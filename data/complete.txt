
import * as ActTme from "../../act/time.action";
import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";


var bit, val, idx, dex, lst, dat, src;

export const initControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {


  bal.slv({ intBit: { idx: "init-control" } });

  return cpy;
};






export const createControl = (cpy: ControlModel, bal: ControlBit, ste: State) => {

  // const { exec } = require('child_process');

  // exec('npx quasar build', async (err, stdout, stderr) => {

  //   if (bal.slv != null) bal.slv({ condBit: { idx: "create-control", dat: {} } });

  // })


  return cpy;
};

export const testControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {

  //bit = await ste.bus(ActCrd.READ_CARDANO, {})

  bit = await window['TIME'](ActTme.RANDOM_TIME, { idx: 'clk00' })

  if (bal.slv != null) bal.slv({ condBit: { idx: "test-control", val:1, dat: { tmeBit:bit } } });

  return cpy;
};





var patch = (ste, type, bale) => ste.dispatch({ type, bale });







import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const accessControl = (cpy: ControlModel, bal: ControlBit, ste: State) => {
  cpy.access = bal.val

  cpy.lastUpdateTimeLong = 0;
  cpy.deltaHoldLong = 0;

  cpy.lastUpdateTimeShort = 0;
  cpy.deltaHoldShort = 0;

  cpy.shortValue = cpy.maxShort

  cpy.tinyCount = 0;

  cpy.delayUntil = Date.now() + 100;

  var clientLocal = cpy.clientLocal;
  var serverLocal = cpy.serverLocal;

  var localLocation = cpy.localLocation;
  var remoteLocation = cpy.remoteLocation

  bal.slv({ ctlBit: { idx: "access-control", val: cpy.access, dat: { clientLocal, serverLocal, localLocation, remoteLocation } } });
  return cpy;
};

import * as ActClk from "../../act/clock.action";
import * as ActTme from "../../act/time.action";

import * as ActInc from "../../act/increment.action";
import * as ActBby from "../../act/babylon.action";
import * as ActMku from "../../act/miku.action";
import * as ActScr from "../../act/screen.action";

import * as ActPrg from "../../act/progress.action";

import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;


export const advanceControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {

  cpy.dex += 1;
  //const bit = await window['TIME'](ActPrg.UPDATE_PROGRESS, { idx: cpy.idxInc, src: cpy.idxClk });
  
  bal.slv({ ctlBit: { idx: "advance-control" } });
  return cpy;
};



import * as ActClr from "../../act/color.action";
import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const dataControl = (cpy: ControlModel, bal: ControlBit, ste: State) => {

  

  var colorList

  fetch('./data/color/000.color.name.json') // Example API endpoint
    .then(response => {
      if (!response.ok) { // Check if the response status is within the 200-299 range
        throw new Error(`HTTP error! Status: ${response.status}`); // Throw an error for bad responses
      }
      return response.json(); // Parse the JSON data from the response
    })
    .then(async (data) => {
      colorList = data;


      bit = await window['SOWER'](ActClr.OPEN_COLOR, { lst: colorList })
      cpy.colorListSize = bit.clrBit.val


      bit = await window['SOWER'](ActClr.BASKET_COLOR, {})

      bal.slv({ ctlBit: { idx: "data-control", val: cpy.colorListSize } });

    })
    .catch(error => {
      console.error('There was a problem with the fetch operation:', error); // Handle errors
    });


  return cpy;
};

import * as ActClk from "../../act/clock.action";
import * as ActTme from "../../act/time.action";

import * as ActInc from "../../act/increment.action";
import * as ActBby from "../../act/babylon.action";
import * as ActMku from "../../act/miku.action";
import * as ActScr from "../../act/screen.action";

import * as ActPrg from "../../act/progress.action";

import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;


export const incrementControl = (cpy: ControlModel, bal: ControlBit, ste: State) => {

  cpy.idxInc = bal.src

  bal.slv({ ctlBit: { idx: "increment-control", src: bal.src } });

  return cpy;
};


import * as ActClk from "../../act/clock.action";
import * as ActTme from "../../act/time.action";
import * as ActInc from "../../act/increment.action";

import * as ActCan from "../../act/container.action";
import * as ActGph from "../../act/graphic.action";
import * as ActTxt from "../../act/text.action";
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";
import * as ActHex from "../../act/hexagon.action";
import * as ActFgn from "../../act/focigon.action";
import * as ActFme from "../../act/frame.action";
import * as ActApp from "../../act/application.action";

import * as ActBby from "../../act/babylon.action";
import * as ActMku from "../../act/miku.action";
import * as ActScr from "../../act/screen.action";



import * as PVT from '../../val/pivot'

import * as ActCtl from '../control.action'
import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const openControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {

  cpy.opened = 1;

  
  //now for the colors




  //NEED DOCUMENT TO MAKE THESE CALLS WORK
  //NEED DOCUMENT TO MAKE THESE CALLS WORK
  //NEED DOCUMENT TO MAKE THESE CALLS WORK

  if (typeof document === 'undefined') return bal.slv({ ctlBit: { idx: "open-control", src: 'no document' } });
  if (document === undefined) return bal.slv({ ctlBit: { idx: "open-control", src: 'no document' } });

  await new Promise(resolve => setTimeout(resolve, 10));

  await ste.hunt(ActCtl.DATA_CONTROL, { src: 'color-list' })
  
  //bit = await window[PVT.SHADE](ActApp.WRITE_APPLICATION, { idx: 'app00', src: 'surface00' })

  //var app = bit.appBit.dat.bit

  //bit = await window[PVT.SHADE](ActCan.WRITE_CONTAINER, { idx: 'can00', src: 'app00' })
 // dat = bit.canBit.dat;
 // var container = dat['bit']
  //app.stage.addChild(container);

  //bit = await window[PVT.SHADE](ActGph.WRITE_GRAPHIC, { idx: 'gph00' })
  //dat = bit.gphBit.dat;
  //var graphic = dat['bit']
  //container.addChild(graphic)

  //bit = await window[PVT.SHADE](ActGph.WRITE_GRAPHIC, { idx: 'gph01' })
  //dat = bit.gphBit.dat;
  //var graphic = dat['bit']
  //container.addChild(graphic)

  //graphic.rect(1, 1, 950, 115)
  //graphic.fill(0x0ff00);

  //container.x = app.screen.width / 2;
  //container.y = app.screen.height / 2;

  //bit = await window[PVT.SHADE](ActTxt.WRITE_TEXT, { idx: 'txt00', dat: { txt: '' } })
  //dat = bit.txtBit.dat;
  //var text = dat['bit']
  //app.stage.addChild(text)

  //bit = await window[PVT.SHADE](ActHex.WRITE_HEXAGON, { idx: 'hex00', dat: { dat: { gph: 'gph00', bit: map } } })
  //bit = await window[PVT.SHADE](ActFgn.WRITE_FOCIGON, { idx: 'fgn00', src: 'app00', dat: { gph: 'gph01', bit: focus } })

  //var text = dat['bit']
  //app.stage.addChild(text)

  

  await window['SOLID'](ActBby.OPEN_BABYLON, { src: 'surface00' })
  await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', src: 'greasi/00.pmx', dat: { position: { z: -7 } } })
  await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', dat: { position: { z: 40, x: -15 } } })
  await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00' })

  bal.slv({ ctlBit: { idx: "open-control" } });
  return cpy;
};


import * as ActClk from "../../act/clock.action";
import * as ActTxt from "../../act/text.action";

import * as ActHex from "../../act/hexagon.action";
import * as ActFgn from "../../act/focigon.action";
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";
import * as ActClr from "../../act/color.action";

import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;
export const outputControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {

  var output = { dex: 0, now: null, colorListSize: 0 };
  output.dex = cpy.dex

  bit = await window['TIME'](ActClk.READ_CLOCK, { idx: 'clk00' })

  output.now = bit.clkBit.dat

  bit = await window['SPACE'](ActMap.READ_HEXMAP, { idx: 'map00' })
  var map = bit.mapBit.dat.bit

  bit = await window['SPACE'](ActFoc.READ_FOCUS, { idx: 'foc00', src: 'map00' })
  var focus = bit.focBit.dat

  if (typeof document === 'undefined') return bal.slv({ ctlBit: { idx: "output-control", src: 'no document', dat: output } });
  if (document === undefined) return bal.slv({ ctlBit: { idx: "output-control", src: 'no document', dat: output } });

  bit = await window['SOWER'](ActClr.ACCESS_COLOR, {})

  var colorListSize = bit.clrBit.dat.val



  output.colorListSize = colorListSize

  //bit = await window['SHADE'](ActTxt.WRITE_TEXT, { idx: 'txt00', dat: { txt: 'You are waking from a dream about colorful flowers and it fills you with great excitement when you consider all the possible outcomes which could come afterward.' } })
  bit = await window['SHADE'](ActHex.WRITE_HEXAGON, { idx: 'hex00', dat: { dat: { gph: 'gph00', bit: map } } })
  bit = await window['SHADE'](ActFgn.WRITE_FOCIGON, { idx: 'fgn00', src: 'app00', dat: { gph: 'gph01', bit: focus } })

  bal.slv({ ctlBit: { idx: "output-control", dat: output } });

  return cpy;
};


import * as ActClk from "../../act/clock.action";
import * as ActEth from "../../act/earth.action";

import * as ActCtr from "../../00.control.unit/control.action";

import { ControlModel } from "../control.model";
import ControlBit from "../fce/control.bit";
import State from "../../99.core/state";

import * as PVT from '../../val/pivot'

var bit, val, idx, dex, lst, dat, src;

export const updateControl = async (cpy: ControlModel, bal: ControlBit, ste: State) => {

  if (cpy.opened == 0) {
    bit = await ste.hunt(ActCtr.OPEN_CONTROL, {})
    bit = window[ PVT.EARTH ](ActEth.OPEN_EARTH, {})
  }
  
  
  // 1. Handle manual override first for immediate action.
  if (bal.val === 1) {
    bit = await ste.hunt(ActCtr.ADVANCE_CONTROL, {})
    bit = await ste.hunt(ActCtr.OUTPUT_CONTROL, {})
    dat = bit.ctlBit.dat
    bal.slv({ ctlBit: { idx: "update-control", dat } });
    return cpy;
  }

  // --- NEW DELAY CHECK ---
  // 2. Enforce the delay for automatic updates.
  // If the current time is before our target delay time, do nothing and exit.
  if (Date.now() < cpy.delayUntil) {
    // We are still within the 100ms delay period.
    // The time that passes here will be correctly calculated on the first update AFTER the delay ends.
    bit = await ste.hunt(ActCtr.OUTPUT_CONTROL, {})
    dat = bit.ctlBit.dat
    bal.slv({ ctlBit: { idx: "update-control", dat } });
    return cpy;
  }

  // 2. Determine the parameters for the current mode (slow or fast tick).
  const isSlowMode = cpy.access === 0;
  const lastUpdateKey = isSlowMode ? 'lastUpdateTimeLong' : 'lastUpdateTimeShort';
  const deltaHoldKey = isSlowMode ? 'deltaHoldLong' : 'deltaHoldShort';
  const threshold = isSlowMode ? cpy.maxLong : cpy.shortValue;

  // 3. Unified Game Loop Logic.
  const now = Date.now();
  if (!cpy[lastUpdateKey]) {
    cpy[lastUpdateKey] = now; // Initialize time if it's the first run for this mode.
  }

  const timeDelta = now - cpy[lastUpdateKey];
  cpy[lastUpdateKey] = now;
  cpy[deltaHoldKey] += timeDelta;

  // 4. Process all accumulated ticks. (Crucial for handling idle time)
  // Using 'while' instead of 'if' ensures we "catch up" on all missed ticks.
  while (cpy[deltaHoldKey] >= threshold) {
    bit = await ste.hunt(ActCtr.ADVANCE_CONTROL, {})
    cpy[deltaHoldKey] -= threshold;

    // 5. Handle logic specific to the "fast tick" mode.
    if (!isSlowMode) {
      cpy.tinyCount += 1;
      if (cpy.tinyCount > cpy.tinyMax) {
        cpy.shortValue = cpy.maxTiny; // The fast tick rate can change over time.
      }
    }
  }

  // 6. Final callback, same for all paths.

  bit = await ste.hunt(ActCtr.OUTPUT_CONTROL, {})
  dat = bit.ctlBit.dat
  
  bal.slv({ ctlBit: { idx: "update-control", dat } });

  return cpy;

};


import { Action } from "../99.core/interface/action.interface";
import  ControlBit  from "./fce/control.bit";

// Control actions

export const INIT_CONTROL = "[Control action] Init Control";
export class InitControl implements Action {
 readonly type = INIT_CONTROL;
 constructor(public bale: ControlBit) {}
}

export const UPDATE_CONTROL = "[Control action] Update Control";
export class UpdateControl implements Action {
 readonly type = UPDATE_CONTROL;
 constructor(public bale: ControlBit) {}
}

export const OPEN_CONTROL = "[Open action] Open Control";
 export class OpenControl implements Action {
 readonly type = OPEN_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const CREATE_CONTROL = "[Create action] Create Control";
 export class CreateControl implements Action {
 readonly type = CREATE_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const TEST_CONTROL = "[Test action] Test Control";
 export class TestControl implements Action {
 readonly type = TEST_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const ACCESS_CONTROL = "[Access action] Access Control";
 export class AccessControl implements Action {
 readonly type = ACCESS_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const OUTPUT_CONTROL = "[Output action] Output Control";
 export class OutputControl implements Action {
 readonly type = OUTPUT_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const ADVANCE_CONTROL = "[Advance action] Advance Control";
 export class AdvanceControl implements Action {
 readonly type = ADVANCE_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export const INCREMENT_CONTROL = "[Increment action] Increment Control";
 export class IncrementControl implements Action {
 readonly type = INCREMENT_CONTROL;
 constructor(public bale: ControlBit) {}
 }

 export const DATA_CONTROL = "[Control action] Data Control";
 export class DataControl implements Action {
 readonly type = DATA_CONTROL;
 constructor(public bale: ControlBit) {}
 }
 
export type Actions = | InitControl | UpdateControl 
| OpenControl
| CreateControl
| TestControl
| AccessControl
| OutputControl
| AdvanceControl
| IncrementControl
| DataControl
export { initControl  } from "./buz/0.control.buzz";
export { updateControl  } from "./buz/updateControl.buzz";
export { openControl  } from "./buz/openControl.buzz";
export { createControl  } from "./buz/0.control.buzz";
export { testControl  } from "./buz/0.control.buzz";
export { accessControl  } from "./buz/accessControl.buzz";
export { outputControl  } from "./buz/outputControl.buzz";
export { advanceControl  } from "./buz/advanceControl.buzz";
export { incrementControl  } from "./buz/incrementControl.buzz";
export { dataControl  } from "./buz/dataControl.buzz";
import Control from "./fce/control.interface";
import ControlBit from "./fce/control.interface";

export class ControlModel implements Control {
    idx: string = '111.control';
    //controlBitList: ControlBit[] = [];
    //controlBits: any = {};
    opened: number = 0
    
    access: number = 0
    dex: number = 0;

    lastUpdateTimeLong: number = 0;
    deltaHoldLong: number = 0;
    maxLong: number = 1000;
    
    lastUpdateTimeShort: number = 0;
    deltaHoldShort: number = 0;
    maxShort: number = 100;

    shortValue:number =0 ;

    tinyCount:number = 0;
    tinyMax:number = 20;

    maxTiny: number = 50;

    delayUntil: number = 0;

    timeBit:any;

    colorListSize:number =0;

    clientLocal:boolean = true;
    serverLocal:boolean = false;

    localLocation:string = 'http://localhost:3005/api/'
    remoteLocation:string = "https://zero01-alligator-quest.onrender.com/api"

}

import * as clone from "clone-deep";
import * as Act from "./control.action";
import { ControlModel } from "./control.model";
import * as Buzz from "./control.buzzer";
import State from "../99.core/state";

export function reducer(model: ControlModel = new ControlModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_CONTROL:
            return Buzz.updateControl(clone(model), act.bale, state);

        case Act.INIT_CONTROL:
            return Buzz.initControl(clone(model), act.bale, state);

        case Act.OPEN_CONTROL:
            return Buzz.openControl(clone(model), act.bale, state);

        case Act.CREATE_CONTROL:
            return Buzz.createControl(clone(model), act.bale, state);

        case Act.TEST_CONTROL:
            return Buzz.testControl(clone(model), act.bale, state);

        case Act.ACCESS_CONTROL:
            return Buzz.accessControl(clone(model), act.bale, state);

        case Act.OUTPUT_CONTROL:
            return Buzz.outputControl(clone(model), act.bale, state);

        case Act.ADVANCE_CONTROL:
            return Buzz.advanceControl(clone(model), act.bale, state);

        case Act.INCREMENT_CONTROL:
            return Buzz.incrementControl(clone(model), act.bale, state);


        case Act.DATA_CONTROL:
            return Buzz.dataControl(clone(model), act.bale, state);

        default:
            return model;
    }
}

import State from "../99.core/state";


export default class ControlUnit {

 constructor(state: State) {
 }
}


export default interface ControlBit {
  idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  ControlBit  from "./control.bit";

export default interface Control {
 // idx:string;
 // controlBitList: ControlBit[];
 // controlBits:any;

}

global.CONTROL = require("../dist/111.control/hunt");
global.CONTROL.ActCtl = require("../dist/111.control/00.control.unit/control.action");







import { TurnModel } from "../turn.model";
import TurnBit from "../fce/turn.bit";
import State from "../../99.core/state";


import * as ActTrn from "../../01.turn.unit/turn.action";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action";

import * as ActCrd from "../../act/cardano.action";
import * as ActBlk from "../../act/block.action";

var bit, val, idx, dex, lst, dat, src;

export const initTurn = async (cpy: TurnModel, bal: TurnBit, ste: State) => {


  bal.slv({ intBit: { idx: "init-turn" } });

  return cpy;
};

export const updateTurn = async (cpy: TurnModel, bal: TurnBit, ste: State) => {


  
  var diff = bit.blkBit.dat.diff

  if (diff == 0) {

    bal.slv({ trnBit: { idx: "update-turn", dat: bit } });
    return cpy
  }

  diff

  //autho code to maniuplate

  bal.slv({ trnBit: { idx: "update-turn", dat: bit } });
  return cpy;
};



export const openTurn = async (cpy: TurnModel, bal: TurnBit, ste: State) => {

  bal.slv({ trnBit: { idx: "open-turn", dat: bit } });

  return cpy;
};




export const readTurn = (cpy: TurnModel, bal: TurnBit, ste: State) => {
  debugger
  return cpy;
};


export const startTurn = (cpy: TurnModel, bal: TurnBit, ste: State) => {

  bal.slv({ trnBit: { idx: "start-turn", dat: bit } });

  return cpy;
};

export default interface TurnBit {
  idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  TurnBit  from "./turn.bit";

export default interface Turn {
 // idx:string;
 // turnBitList: TurnBit[];
 // turnBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  TurnBit  from "./fce/turn.bit";

// Turn actions

export const INIT_TURN = "[Turn action] Init Turn";
export class InitTurn implements Action {
 readonly type = INIT_TURN;
 constructor(public bale: TurnBit) {}
}

export const UPDATE_TURN = "[Turn action] Update Turn";
export class UpdateTurn implements Action {
 readonly type = UPDATE_TURN;
 constructor(public bale: TurnBit) {}
}

export const OPEN_TURN = "[Open action] Open Turn";
 export class OpenTurn implements Action {
 readonly type = OPEN_TURN;
 constructor(public bale: TurnBit) {}
 }
 
export const READ_TURN = "[Read action] Read Turn";
 export class ReadTurn implements Action {
 readonly type = READ_TURN;
 constructor(public bale: TurnBit) {}
 }
 
export const START_TURN = "[Start action] Start Turn";
 export class StartTurn implements Action {
 readonly type = START_TURN;
 constructor(public bale: TurnBit) {}
 }
 
export type Actions = | InitTurn | UpdateTurn 
| OpenTurn
| ReadTurn
| StartTurn
export { initTurn  } from "./buz/turn.buzz";
export { updateTurn  } from "./buz/turn.buzz";
export { openTurn  } from "./buz/turn.buzz";
export { readTurn  } from "./buz/turn.buzz";
export { startTurn  } from "./buz/turn.buzz";
import Turn from "./fce/turn.interface";
import TurnBit from "./fce/turn.interface";

export class TurnModel implements Turn {
 //idx:string;
 //turnBitList: TurnBit[] = [];
 //turnBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./turn.action";
import { TurnModel } from "./turn.model";
import * as Buzz from "./turn.buzzer";
import State from "../99.core/state";

export function reducer(model: TurnModel = new TurnModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_TURN:
 return Buzz.updateTurn(clone(model), act.bale, state);

 case Act.INIT_TURN:
 return Buzz.initTurn(clone(model), act.bale, state);

case Act.OPEN_TURN:
 return Buzz.openTurn(clone(model), act.bale, state);
 
case Act.READ_TURN:
 return Buzz.readTurn(clone(model), act.bale, state);
 
case Act.START_TURN:
 return Buzz.startTurn(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class TurnUnit {

 constructor(state: State) {
 }
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
    type: string;
    bale?: T;
}

export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_APPLICATION = "[Application action] Init Application";
export const UPDATE_APPLICATION = "[Application action] Update Application";
export const READ_APPLICATION = "[Read action] Read Application";
export const WRITE_APPLICATION = "[Write action] Write Application";
export const REMOVE_APPLICATION = "[Remove action] Remove Application";
export const DELETE_APPLICATION = "[Delete action] Delete Application";
export const CREATE_APPLICATION = "[Create action] Create Application";
export const TEST_APPLICATION = "[Test action] Test Application";
export const INIT_BABYLON = "[Babylon action] Init Babylon";
export const UPDATE_BABYLON = "[Babylon action] Update Babylon";
export const OPEN_BABYLON = "[Babylon action] Open Babylon";
export const RECORD_BABYLON = "[Babylon action] Record Babylon";
export const ACTION_BABYLON = "[Babylon action] Action Babylon";
export const CUT_BABYLON = "[Babylon action] Cut Babylon";
export const CAMERA_BABYLON = "[Babylon action] Cut Babylon";
export const INIT_BLOCK = "[Block action] Init Block";
export const UPDATE_BLOCK = "[Block action] Update Block";
export const READ_BLOCK = "[Read action] Read Block";
export const WRITE_BLOCK = "[Write action] Write Block";
export const REMOVE_BLOCK = "[Remove action] Remove Block";
export const DELETE_BLOCK = "[Delete action] Delete Block";
export const CREATE_BLOCK = "[Create action] Create Block";
export const NOW_BLOCK = "[Now action] Now Block";
export const OPEN_BLOCK = "[Open action] Open Block";
export const HASH_BLOCK = "[Hash action] Hash Block";

export const INIT_CANVAS = "[Canvas action] Init Canvas";
export const UPDATE_CANVAS = "[Canvas action] Update Canvas";
export const READ_CANVAS = "[Read action] Read Canvas";
export const WRITE_CANVAS = "[Write action] Write Canvas";
export const DELETE_CANVAS = "[Delete action] Delete Canvas";
export const REMOVE_CANVAS = "[Remove action] Remove Canvas";
export const CREATE_CANVAS = "[Create action] Create Canvas";
export const NEST_CANVAS = "[Nest action] Nest Canvas";
export const INIT_CARDANO = "[Cardano action] Init Cardano";
export const UPDATE_CARDANO = "[Cardano action] Update Cardano";
export const TEST_CARDANO = "[Test action] Test Cardano";
export const INIT_CHOICE = "[Choice action] Init Choice";
export const UPDATE_CHOICE = "[Choice action] Update Choice";
export const OPEN_CHOICE = "[Open action] Open Choice";
export const KEY_CHOICE = "[Key action] Key Choice";
export const TOWER_CHOICE = "[Tower action] Tower Choice";

export const INIT_CLOCK = "[Clock action] Init Clock";
export const UPDATE_CLOCK = "[Clock action] Update Clock";
export const READ_CLOCK = "[Read action] Read Clock";
export const WRITE_CLOCK = "[Write action] Write Clock";
export const REMOVE_CLOCK = "[Remove action] Remove Clock";
export const CREATE_CLOCK = "[Create action] Create Clock";
export const DELETE_CLOCK = "[Delete action] Delete Clock";
export const BLOCK_CLOCK = "[Block action] Block Clock";
export const LIST_CLOCK = "[List action] List Clock";
export const TEST_CLOCK = "[Test action] Test Clock";
export const INIT_COLOR = "[Color action] Init Color";
export const UPDATE_COLOR = "[Color action] Update Color";
export const OPEN_COLOR = "[Open action] Open Color";
export const READ_COLOR = "[Read action] Read Color";
export const WRITE_COLOR = "[Write action] Write Color";
export const REMOVE_COLOR = "[Remove action] Remove Color";
export const DELETE_COLOR = "[Delete action] Delete Color";
export const CREATE_COLOR = "[Create action] Create Color";
export const LIST_COLOR = "[List action] List Color";
export const RANDOM_COLOR = "[Random action] Random Color";
export const BASKET_COLOR = "[Basket action] Basket Color";
export const ACCESS_COLOR = "[Access action] Access Color";
export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";
export const INIT_CONTAINER = "[Container action] Init Container";
export const UPDATE_CONTAINER = "[Container action] Update Container";
export const READ_CONTAINER = "[Read action] Read Container";
export const WRITE_CONTAINER = "[Write action] Write Container";
export const CREATE_CONTAINER = "[Create action] Create Container";
export const SURFACE_CONTAINER = "[Surface action] Surface Container";
export const ADD_CONTAINER = "[Add action] Add Container";
export const REMOVE_CONTAINER = "[Remove action] Remove Container";
export const DELETE_CONTAINER = "[Delete action] Delete Container";
export const LIST_CONTAINER = "[List action] List Container";
export const INIT_DISK = '[Disk action] Init Disk'
export const UPDATE_DISK = '[Disk action] Update Disk'
export const READ_DISK = '[Disk action] Read Disk'
export const WRITE_DISK = '[Disk action] Write Disk'
export const INDEX_DISK = '[Index action] Index Disk'
export const LOAD_LIST_DISK = '[Load_list action] Load_list Disk'
export const COPY_DISK = '[Copy action] Copy Disk'
export const FRAME_DISK = '[Frame action] Frame Disk'
export const BATCH_DISK = '[Batch action] Batch Disk'
export const TRASH_DISK = '[Trash action] Trash Disk'
export const ENSURE_DISK = '[Ensure action] Ensure Disk'
export const DELETE_DISK = '[Delete action] Delete Disk'
export const INIT_EARTH = "[Earth action] Init Earth";
export const OPEN_EARTH = "[Earth action] Open Earth";
export const UPDATE_EARTH = "[Earth action] Update Earth";
export const ADVANCE_EARTH = "[Advance action] Advance Earth";
export const OUTPUT_EARTH = "[Output action] Output Earth";
export const ACCESS_EARTH = "[Access action] Access Earth";
export const INIT_FOCIGON = "[Focigon action] Init Focigon";
export const UPDATE_FOCIGON = "[Focigon action] Update Focigon";
export const READ_FOCIGON = "[Read action] Read Focigon";
export const WRITE_FOCIGON = "[Write action] Write Focigon";
export const REMOVE_FOCIGON = "[Remove action] Remove Focigon";
export const CREATE_FOCIGON = "[Create action] Create Focigon";
export const DELETE_FOCIGON = "[Delete action] Delete Focigon";
export const INIT_FOCUS = "[Focus action] Init Focus";
export const AWAKE_FOCUS = "[Focus action] Awake Focus";
export const UPDATE_FOCUS = "[Focus action] Update Focus";
export const OPEN_FOCUS = "[Focus action] Open Focus";
export const CREATE_FOCUS = "[Focus action] Create Focus";
export const READ_FOCUS = "[Read action] Read Focus";
export const WRITE_FOCUS = "[Write action] Write Focus";
export const REMOVE_FOCUS = "[Remove action] Remove Focus";
export const DELETE_FOCUS = "[Delete action] Delete Focus";
export const CORNER_FOCUS = "[Corner action] Corner Focus";
export const LIST_FOCUS = "[List action] List Focus";
 export const SPIN_RIGHT_FOCUS = "[List action] Spin Left Focus";
 export const SPIN_LEFT_FOCUS = "[List action] Spin Right Focus";
 export const FORWARD_FOCUS = "[List action] Forward Focus";
 export const BACKWARD_FOCUS = "[List action] Backward Focus";
 export const CENTER_FOCUS = "[List action] Center Focus";
export const BOND_FOCUS = "[Bond action] Bond Focus";
export const LOCATE_FOCUS = "[Locate action] Locate Focus";
export const VISION_FOCUS = "[Vision action] Vision Focus";
export const SELECT_FOCUS = "[Select action] Select Focus";
 export const MODEL_FOCUS = "[Select action] Model Focus";
 export const BROWNIAN_FOCUS = "[Select action] Brownian Focus";
export const INIT_FRAME = "[Frame action] Init Frame";
export const UPDATE_FRAME = "[Frame action] Update Frame";
export const READ_FRAME = "[Read action] Read Frame";
export const WRITE_FRAME = "[Write action] Write Frame";
export const REMOVE_FRAME = "[Remove action] Remove Frame";
export const CREATE_FRAME = "[Create action] Create Frame";
export const DELETE_FRAME = "[Delete action] Delete Frame";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const CREATE_GRAPHIC = "[Create action] Create Graphic";
export const REMOVE_GRAPHIC = "[Remove action] Remove Graphic";
export const DELETE_GRAPHIC = "[Delete action] Delete Graphic";

export const INIT_GRID = "[Grid action] Init Grid";
export const UPDATE_GRID = "[Grid action] Update Grid";

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export const READ_HEXAGON = "[Read action] Read Hexagon";
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
export const REMOVE_HEXAGON = "[Replace action] Remove Hexagon";
export const DELETE_HEXAGON = "[Delete action] Delete Hexagon";
export const FOCUS_HEXAGON = "[Focus action] Focus Hexagon";
export const HEXMAP_HEXAGON = "[Hexmap action] Hexmap Hexagon";
export const INIT_HEXMAP = "[Hexmap action] Init Hexmap";
export const UPDATE_HEXMAP = "[Hexmap action] Update Hexmap";
export const OPEN_HEXMAP = "[Hexmap action] Open Hexmap";
export const READ_HEXMAP = "[Read action] Read Hexmap";
export const WRITE_HEXMAP = "[Write action] Write Hexmap";
export const CREATE_HEXMAP = "[Create action] Create Hexmap";
export const COPY_HEXMAP = "[Copy action] Copy Hexmap";
export const ATLAS_HEXMAP = "[Atlas action] Atlas Hexmap";
export const GEOJSON_HEXMAP = "[Geojson action] Geojson Hexmap";
export const TOOL_HEXMAP = "[Tool action] Tool Hexmap";
export const SAVE_HEXMAP = "[Save action] Save Hexmap";
export const STORE_HEXMAP = "[Store action] Store Hexmap";
export const SHAPE_HEXMAP = "[Shape action] Shape Hexmap";
export const LOAD_HEXMAP = "[Load action] Load Hexmap";
export const LIST_HEXMAP = "[List action] List Hexmap";
export const REPLACE_HEXMAP = "[Replace action] Replace Hexmap";
export const NAME_HEXMAP = "[Name action] Name Hexmap";
export const SEEK_HEXMAP = "[Seek action] Seek Hexmap";
export const FOCUSING_HEXMAP = "[Focusing action] Focusing Hexmap";
export const DEFOCUS_HEXMAP = "[Defocus action] Defocus Hexmap";
export const SELECT_HEXMAP = "[Select action] Select Hexmap";
export const ADD_HEXMAP = "[Select action] Add Hexmap";
export const POUCH_HEXMAP = "[Select action] Pouch Hexmap";
export const INIT_INCREMENT = "[Increment action] Init Increment";
export const UPDATE_INCREMENT = "[Increment action] Update Increment";
export const READ_INCREMENT = "[Read action] Read Increment";
export const WRITE_INCREMENT = "[Write action] Write Increment";
export const REMOVE_INCREMENT = "[Remove action] Remove Increment";
export const DELETE_INCREMENT = "[Delete action] Delete Increment";
export const CREATE_INCREMENT = "[Create action] Create Increment";
export const LIST_INCREMENT = "[List action] List Increment";
export const INIT_INPUT = "[Input action] Init Input";
export const UPDATE_INPUT = "[Input action] Update Input";
export const OPEN_INPUT = "[Open action] Open Input";
export const INIT_MIKU = "[Miku action] Init Miku";
export const UPDATE_MIKU = "[Miku action] Update Miku";
export const READ_MIKU = "[Miku action] Read Miku";
export const WRITE_MIKU = "[Miku action] Write Miku";
export const DELETE_MIKU = "[Miku action] Delete Miku";
export const REMOVE_MIKU = "[Miku action] Remove Miku";
export const CREATE_MIKU = "[Miku action] Create Miku";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_PROGRESS = "[Progress action] Init Progress";
export const UPDATE_PROGRESS = "[Progress action] Update Progress";

export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SCREEN = "[Screen action] Init Screen";
export const UPDATE_SCREEN = "[Screen action] Update Screen";
export const READ_SCREEN = "[Read action] Read Screen";
export const WRITE_SCREEN = "[Write action] Write Screen";
export const REMOVE_SCREEN = "[Remove action] Remove Screen";
export const DELETE_SCREEN = "[Delete action] Delete Screen";
export const CREATE_SCREEN = "[Create action] Create Screen";
export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const TEST_SPACE = "[Test action] Test Space";
export const INIT_SPARK = "[Spark action] Init Spark";
export const UPDATE_SPARK = "[Spark action] Update Spark";
export const READ_SPARK = "[Read action] Read Spark";
export const WRITE_SPARK = "[Write action] Write Spark";
export const REMOVE_SPARK = "[Remove action] Remove Spark";
export const DELETE_SPARK = "[Delete action] Delete Spark";
export const CREATE_SPARK = "[Create action] Create Spark";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const OPEN_TERMINAL = "[Terminal action] Open Terminal";
export const FOCUS_TERMINAL = "[Terminal action] Focus Terminal";
export const WRITE_TERMINAL = "[Terminal action] Write Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const CLEAR_TERMINAL = "[Terminal action] Clear Terminal";
export const INPUT_TERMINAL = "[Terminal action] Input Terminal";
export const TABLE_TERMINAL = "[Terminal action] Table Terminal";
export const CLOSE_TERMINAL = "[Terminal action] Close Terminal";
export const ROOT_TERMINAL = "[Terminal action] Root Terminal";
export const CONTENT_TERMINAL = "[Terminal action] Content Terminal";
export const ADD_PORT = "[Terminal action] Add Port";

export const INIT_TEXT = "[Text action] Init Text";
export const UPDATE_TEXT = "[Text action] Update Text";
export const READ_TEXT = "[Read action] Read Text";
export const WRITE_TEXT = "[Write action] Write Text";
export const CREATE_TEXT = "[Create action] Create Text";
export const REMOVE_TEXT = "[Remove action] Remove Text";
export const DELETE_TEXT = "[Delete action] Delete Text";
export const LIST_TEXT = "[List action] List Text";
export const INIT_TIME = "[Time action] Init Time";
export const UPDATE_TIME = "[Time action] Update Time";
export const TEST_TIME = "[Reduce action] Test Time";
export const RANDOM_TIME = "[Random action] Random Time";

export const INIT_VISAGE = "[Visage action] Init Visage";
export const UPDATE_VISAGE = "[Visage action] Update Visage";
export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage"; 
export const READ_VISAGE = "[Read action] Read Visage";
export const WRITE_VISAGE = "[Write action] Write Visage"; 
export const CREATE_VISAGE = "[Create action] Create Visage";
export const SIZE_VISAGE = "[Size action] Size Visage";
export const RENDER_VISAGE = "[Render action] Render Visage";
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import ControlUnit from "./00.control.unit/control.unit";
import TurnUnit from "./01.turn.unit/turn.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Control from "./00.control.unit/fce/control.interface";
import { ControlModel } from "./00.control.unit/control.model";
import Turn from "./01.turn.unit/fce/turn.interface";
import { TurnModel } from "./01.turn.unit/turn.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [ControlUnit,TurnUnit,CollectUnit,BusUnit];

import * as reduceFromControl from "./00.control.unit/control.reduce";
import * as reduceFromTurn from "./01.turn.unit/turn.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 control : reduceFromControl.reducer, 
turn : reduceFromTurn.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 control : Control = new ControlModel();
turn : Turn = new TurnModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
 hunt:null,
 state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
 

 
 init();

 var slv;
 const promo = new Promise((rslv, rjct) => (slv = rslv));

 if (obj == null) obj = {};
 if (obj.slv == null) obj.slv = (val0) => slv(val0);
 
 sim.state.dispatch({ type: typ, bale: obj });
 return promo;
};

var init = () => {
 if (sim.state != null) return;
 sim.state = new State();
 sim.state.pivot = sim;
 sim.state.hunt = sim.hunt
 for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const VERTICAL = "vertical";
export const HORIZONTAL = "horizontal";



export const BLACK: string = "black";
export const RED: string = "red";
export const GREEN: string = "green";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";
export const CYAN: string = "cyan";
export const WHITE: string = "white";
export const BLUE: string = "blue";
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export type Position <Type> = {
    x: number;
    y: number;
} & Type


export type GridFill =Position<{
    xSpan:number;
    ySpan:number;
}>

export const TOP_FULL_IDX = 'top-fill';
export const MID_FULL_IDX = 'mid-fill';
export const BOT_FULL_IDX  = 'bot-fill';

export const TOP_FULL_BIT:GridFill= {x:0, y:0, xSpan:12, ySpan:4};
export const MID_FULL_BIT:GridFill= {x:0, y:4, xSpan:12, ySpan:5};
export const BOT_FULL_BIT:GridFill= {x:0, y:8, xSpan:12, ySpan:4};

export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const HOURS = "incHrs";
export const MINUTES = "incMin";
export const DAYS = "incDay";
export const SECONDS = "incSec";
export const DEFAULT = "incDft";


export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

export const CONTROL = "CONTROL";
export const TIME = "TIME";
export const SPACE = "SPACE";
export const EARTH = "EARTH";
export const SOWER = "SOWER";
export const SHADE = "SHADE";
export const SOLID = "SOLID";
export const MARKET = "MARKET";
export const LIBRARY = "LIBRARY";

export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
export const GEOJSON = "geojson";
export const RECTANGLE = "rectangle";
export const TRIANGLE = "triangle";
export const HEXAGON = "hexagon";
export const PARALLELOGRAM = "parallelogram";

export const FOCUS = "focus";
export const HEXMAP = "hexmap";
export const CLOCK: string = "clock";
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";
import * as ActErt from '../earth.action'
import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../act/spark.action'
import * as ActTme from '../../act/time.action'

import * as ActClk from '../../act/clock.action'
import * as ActInc from '../../act/increment.action'
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

import * as ActPrg from "../../act/progress.action";

import * as PVT from '../../val/pivot'

import * as Increment from '../../val/increment'

var bit

export const accessEarth = async (cpy: EarthModel, bal: EarthBit, ste: State) => {

  cpy.access = bal.val

  cpy.lastUpdateTimeLong = 0;
  cpy.deltaHoldLong = 0;

  cpy.lastUpdateTimeShort = 0;
  cpy.deltaHoldShort = 0;

  cpy.shortValue = cpy.maxShort

  cpy.tinyCount = 0;

  cpy.delayUntil = Date.now() + 100;

  bit = await ste.hunt(ActErt.UPDATE_EARTH, {})

  bal.slv({ ertBit: { idx: "access-earth", val: cpy.access, dat: {} } });

  return cpy;
};





import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../act/spark.action'
import * as ActTme from '../../act/time.action'

import * as ActClk from '../../act/clock.action'
import * as ActInc from '../../act/increment.action'
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

import * as ActPrg from "../../act/progress.action";

import * as PVT from '../../val/pivot'

import * as Increment from '../../val/increment'

var bit

export const advanceEarth = async (cpy: EarthModel, bal: EarthBit, ste: State) => {

    cpy.dex += 1;
    

    bit = await window['TIME'](ActPrg.UPDATE_PROGRESS, { idx: cpy.idxInc, src: cpy.idxClk });

    

     
  bal.slv({ ertBit: { idx: "advance-earth" } });

    return cpy;
};






import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

export const initEarth = (cpy: EarthModel, bal: EarthBit, ste: State) => {

    bal.slv({ intBit: { idx: "init-earth", dat: { src: 'genesis' } } });

    return cpy;
};






import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../act/spark.action'
import * as ActTme from '../../act/time.action'

import * as ActClk from '../../act/clock.action'
import * as ActClr from '../../act/color.action'

import * as ActInc from '../../act/increment.action'
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

import * as PVT from '../../val/pivot'

import * as Increment from '../../val/increment'

var bit

export const openEarth = async (cpy: EarthModel, bal: EarthBit, ste: State) => {

    if (cpy.opened == 1) {
        bal.slv({ ertBit: { idx: "open-earth", dat: { val: cpy.opened } } });
        return cpy
    }


    cpy.opened = 1

    cpy.idxClk = 'clk00'
    cpy.idxInc = 'inc00'

    var clk = { day: 0, hrs: 0, min: 0, mth: 0, sec: 0, yrs: 1822 }

    bit = await window[PVT.TIME](ActClk.WRITE_CLOCK, { idx: cpy.idxClk, clk })

    var incDft = { day: 0, hrs: 0, min: 0, mth: 0, sec: 6, yrs: 0 }

    var incHrs = { day: 0, hrs: 1, min: 0, mth: 0, sec: 0, yrs: 0 }
    var incMin = { day: 0, hrs: 0, min: 1, mth: 0, sec: 0, yrs: 0 }
    var incDay = { day: 0, hrs: 16, min: 0, mth: 0, sec: 0, yrs: 0 }
    var incSec = { day: 0, hrs: 0, min: 0, mth: 0, sec: 1, yrs: 0 }

    bit = await window[PVT.TIME](ActInc.WRITE_INCREMENT, { idx: Increment.DEFAULT, inc: incDft })

    bit = await window[PVT.TIME](ActInc.WRITE_INCREMENT, { idx: Increment.HOURS, inc: incHrs })
    bit = await window[PVT.TIME](ActInc.WRITE_INCREMENT, { idx: Increment.MINUTES, inc: incMin })
    bit = await window[PVT.TIME](ActInc.WRITE_INCREMENT, { idx: Increment.DAYS, inc: incDay })
    bit = await window[PVT.TIME](ActInc.WRITE_INCREMENT, { idx: Increment.SECONDS, inc: incSec })

    bit = await window[PVT.TIME](ActTme.RANDOM_TIME, { idx: 'clk00' })

    //ste.hunt(ActCtl.INCREMENT_CONTROL, { src: Increment.DEFAULT })

    bit = await window[PVT.SPACE](ActMap.WRITE_HEXMAP, { idx: 'map00' })
    var map = bit.mapBit.dat.bit
  
    bit = await window[PVT.SPACE](ActFoc.WRITE_FOCUS, { idx: 'foc00', src: 'map00' })
    var focus = bit.focBit.dat

    //var FS = require('fs-extra')

    //var lst = FS.readJsonSync('./public/data/color/000.color.name.json')
    //bit = await window[PVT.SOWER](ActClr.OPEN_COLOR, { lst })

    //bit = await window[PVT.SOWER](ActSpk.WRITE_SPARK, { idx: 'spk00' })

    bal.slv({ ertBit: { idx: "open-earth", dat: { val: cpy.opened } } });

    return cpy;
};





import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../act/spark.action'
import * as ActTme from '../../act/time.action'

import * as ActClk from '../../act/clock.action'
import * as ActInc from '../../act/increment.action'
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

import * as PVT from '../../val/pivot'

import * as Increment from '../../val/increment'

var bit

export const outputEarth = async (cpy: EarthModel, bal: EarthBit, ste: State) => {

    var output = { dex: 0, now: null, map:null, focus:null, colorListSize: 0 };
    output.dex = cpy.dex

    bit = await window['TIME'](ActClk.READ_CLOCK, { idx: cpy.idxClk })

    output.now = bit.clkBit.dat

    bit = await window['SPACE'](ActMap.READ_HEXMAP, { idx: 'map00' })
    output.map = bit.mapBit.dat.bit
    

    bit = await window['SPACE'](ActFoc.READ_FOCUS, { idx: 'foc00', src: 'map00' })
    output.focus = bit.focBit.dat

    bal.slv({ ertBit: { idx: "output-earth", dat: output, val: cpy.opened } });

    return cpy;
};





import * as ActEth from "../earth.action";
import { EarthModel } from "../earth.model";
import EarthBit from "../fce/earth.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../act/spark.action'
import * as ActTme from '../../act/time.action'

import * as ActClk from '../../act/clock.action'
import * as ActInc from '../../act/increment.action'
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

import * as PVT from '../../val/pivot'

import * as Increment from '../../val/increment'

var bit, dat

export const updateEarth = async (cpy: EarthModel, bal: EarthBit, ste: State) => {


    if (cpy.opened == 0) bit = await ste.hunt(ActEth.OPEN_EARTH, {})

    // 1. Handle manual override first for immediate action.
    //if (bal.val === 1) {
    //    bit = await ste.hunt(ActEth.ADVANCE_EARTH, {})
    //    bit = await ste.hunt(ActEth.OUTPUT_EARTH, {})
    //    dat = bit.ctlBit.dat
    //    bal.slv({ ctlBit: { idx: "update-control", dat } });
    //    return cpy;
    // }

    // --- NEW DELAY CHECK ---
    // 2. Enforce the delay for automatic updates.
    // If the current time is before our target delay time, do nothing and exit.
    if (Date.now() < cpy.delayUntil) {
        // We are still within the 100ms delay period.
        // The time that passes here will be correctly calculated on the first update AFTER the delay ends.
        bit = await ste.hunt(ActEth.OUTPUT_EARTH, {})
        dat = bit.ctlBit.dat
        bal.slv({ ctlBit: { idx: "update-control", dat } });
        return cpy;
    }

    // 2. Determine the parameters for the current mode (slow or fast tick).
    const isSlowMode = cpy.access === 0;
    const lastUpdateKey = isSlowMode ? 'lastUpdateTimeLong' : 'lastUpdateTimeShort';
    const deltaHoldKey = isSlowMode ? 'deltaHoldLong' : 'deltaHoldShort';
    const threshold = isSlowMode ? cpy.maxLong : cpy.shortValue;

    // 3. Unified Game Loop Logic.
    const now = Date.now();
    if (!cpy[lastUpdateKey]) {
        cpy[lastUpdateKey] = now; // Initialize time if it's the first run for this mode.
    }

    const timeDelta = now - cpy[lastUpdateKey];
    cpy[lastUpdateKey] = now;
    cpy[deltaHoldKey] += timeDelta;

    // 4. Process all accumulated ticks. (Crucial for handling idle time)
    // Using 'while' instead of 'if' ensures we "catch up" on all missed ticks.
    while (cpy[deltaHoldKey] >= threshold) {
        bit = await ste.hunt(ActEth.ADVANCE_EARTH, {})
        cpy[deltaHoldKey] -= threshold;

        // 5. Handle logic specific to the "fast tick" mode.
        if (!isSlowMode) {
            cpy.tinyCount += 1;
            if (cpy.tinyCount > cpy.tinyMax) {
                cpy.shortValue = cpy.maxTiny; // The fast tick rate can change over time.
            }
        }
    }


    bit = await ste.hunt(ActEth.OUTPUT_EARTH, {})
    dat = bit.ertBit.dat

    

    bal.slv({ ertBit: { idx: "update-earth", dat } });

    return cpy;
};





import { Action } from "../99.core/interface/action.interface";
import  EarthBit  from "./fce/earth.bit";

// Earth actions

export const INIT_EARTH = "[Earth action] Init Earth";
export class InitEarth implements Action {
 readonly type = INIT_EARTH;
 constructor(public bale: EarthBit) {}
}

export const OPEN_EARTH = "[Earth action] Open Earth";
export class OpenEarth implements Action {
 readonly type = OPEN_EARTH;
 constructor(public bale: EarthBit) {}
}

export const UPDATE_EARTH = "[Earth action] Update Earth";
export class UpdateEarth implements Action {
 readonly type = UPDATE_EARTH;
 constructor(public bale: EarthBit) {}
}

export const ADVANCE_EARTH = "[Advance action] Advance Earth";
 export class AdvanceEarth implements Action {
 readonly type = ADVANCE_EARTH;
 constructor(public bale: EarthBit) {}
 }
 
export const OUTPUT_EARTH = "[Output action] Output Earth";
 export class OutputEarth implements Action {
 readonly type = OUTPUT_EARTH;
 constructor(public bale: EarthBit) {}
 }
 
export const ACCESS_EARTH = "[Access action] Access Earth";
 export class AccessEarth implements Action {
 readonly type = ACCESS_EARTH;
 constructor(public bale: EarthBit) {}
 }
 
export type Actions = | InitEarth | UpdateEarth | OpenEarth 
| AdvanceEarth
| OutputEarth
| AccessEarth
export { initEarth  } from "./buz/earth.buzz";
export { advanceEarth  } from "./buz/advanceEarth.buzz";
export { updateEarth  } from "./buz/updateEarth.buzz";
export { openEarth  } from "./buz/openEarth.buzz";
export { outputEarth  } from "./buz/outputEarth.buzz";
export { accessEarth  } from "./buz/accessEarth.buzz";
import Earth from "./fce/earth.interface";
import EarthBit from "./fce/earth.interface";

export class EarthModel implements Earth {
   opened: number = 0

   dex: number = 0;
   //idx:string;
   //earthBitList: EarthBit[] = [];
   //earthBits: any = {};
   idxClk: string
   idxInc: string

   access: number = 0

   maxLong: number = 1000;

   lastUpdateTimeShort: number = 0;
   deltaHoldShort: number = 0;
   maxShort: number = 100;

   shortValue: number = 0;

   tinyCount:number = 0;
   tinyMax:number = 20;

   maxTiny: number = 50;

   lastUpdateTimeLong: number = 0;
   deltaHoldLong: number = 0;
   

   delayUntil: number = 0;
}

import * as clone from "clone-deep";
import * as Act from "./earth.action";
import { EarthModel } from "./earth.model";
import * as Buzz from "./earth.buzzer";
import State from "../99.core/state";

export function reducer(model: EarthModel = new EarthModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_EARTH:
 return Buzz.updateEarth(clone(model), act.bale, state);

 case Act.INIT_EARTH:
 return Buzz.initEarth(clone(model), act.bale, state);

 case Act.OPEN_EARTH:
 return Buzz.openEarth(clone(model), act.bale, state);

case Act.ADVANCE_EARTH:
 return Buzz.advanceEarth(clone(model), act.bale, state);
 
case Act.OUTPUT_EARTH:
 return Buzz.outputEarth(clone(model), act.bale, state);
 
case Act.ACCESS_EARTH:
 return Buzz.accessEarth(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class EarthUnit {

 constructor(state: State) {
 }
}


export default interface EarthBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  EarthBit  from "./earth.bit";

export default interface Earth {
 // idx:string;
 // earthBitList: EarthBit[];
 // earthBits:any;

}

'use server'

import * as Import from "./BEE";
import State from "./99.core/state";

var dex = 0;

let instance = null;

var sim = {
  hunt: (a, b) => { },
  state: null
};

sim.hunt = (typ, obj) => { return host(obj, typ) }

var host = (obj, typ) => {

  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);

  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {

  if (!instance) {

    if (sim.state != null) return;
    sim.state = new State();
    sim.state.pivot = sim;
    sim.state.hunt = sim.hunt
    for (var k in Import.list) new Import.list[k](sim.state);
    instance = sim
  }


  return instance

};


export const space = async (typ, obj) => {
  return sim.hunt(typ, obj)
}
global.EARTH = require("../dist/000.earth/hunt");

import { WorldModel } from "../world.model";
import WorldBit from "../fce/world.bit";
import State from "../../99.core/state";
import OrbBit from "../fce/orb.bit";


import * as ActClr from "../../03.color.unit/color.action";

import * as ActWld from "../../01.world.unit/world.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";


import EtherealBit from "../fce/talent/etheric.bit";

var bit, val, idx, dex, lst, dat, src;

export const createWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {

    var dat: OrbBit = { idx: bal.idx, src: bal.src }

    //var etri:EtherealBit = { bliyte:null, grusit:null, flxuow:null, kldadu:null };
    //dat.bit = etri;

    //bit = await ste.hunt( ActClr.BASKET_COLOR, {})
    //dat.bit.bliyte = bit.clrBit.dat

    //bit = await ste.hunt( ActClr.BASKET_COLOR, {})
    //dat.bit.flxuow = bit.clrBit.dat

    //bit = await ste.hunt( ActClr.BASKET_COLOR, {})
    //dat.bit.grusit = bit.clrBit.dat

    //bit = await ste.hunt( ActClr.BASKET_COLOR, {})
    //dat.bit.kldadu = bit.clrBit.dat

    //dat

    bal.slv({ wldBit: { idx: "create-world", dat } });

    return cpy;
};

import { WorldModel } from "../world.model";
import WorldBit from "../fce/world.bit";
import State from "../../99.core/state";
import OrbBit from "../fce/orb.bit";


import * as ActWld from "../../01.world.unit/world.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";




var bit, val, idx, dex, lst, dat, src;

export const initWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {

    //set up colors
    //src = '000.color.name.json'
    //bit = await ste.bus(ActDsk.READ_DISK, { src: './data/color-list/' + src })
    //var colorList = bit.dskBit.dat;

    //lst = JSON.parse(colorList)

    //bit = await ste.bus(ActClr.WRITE_COLOR, { idx: 'clr00', dat: { lst } });

    //var staveDataLoc = './data/stave/'
    //src = staveDataLoc + '002.genisi.txt';

    //bit = await ste.bus(ActStv.WRITE_STAVE, { src });

    bal.slv({ intBit: { idx: "init-world" } });

    return cpy;
};


export const updateWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {
    return cpy;
};


export const readWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {

    if (bal.idx == null) bal.idx = 'wld00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActWld.CREATE_WORLD })

    bal.slv({ wldBit: { idx: "read-world", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActWld.CREATE_WORLD })

    if (bal.slv != null) bal.slv({ wldBit: { idx: "write-world", dat: bit.clcBit.dat } });
    return cpy;
};



export const removeWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {
    debugger
    return cpy;
};


export const deleteWorld = async (cpy: WorldModel, bal: WorldBit, ste: State) => {
    debugger
    return cpy;
};





export default interface OrbBit {
    idx: string;
    src?: string;
    val?: number;
}

export default interface AuthenticBit {
    direction: string;
    purpose: string;
    cohesion: string;
}

export default interface CapacitiveBit {
    cognition: string;
    vocabulary: string;
    reminiscence: string;
}

export default interface EthericBit {
    bliyte: string;
    grusit: string;
    flxuow: string;
    kldadu: string
}

export default interface ImaginativeBit {
    style: string;
    ingenuity: string;
    vision: string;
}

export default interface LegitimateBit {
    fidelity: string;
    recognition: string;
    sovereignty: string;
}

export default interface PivotalBit {
    contribution: string;
    gravity: string;
    providence: string;
}

export default interface ReactiveBit {
    discernment: string;
    impulse: string;
    sensation: string;
}

export default interface SignificantBit {
    force: string;
    charge: string;
    scale: string;
}

export default interface VigorousBit {
    pizazz: string;
    oomph: string;
    zing: string;
}

export default interface WorldBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}

import  WorldBit  from "./world.bit";

export default interface World {
 // idx:string;
 // worldBitList: WorldBit[];
 // worldBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  WorldBit  from "./fce/world.bit";

// World actions

export const INIT_WORLD = "[World action] Init World";
export class InitWorld implements Action {
 readonly type = INIT_WORLD;
 constructor(public bale: WorldBit) {}
}

export const UPDATE_WORLD = "[World action] Update World";
export class UpdateWorld implements Action {
 readonly type = UPDATE_WORLD;
 constructor(public bale: WorldBit) {}
}

export const READ_WORLD = "[Read action] Read World";
 export class ReadWorld implements Action {
 readonly type = READ_WORLD;
 constructor(public bale: WorldBit) {}
 }

export const WRITE_WORLD = "[Write action] Write World";
 export class WriteWorld implements Action {
 readonly type = WRITE_WORLD;
 constructor(public bale: WorldBit) {}
 }

export const REMOVE_WORLD = "[Remove action] Remove World";
 export class RemoveWorld implements Action {
 readonly type = REMOVE_WORLD;
 constructor(public bale: WorldBit) {}
 }

export const DELETE_WORLD = "[Delete action] Delete World";
 export class DeleteWorld implements Action {
 readonly type = DELETE_WORLD;
 constructor(public bale: WorldBit) {}
 }

export const CREATE_WORLD = "[Create action] Create World";
 export class CreateWorld implements Action {
 readonly type = CREATE_WORLD;
 constructor(public bale: WorldBit) {}
 }

export type Actions = | InitWorld | UpdateWorld
| ReadWorld
| WriteWorld
| RemoveWorld
| DeleteWorld
| CreateWorld

export { initWorld  } from "./buz/world.buzz";
export { updateWorld  } from "./buz/world.buzz";
export { readWorld  } from "./buz/world.buzz";
export { writeWorld  } from "./buz/world.buzz";
export { removeWorld  } from "./buz/world.buzz";
export { deleteWorld  } from "./buz/world.buzz";
export { createWorld  } from "./buz/createWorld.buzz";

import World from "./fce/world.interface";
import WorldBit from "./fce/world.interface";

export class WorldModel implements World {
 //idx:string;
 //worldBitList: WorldBit[] = [];
 //worldBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./world.action";
import { WorldModel } from "./world.model";
import * as Buzz from "./world.buzzer";
import State from "../99.core/state";

export function reducer(model: WorldModel = new WorldModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {

 case Act.UPDATE_WORLD:
 return Buzz.updateWorld(clone(model), act.bale, state);

 case Act.INIT_WORLD:
 return Buzz.initWorld(clone(model), act.bale, state);

case Act.READ_WORLD:
 return Buzz.readWorld(clone(model), act.bale, state);

case Act.WRITE_WORLD:
 return Buzz.writeWorld(clone(model), act.bale, state);

case Act.REMOVE_WORLD:
 return Buzz.removeWorld(clone(model), act.bale, state);

case Act.DELETE_WORLD:
 return Buzz.deleteWorld(clone(model), act.bale, state);

case Act.CREATE_WORLD:
 return Buzz.createWorld(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class WorldUnit {

 constructor(state: State) {
 }
}

import * as ActFte from '../fate.action'


import { FateModel } from "../fate.model";
import FateBit from "../fce/fate.bit";
import State from "../../99.core/state";

var bit

export const initFate = (cpy: FateModel, bal: FateBit, ste: State) => {

    bal.slv({ intBit: { idx: "init-fate", dat: {} } });
    return cpy;
};

export const updateFate = (cpy: FateModel, bal: FateBit, ste: State) => {

    var Chance = require("chance");
    cpy.fate = new Chance(cpy.seed);
    cpy.seed += 1;

    bal.slv({ fteBit: { idx: "update-fate", dat: {} } });

    return cpy;
};


export const integerFate = async (cpy: FateModel, bal: FateBit, ste: State) => {

    if (cpy.fate == null) bit = await ste.hunt(ActFte.UPDATE_FATE, {})

    if (bal == null) bal = { idx: '' }
    if (bal.lst == null) bal.lst = [0, 9]

    var val = cpy.fate.integer({ min: bal.lst[0], max: bal.lst[1] });

    bal.slv({ fteBit: { idx: "integer-fate", val } });

    return cpy;
};

export const appleFate = async (cpy: FateModel, bal: FateBit, ste: State) => {

    if (cpy.fate == null) bit = await ste.hunt(ActFte.UPDATE_FATE, {})

    var val = cpy.fate.apple_token();

    bal.slv({ fteBit: { idx: "apple-fate", val } });

    return cpy;
};

var data = {}

export const sineFate = async (cpy: FateModel, bal: FateBit, ste: State) => {
    bit = await ste.hunt(ActFte.INTEGER_FATE, {})
    cpy.position += bit.fteBit.val + 1;
    cpy.sine = cpy.amplitude * Math.sin(cpy.frequency * cpy.position) * .1;
    cpy.sine = Number(cpy.sine.toFixed(3))

    if ( data[ 'sine' + cpy.sine ] == null ) data[ 'sine' + cpy.sine ] = 1;
    else {
    //    debugger
    }

    var dex = 0
    for ( var key in data ){
        dex += 1;
     }

    bal.slv({ fteBit: { idx: "sine-fate", val: cpy.sine, dex } });
    return cpy;
};
import * as ActFte from '../fate.action'

import { FateModel } from "../fate.model";
import FateBit from "../fce/fate.bit";
import State from "../../99.core/state";

var bit

export const selectFate = async (cpy: FateModel, bal: FateBit, ste: State) => {

    if (cpy.fate == null) bit = await ste.hunt(ActFte.UPDATE_FATE, {})

    if (bal == null) bal = { idx: null, lst: null }

    if (bal.lst == null) bal.lst = [1, 2]
    var dat = cpy.fate.pickone(bal.lst)

    bal.slv({ fteBit: { idx: "select-fate", dat } });

    return cpy;
};

import * as ActFte from '../fate.action'

import { FateModel } from "../fate.model";
import FateBit from "../fce/fate.bit";
import State from "../../99.core/state";

var bit,lst

export const shuffleFate = async (cpy: FateModel, bal: FateBit, ste: State) => {

    

    if (cpy.fate == null) bit = await ste.hunt(ActFte.UPDATE_FATE, {})

    if (bal == null) bal = { idx: null, lst: null }

    if (bal.lst == null) bal.lst = [1, 2]
    lst = cpy.fate.shuffle(bal.lst)

    bal.slv({ fteBit: { idx: "shuffle-fate", lst } });

    return cpy;
};

import { Action } from "../99.core/interface/action.interface";
import  FateBit  from "./fce/fate.bit";

// Fate actions

export const INIT_FATE = "[Fate action] Init Fate";
export class InitFate implements Action {
 readonly type = INIT_FATE;
 constructor(public bale: FateBit) {}
}

export const UPDATE_FATE = "[Fate action] Update Fate";
export class UpdateFate implements Action {
 readonly type = UPDATE_FATE;
 constructor(public bale: FateBit) {}
}

export const INTEGER_FATE = "[Fate action] Integer Fate";
 export class IntegerFate implements Action {
 readonly type = INTEGER_FATE;
 constructor(public bale: FateBit) {}
 }
 
export const APPLE_FATE = "[Fate action] Apple Fate";
 export class AppleFate implements Action {
 readonly type = APPLE_FATE;
 constructor(public bale: FateBit) {}
 }
 
export const SINE_FATE = "[Sine action] Sine Fate";
 export class SineFate implements Action {
 readonly type = SINE_FATE;
 constructor(public bale: FateBit) {}
 }
 
export const SELECT_FATE = "[Select action] Select Fate";
 export class SelectFate implements Action {
 readonly type = SELECT_FATE;
 constructor(public bale: FateBit) {}
 }
 
export const SHUFFLE_FATE = "[Shuffle action] Shuffle Fate";
 export class ShuffleFate implements Action {
 readonly type = SHUFFLE_FATE;
 constructor(public bale: FateBit) {}
 }
 
export type Actions = | InitFate | UpdateFate 
| IntegerFate
| AppleFate
| SineFate
| SelectFate
| ShuffleFate
export { initFate  } from "./buz/fate.buzz";
export { updateFate  } from "./buz/fate.buzz";
export { integerFate  } from "./buz/fate.buzz";
export { appleFate  } from "./buz/fate.buzz";
export { sineFate  } from "./buz/fate.buzz";
export { selectFate  } from "./buz/selectFate.buzz";
export { shuffleFate  } from "./buz/shuffleFate.buzz";
import Fate from "./fce/fate.interface";
import FateBit from "./fce/fate.interface";

export class FateModel implements Fate {
 //idx:string;
 //fateBitList: FateBit[] = [];
 //fateBits: any = {};
 fate:any;
 seed:number = 19250925;

 amplitude:number = 10;  // Wave height
 frequency:number = 0.1; // How many cycles
 phaseShift:number = 0;  // Horizontal offset
 position:number = 0;
 sine:number = 0;

}

import * as clone from "clone-deep";
import * as Act from "./fate.action";
import { FateModel } from "./fate.model";
import * as Buzz from "./fate.buzzer";
import State from "../99.core/state";

export function reducer(model: FateModel = new FateModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_FATE:
 return Buzz.updateFate(clone(model), act.bale, state);

 case Act.INIT_FATE:
 return Buzz.initFate(clone(model), act.bale, state);

case Act.INTEGER_FATE:
 return Buzz.integerFate(clone(model), act.bale, state);
 
case Act.APPLE_FATE:
 return Buzz.appleFate(clone(model), act.bale, state);
 
case Act.SINE_FATE:
 return Buzz.sineFate(clone(model), act.bale, state);
 
case Act.SELECT_FATE:
 return Buzz.selectFate(clone(model), act.bale, state);
 
case Act.SHUFFLE_FATE:
 return Buzz.shuffleFate(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class FateUnit {

 constructor(state: State) {
 }
}


export default interface FateBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
 lst?: [number, number]
}




import  FateBit  from "./fate.bit";

export default interface Fate {
 // idx:string;
 // fateBitList: FateBit[];
 // fateBits:any;

}



import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActClr from "../color.action";

import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";

import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initColor = (cpy: ColorModel, bal: ColorBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-color" } });
    return cpy;
};



export const updateColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {
    // Logic for updating color properties would go here.
    bal.slv({ clrBit: { idx: "update-color", dat: bal.dat } });
    return cpy;
};

export const readColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'clr00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActClr.CREATE_COLOR });
    if (bal.slv != null) bal.slv({ clrBit: { idx: "read-color", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActClr.CREATE_COLOR });
    if (bal.slv != null) bal.slv({ clrBit: { idx: "write-color", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActClr.DELETE_COLOR });
    if (bal.slv != null) bal.slv({ clrBit: { idx: "remove-color", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {
    // No complex resources to clean up for a simple data object.
    if (bal.slv != null) bal.slv({ clrBit: { idx: "delete-color" } });
    return cpy;
};


export const listColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {

    dat = null

    bit = await ste.hunt(ActCol.LIST_COLLECT, { val: 0, bit: ActClr.CREATE_COLOR })
    lst = bit.clcBit.lst

    bal.slv({ clrBit: { idx: 'list-color', val: lst.length, lst } });

    return cpy;
};
import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";
import State from "../../99.core/state";

import ClrBit from "../fce/clr.bit";

import * as ActClr from '../color.action'
import * as ActFte from '../../../000.earth/02.fate.unit/fate.action'

var bit, lst, idx, src, dat, val;

export const accessColor = (cpy: ColorModel, bal: ColorBit, ste: State) => {

    

    dat = { val: cpy.basket.length }

    bal.slv({ clrBit: { idx: "access-color", dat } });

    return cpy;
};

import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";
import State from "../../99.core/state";
import * as clone from "clone-deep";

import * as ActClr from '../color.action'
import * as ActFte from '../../../000.earth/02.fate.unit/fate.action'

var bit, lst, idx, src, dat, val;

export const basketColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {

    

    var nowColor;

    if (cpy.basket.length == 0) {
        lst = clone(cpy.nameList)
        var fteBit = await ste.hunt(ActFte.SHUFFLE_FATE, { lst })
        cpy.basket = fteBit.fteBit.lst
    }

    if (cpy.basket.length == 1) {
        nowColor = basketColor[0]

        //BASKET RESET!!!

    } else {

        var fteBit = await ste.hunt(ActFte.SELECT_FATE, { lst: cpy.basket })

        nowColor = fteBit.fteBit.dat

        var index = 0;

        cpy.basket.forEach( (a,b)=>{
            if ( a !=  nowColor ) return 
            index = b
        })

        cpy.basket.splice(index, 1);

    }

    bal.slv({ clrBit: { idx: 'basket-color', dat: nowColor, val:cpy.basket.length } });

    return cpy;
};
import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";
import State from "../../99.core/state";

import ClrBit from "../fce/clr.bit";

import * as ActClr from '../color.action'
import * as ActFte from '../../../000.earth/02.fate.unit/fate.action'

var bit, lst, idx, src, dat, val;

export const createColor = (cpy: ColorModel, bal: ColorBit, ste: State) => {
    var dat: ClrBit = { idx: bal.idx, hex: '#FFFFFF' }; // Default color is white

    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    if (cpy.names[bal.idx] == null) {
        cpy.nameList.push(bal.idx)
        cpy.names[bal.idx] = 1
    }

    bal.slv({ clrBit: { idx: "create-color", dat: dat } });
    return cpy;
};


import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";
import State from "../../99.core/state";

import * as ActClr from '../color.action'

var lst, idx, src, dat, val;

export const openColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {

 

    lst = bal.lst

    var dex = 0;

    var action = async () => {

 

        dex
        var itm = lst[dex];
        if (itm == null) {
            bal.slv({ clrBit: { idx: "open-color-error", src: 'no item present' } });
        }

        var name = itm.name;

        var S = require('string')
        idx = S(name).slugify().s
        src = itm.value
        dat = itm.rgb
        val = itm.value

        await ste.hunt(ActClr.WRITE_COLOR, { idx, src, val, dat })

        dex += 1;

        if (dex >= lst.length) {

            bal.slv({ clrBit: { idx: "open-color", val: lst.length } });
            return
        }

        await action()

    }

    await action()

    return cpy;
};


import { ColorModel } from "../color.model";
import ColorBit from "../fce/color.bit";
import State from "../../99.core/state";

import * as ActClr from '../color.action'
import * as ActFte from '../../../000.earth/02.fate.unit/fate.action'

var bit, lst, idx, src, dat, val;

export const randomColor = async (cpy: ColorModel, bal: ColorBit, ste: State) => {

    bit = await ste.hunt(ActClr.LIST_COLOR)

    lst = bit.clrBit.lst

    bit = await ste.hunt( ActFte.SELECT_FATE, {lst})
    idx = bit.fteBit.dat

    bit = await ste.hunt(ActClr.READ_COLOR, {idx})

    dat = bit.clrBit.dat;

    bal.slv({ clrBit: { idx: 'randome-color', dat } });

    return cpy;
};
import { Action } from "../99.core/interface/action.interface";
import ColorBit from "./fce/color.bit";
export declare const INIT_COLOR = "[Color action] Init Color";
export declare class InitColor implements Action {
    bale: ColorBit;
    readonly type = "[Color action] Init Color";
    constructor(bale: ColorBit);
}
export declare const UPDATE_COLOR = "[Color action] Update Color";
export declare class UpdateColor implements Action {
    bale: ColorBit;
    readonly type = "[Color action] Update Color";
    constructor(bale: ColorBit);
}
export declare const OPEN_COLOR = "[Open action] Open Color";
export declare class OpenColor implements Action {
    bale: ColorBit;
    readonly type = "[Open action] Open Color";
    constructor(bale: ColorBit);
}
export declare const READ_COLOR = "[Read action] Read Color";
export declare class ReadColor implements Action {
    bale: ColorBit;
    readonly type = "[Read action] Read Color";
    constructor(bale: ColorBit);
}
export declare const WRITE_COLOR = "[Write action] Write Color";
export declare class WriteColor implements Action {
    bale: ColorBit;
    readonly type = "[Write action] Write Color";
    constructor(bale: ColorBit);
}
export declare const REMOVE_COLOR = "[Remove action] Remove Color";
export declare class RemoveColor implements Action {
    bale: ColorBit;
    readonly type = "[Remove action] Remove Color";
    constructor(bale: ColorBit);
}
export declare const DELETE_COLOR = "[Delete action] Delete Color";
export declare class DeleteColor implements Action {
    bale: ColorBit;
    readonly type = "[Delete action] Delete Color";
    constructor(bale: ColorBit);
}
export declare const CREATE_COLOR = "[Create action] Create Color";
export declare class CreateColor implements Action {
    bale: ColorBit;
    readonly type = "[Create action] Create Color";
    constructor(bale: ColorBit);
}
export declare const LIST_COLOR = "[List action] List Color";
export declare class ListColor implements Action {
    bale: ColorBit;
    readonly type = "[List action] List Color";
    constructor(bale: ColorBit);
}
export declare const RANDOM_COLOR = "[Random action] Random Color";
export declare class RandomColor implements Action {
    bale: ColorBit;
    readonly type = "[Random action] Random Color";
    constructor(bale: ColorBit);
}
export declare const BASKET_COLOR = "[Basket action] Basket Color";
export declare class BasketColor implements Action {
    bale: ColorBit;
    readonly type = "[Basket action] Basket Color";
    constructor(bale: ColorBit);
}
export declare const ACCESS_COLOR = "[Access action] Access Color";
export declare class AccessColor implements Action {
    bale: ColorBit;
    readonly type = "[Access action] Access Color";
    constructor(bale: ColorBit);
}
export type Actions = InitColor | UpdateColor | OpenColor | ReadColor | WriteColor | RemoveColor | DeleteColor | CreateColor | ListColor | RandomColor | BasketColor | AccessColor;

import { Action } from "../99.core/interface/action.interface";
import  ColorBit  from "./fce/color.bit";

// Color actions

export const INIT_COLOR = "[Color action] Init Color";
export class InitColor implements Action {
 readonly type = INIT_COLOR;
 constructor(public bale: ColorBit) {}
}

export const UPDATE_COLOR = "[Color action] Update Color";
export class UpdateColor implements Action {
 readonly type = UPDATE_COLOR;
 constructor(public bale: ColorBit) {}
}

export const OPEN_COLOR = "[Open action] Open Color";
 export class OpenColor implements Action {
 readonly type = OPEN_COLOR;
 constructor(public bale: ColorBit) {}
 }

export const READ_COLOR = "[Read action] Read Color";
 export class ReadColor implements Action {
 readonly type = READ_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const WRITE_COLOR = "[Write action] Write Color";
 export class WriteColor implements Action {
 readonly type = WRITE_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const REMOVE_COLOR = "[Remove action] Remove Color";
 export class RemoveColor implements Action {
 readonly type = REMOVE_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const DELETE_COLOR = "[Delete action] Delete Color";
 export class DeleteColor implements Action {
 readonly type = DELETE_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const CREATE_COLOR = "[Create action] Create Color";
 export class CreateColor implements Action {
 readonly type = CREATE_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const LIST_COLOR = "[List action] List Color";
 export class ListColor implements Action {
 readonly type = LIST_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const RANDOM_COLOR = "[Random action] Random Color";
 export class RandomColor implements Action {
 readonly type = RANDOM_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const BASKET_COLOR = "[Basket action] Basket Color";
 export class BasketColor implements Action {
 readonly type = BASKET_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export const ACCESS_COLOR = "[Access action] Access Color";
 export class AccessColor implements Action {
 readonly type = ACCESS_COLOR;
 constructor(public bale: ColorBit) {}
 }
 
export type Actions = | InitColor | UpdateColor 
| OpenColor
| ReadColor
| WriteColor
| RemoveColor
| DeleteColor
| CreateColor
| ListColor
| RandomColor
| BasketColor
| AccessColor
export { initColor  } from "./buz/0.color.buzz";
export { updateColor  } from "./buz/0.color.buzz";
export { readColor } from "./buz/0.color.buzz";
export { writeColor } from "./buz/0.color.buzz";
export { removeColor } from "./buz/0.color.buzz";
export { deleteColor } from "./buz/0.color.buzz";
export { listColor  } from "./buz/0.color.buzz";
export { randomColor  } from "./buz/randomColor.buzz";
export { basketColor  } from "./buz/basketColor.buzz";
export { openColor  } from "./buz/openColor.buzz";
export { createColor } from "./buz/createColor.buzz";
export { accessColor  } from "./buz/accessColor.buzz";
import Color from "./fce/color.interface";
import ColorBit from "./fce/color.interface";

export class ColorModel implements Color {
    //idx:string;
    //colorBitList: ColorBit[] = [];
    //colorBits: any = {};
    nameList: any[] = []
    names: any = {}
    basket: any[] = []
}

import * as clone from "clone-deep";
import * as Act from "./color.action";
import { ColorModel } from "./color.model";
import * as Buzz from "./color.buzzer";
import State from "../99.core/state";

export function reducer(model: ColorModel = new ColorModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_COLOR:
 return Buzz.updateColor(clone(model), act.bale, state);

 case Act.INIT_COLOR:
 return Buzz.initColor(clone(model), act.bale, state);

case Act.OPEN_COLOR:
 return Buzz.openColor(clone(model), act.bale, state);
 
case Act.READ_COLOR:
 return Buzz.readColor(clone(model), act.bale, state);
 
case Act.WRITE_COLOR:
 return Buzz.writeColor(clone(model), act.bale, state);
 
case Act.REMOVE_COLOR:
 return Buzz.removeColor(clone(model), act.bale, state);
 
case Act.DELETE_COLOR:
 return Buzz.deleteColor(clone(model), act.bale, state);
 
case Act.CREATE_COLOR:
 return Buzz.createColor(clone(model), act.bale, state);
 
case Act.LIST_COLOR:
 return Buzz.listColor(clone(model), act.bale, state);
 
case Act.RANDOM_COLOR:
 return Buzz.randomColor(clone(model), act.bale, state);
 
case Act.BASKET_COLOR:
 return Buzz.basketColor(clone(model), act.bale, state);
 
case Act.ACCESS_COLOR:
 return Buzz.accessColor(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class ColorUnit {

 constructor(state: State) {
 }
}


export default interface ColorBit {
 idx: string;
 hex?: string;
}



export default interface ColorBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    lst?: any[];
    slv?: Function;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=color.bit.js.map

export default interface ColorBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    lst?: any[]
    slv?: Function;
}




import  ColorBit  from "./color.bit";

export default interface Color {
 // idx:string;
 // colorBitList: ColorBit[];
 // colorBits:any;

}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatCollect = exports.dotCollect = exports.emptyCollect = exports.deleteCollect = exports.modelCollect = exports.getCollect = exports.putCollect = exports.removeCollect = exports.createCollect = exports.writeCollect = exports.readCollect = exports.fetchCollect = exports.updateCollect = exports.initCollect = void 0;
const ActCol = require("../../97.collect.unit/collect.action");
var bit, lst, dat, idx, val, src, dex;
const initCollect = (cpy, bal, ste) => {
    return cpy;
};
exports.initCollect = initCollect;
const updateCollect = (cpy, bal, ste) => {
    return cpy;
};
exports.updateCollect = updateCollect;
//return the first item in a collection
const fetchCollect = (cpy, bal, ste) => {
    if (bal.val == null)
        bal.val = 1;
    if ((bal.bit == null))
        bal.slv({ clcBit: { idx: "fetch-collect-err", src: 'no-bit' } });
    var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
    var cabBit = cpy.caboodleBitList[cpy.caboodleBits[type]];
    if (bal.val == 1)
        bit = cabBit.bitList[0];
    else
        bit = cabBit;
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "fetch-collect", dat: bit } });
    return cpy;
};
exports.fetchCollect = fetchCollect;
const readCollect = async (cpy, bal, ste) => {
    if ((bal.bit == null))
        bal.slv({ clcBit: { idx: "read-collect-err", src: 'no-bit' } });
    var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
    if (cpy.caboodleBits[type] == null)
        (0, exports.createCollect)(cpy, { idx: type }, ste);
    var cabBit = cpy.caboodleBitList[cpy.caboodleBits[type]];
    if (cabBit.bits[bal.idx] == null) {
        bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, bit: bal.bit });
    }
    else {
        dat = cabBit.bitList[cabBit.bits[bal.idx]];
    }
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "read-collect", dat } });
    return cpy;
};
exports.readCollect = readCollect;
const writeCollect = async (cpy, bal, ste) => {
    dat = null;
    //let us check see if it exists 
    var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
    if (cpy.caboodleBits[type] == null)
        (0, exports.createCollect)(cpy, { idx: type }, ste);
    if ((bal.bit == null))
        bal.slv({ rskBit: { idx: "write-collect-err", src: 'no-bit' } });
    var cabBit = cpy.caboodleBitList[cpy.caboodleBits[type]];
    bal.idx;
    if (cabBit.bits[bal.idx] == null) {
        bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
        var objDat = bit[Object.keys(bit)[0]];
        dat = objDat.dat;
        if (dat == null)
            dat = {};
        dat.dex = cabBit.bitList.length;
        cabBit.bitList.push(dat);
        var idx = bal.idx;
        if (idx == null)
            idx = dat.idx;
        if (idx == null)
            throw new Error("write collect has no idx");
        cabBit.bits[idx] = dat.dex;
    }
    else {
        var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];
        bal.dat;
        for (var key in bal.dat) {
            if (cabDat == null)
                cabDat = {};
            cabDat[key] = bal.dat[key];
        }
        cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
        dat = cabBit;
        //!!! SUPER IMPORTANT
    }
    if ((dat == null) && (bal.slv != null))
        bal.slv({ rskBit: { idx: "write-collect-err", src: 'no-dat' } });
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "write-collect", dat } });
    return cpy;
};
exports.writeCollect = writeCollect;
const createCollect = (cpy, bal, ste) => {
    var cabBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
    cabBit.dex = cpy.caboodleBitList.length;
    cpy.caboodleBitList.push(cabBit);
    cpy.caboodleBits[cabBit.idx] = cabBit.dex;
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "create-collect", dat: cabBit } });
    return cpy;
};
exports.createCollect = createCollect;
const removeCollect = async (cpy, bal, ste) => {
    var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
    if (cpy.caboodleBits[type] == null)
        return bal.slv({ rskBit: { idx: "remove-collect-not-present" } });
    var cabBit = cpy.caboodleBitList[cpy.caboodleBits[type]];
    if (cabBit.bits[bal.idx] == null)
        return bal.slv({ rskBit: { idx: "remove-collect-idx-not-present" } });
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;
    dex = dat.dex;
    for (var i = dex; i < cabBit.bitList.length - 1; i++) {
        var update = cabBit.bitList[i];
        update.dex -= 1;
    }
    for (var key in dat) {
        dat[key] = null;
    }
    delete cabBit.bits[bal.idx];
    var itm = cabBit.bitList.splice(dex, 1);
    cabBit.dex -= 1;
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "remove-collect", dat: itm[0] } });
    return cpy;
};
exports.removeCollect = removeCollect;
const putCollect = (cpy, bal, ste) => {
    cpy.caboodleBits[bal.idx] = bal.val;
    cpy.caboodleBitList[bal.val] = bal.dat;
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "put-collect", dat: bal.dat } });
    return cpy;
};
exports.putCollect = putCollect;
const getCollect = (cpy, bal, ste) => {
    val = cpy.caboodleBits[bal.idx];
    dat = cpy.caboodleBitList[val];
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "get-collect", val, dat } });
    return cpy;
};
exports.getCollect = getCollect;
const modelCollect = (cpy, bal, ste) => {
    //debugger
    if (bal.slv != null)
        bal.slv({ clcBit: { idx: "model-collect", dat: cpy } });
    return cpy;
};
exports.modelCollect = modelCollect;
const deleteCollect = (cpy, bal, ste) => {
    //debugger
    return cpy;
};
exports.deleteCollect = deleteCollect;
const emptyCollect = (cpy, bal, ste) => {
    //debugger
    return cpy;
};
exports.emptyCollect = emptyCollect;
const dotCollect = (cpy, bal, ste) => {
    var gel = bal.dat;
    var out = [];
    bal.src.split("\n").forEach((a, b) => {
        if (a.includes('//') == true)
            return;
        var doTCompiled = doT.template(a);
        var outLine = doTCompiled(gel);
        out.push(outLine);
    });
    if (bal.slv != null)
        bal.slv({ colBit: { idx: "dot-vurt", lst: out, src: out.join('\n') } });
    return cpy;
};
exports.dotCollect = dotCollect;
const formatCollect = (cpy, bal, ste) => {
    lst = bal.src.split(':');
    var idx = lst[0];
    var out = [];
    idx = S(idx).collapseWhitespace().s;
    var opt = lst[1].split(',');
    opt.forEach((a, b) => {
        var now = S(a).collapseWhitespace().s;
        if (a.length < 1)
            return;
        out.push(now);
    });
    dat = [idx, out];
    bal.slv({ colBit: { idx: "format-collect", dat } });
    return cpy;
};
exports.formatCollect = formatCollect;
const S = require("string");
const doT = require("dot");
//# sourceMappingURL=collect.buzz.js.map
import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DotCollect = exports.DOT_COLLECT = exports.FormatCollect = exports.FORMAT_COLLECT = exports.GetCollect = exports.GET_COLLECT = exports.PutCollect = exports.PUT_COLLECT = exports.ModelCollect = exports.MODEL_COLLECT = exports.EmptyCollect = exports.EMPTY_COLLECT = exports.DeleteCollect = exports.DELETE_COLLECT = exports.RemoveCollect = exports.REMOVE_COLLECT = exports.CreateCollect = exports.CREATE_COLLECT = exports.WriteCollect = exports.WRITE_COLLECT = exports.ReadCollect = exports.READ_COLLECT = exports.FetchCollect = exports.FETCH_COLLECT = exports.UpdateCollect = exports.UPDATE_COLLECT = exports.InitCollect = exports.INIT_COLLECT = void 0;
// Collect actions
exports.INIT_COLLECT = "[Collect action] Init Collect";
class InitCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.INIT_COLLECT;
    }
}
exports.InitCollect = InitCollect;
exports.UPDATE_COLLECT = "[Collect action] Update Collect";
class UpdateCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.UPDATE_COLLECT;
    }
}
exports.UpdateCollect = UpdateCollect;
exports.FETCH_COLLECT = "[Collect action] Fetch Collect";
class FetchCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.FETCH_COLLECT;
    }
}
exports.FetchCollect = FetchCollect;
exports.READ_COLLECT = "[Read action] Read Collect";
class ReadCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.READ_COLLECT;
    }
}
exports.ReadCollect = ReadCollect;
exports.WRITE_COLLECT = "[Write action] Write Collect";
class WriteCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.WRITE_COLLECT;
    }
}
exports.WriteCollect = WriteCollect;
exports.CREATE_COLLECT = "[Create action] Create Collect";
class CreateCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.CREATE_COLLECT;
    }
}
exports.CreateCollect = CreateCollect;
exports.REMOVE_COLLECT = "[Create action] Remove Collect";
class RemoveCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.REMOVE_COLLECT;
    }
}
exports.RemoveCollect = RemoveCollect;
exports.DELETE_COLLECT = "[Create action] Delete Collect";
class DeleteCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.DELETE_COLLECT;
    }
}
exports.DeleteCollect = DeleteCollect;
exports.EMPTY_COLLECT = "[Empty action] Empty Collect";
class EmptyCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.EMPTY_COLLECT;
    }
}
exports.EmptyCollect = EmptyCollect;
exports.MODEL_COLLECT = "[Empty action] Model Collect";
class ModelCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.MODEL_COLLECT;
    }
}
exports.ModelCollect = ModelCollect;
exports.PUT_COLLECT = "[Empty action] Put Collect";
class PutCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.PUT_COLLECT;
    }
}
exports.PutCollect = PutCollect;
exports.GET_COLLECT = "[Empty action] Get Collect";
class GetCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.GET_COLLECT;
    }
}
exports.GetCollect = GetCollect;
exports.FORMAT_COLLECT = "[Format action] Format Collect";
class FormatCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.FORMAT_COLLECT;
    }
}
exports.FormatCollect = FormatCollect;
exports.DOT_COLLECT = "[Format action] Dot Collect";
class DotCollect {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.DOT_COLLECT;
    }
}
exports.DotCollect = DotCollect;
//# sourceMappingURL=collect.action.js.map
import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dotCollect = exports.formatCollect = exports.getCollect = exports.putCollect = exports.modelCollect = exports.removeCollect = exports.deleteCollect = exports.fetchCollect = exports.emptyCollect = exports.createCollect = exports.writeCollect = exports.readCollect = exports.updateCollect = exports.initCollect = void 0;
var collect_buzz_1 = require("./buz/collect.buzz");
Object.defineProperty(exports, "initCollect", { enumerable: true, get: function () { return collect_buzz_1.initCollect; } });
var collect_buzz_2 = require("./buz/collect.buzz");
Object.defineProperty(exports, "updateCollect", { enumerable: true, get: function () { return collect_buzz_2.updateCollect; } });
var collect_buzz_3 = require("./buz/collect.buzz");
Object.defineProperty(exports, "readCollect", { enumerable: true, get: function () { return collect_buzz_3.readCollect; } });
var collect_buzz_4 = require("./buz/collect.buzz");
Object.defineProperty(exports, "writeCollect", { enumerable: true, get: function () { return collect_buzz_4.writeCollect; } });
var collect_buzz_5 = require("./buz/collect.buzz");
Object.defineProperty(exports, "createCollect", { enumerable: true, get: function () { return collect_buzz_5.createCollect; } });
var collect_buzz_6 = require("./buz/collect.buzz");
Object.defineProperty(exports, "emptyCollect", { enumerable: true, get: function () { return collect_buzz_6.emptyCollect; } });
var collect_buzz_7 = require("./buz/collect.buzz");
Object.defineProperty(exports, "fetchCollect", { enumerable: true, get: function () { return collect_buzz_7.fetchCollect; } });
var collect_buzz_8 = require("./buz/collect.buzz");
Object.defineProperty(exports, "deleteCollect", { enumerable: true, get: function () { return collect_buzz_8.deleteCollect; } });
var collect_buzz_9 = require("./buz/collect.buzz");
Object.defineProperty(exports, "removeCollect", { enumerable: true, get: function () { return collect_buzz_9.removeCollect; } });
var collect_buzz_10 = require("./buz/collect.buzz");
Object.defineProperty(exports, "modelCollect", { enumerable: true, get: function () { return collect_buzz_10.modelCollect; } });
var collect_buzz_11 = require("./buz/collect.buzz");
Object.defineProperty(exports, "putCollect", { enumerable: true, get: function () { return collect_buzz_11.putCollect; } });
var collect_buzz_12 = require("./buz/collect.buzz");
Object.defineProperty(exports, "getCollect", { enumerable: true, get: function () { return collect_buzz_12.getCollect; } });
var collect_buzz_13 = require("./buz/collect.buzz");
Object.defineProperty(exports, "formatCollect", { enumerable: true, get: function () { return collect_buzz_13.formatCollect; } });
var collect_buzz_14 = require("./buz/collect.buzz");
Object.defineProperty(exports, "dotCollect", { enumerable: true, get: function () { return collect_buzz_14.dotCollect; } });
//# sourceMappingURL=collect.buzzer.js.map
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CollectModel = void 0;
class CollectModel {
    constructor() {
        this.idx = '23.11.14';
        this.caboodleBitList = [];
        this.caboodleBits = {};
    }
}
exports.CollectModel = CollectModel;
//# sourceMappingURL=collect.model.js.map
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
const clone = require("clone-deep");
const Act = require("./collect.action");
const collect_model_1 = require("./collect.model");
const Buzz = require("./collect.buzzer");
function reducer(model = new collect_model_1.CollectModel(), act, state) {
    switch (act.type) {
        case Act.UPDATE_COLLECT:
            return Buzz.updateCollect(clone(model), act.bale, state);
        case Act.INIT_COLLECT:
            return Buzz.initCollect(clone(model), act.bale, state);
        case Act.READ_COLLECT:
            return Buzz.readCollect(clone(model), act.bale, state);
        case Act.WRITE_COLLECT:
            return Buzz.writeCollect(clone(model), act.bale, state);
        case Act.CREATE_COLLECT:
            return Buzz.createCollect(clone(model), act.bale, state);
        case Act.DELETE_COLLECT:
            return Buzz.deleteCollect(clone(model), act.bale, state);
        case Act.REMOVE_COLLECT:
            return Buzz.removeCollect(clone(model), act.bale, state);
        case Act.EMPTY_COLLECT:
            return Buzz.emptyCollect(clone(model), act.bale, state);
        case Act.FETCH_COLLECT:
            return Buzz.fetchCollect(clone(model), act.bale, state);
        case Act.MODEL_COLLECT:
            return Buzz.modelCollect(clone(model), act.bale, state);
        case Act.GET_COLLECT:
            return Buzz.getCollect(clone(model), act.bale, state);
        case Act.PUT_COLLECT:
            return Buzz.putCollect(clone(model), act.bale, state);
        case Act.FORMAT_COLLECT:
            return Buzz.formatCollect(clone(model), act.bale, state);
        case Act.DOT_COLLECT:
            return Buzz.dotCollect(clone(model), act.bale, state);
        default:
            return model;
    }
}
exports.reducer = reducer;
//# sourceMappingURL=collect.reduce.js.map
import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_ioc_1 = require("typescript-ioc");
const state_1 = require("../99.core/state");
let CollectUnit = class CollectUnit {
    constructor(state) {
    }
};
CollectUnit = __decorate([
    typescript_ioc_1.Singleton,
    __metadata("design:paramtypes", [state_1.default])
], CollectUnit);
exports.default = CollectUnit;
//# sourceMappingURL=collect.unit.js.map
import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=caboodle.bit.js.map

export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=collect.bit.js.map

export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}




"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=collect.interface.js.map

import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateBus = exports.CREATE_BUS = exports.UpdateBus = exports.UPDATE_BUS = exports.MessageBus = exports.MESSAGE_BUS = exports.ConnectBus = exports.CONNECT_BUS = exports.OpenBus = exports.OPEN_BUS = exports.InitBus = exports.INIT_BUS = void 0;
// Bus actions
exports.INIT_BUS = "[Bus action] Init Bus";
class InitBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.INIT_BUS;
    }
}
exports.InitBus = InitBus;
exports.OPEN_BUS = "[Bus action] Open Bus";
class OpenBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.OPEN_BUS;
    }
}
exports.OpenBus = OpenBus;
exports.CONNECT_BUS = "[Bus action] Connect Bus";
class ConnectBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.CONNECT_BUS;
    }
}
exports.ConnectBus = ConnectBus;
exports.MESSAGE_BUS = "[Bus action] Message Bus";
class MessageBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.MESSAGE_BUS;
    }
}
exports.MessageBus = MessageBus;
exports.UPDATE_BUS = "[Bus action] Update Bus";
class UpdateBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.UPDATE_BUS;
    }
}
exports.UpdateBus = UpdateBus;
exports.CREATE_BUS = "[Bus action] Create Bus";
class CreateBus {
    constructor(bale) {
        this.bale = bale;
        this.type = exports.CREATE_BUS;
    }
}
exports.CreateBus = CreateBus;
//# sourceMappingURL=bus.action.js.map
import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBus = exports.messageBus = exports.connectBus = exports.updateBus = exports.openBus = exports.initBus = void 0;
var bus_buzz_1 = require("./buz/bus.buzz");
Object.defineProperty(exports, "initBus", { enumerable: true, get: function () { return bus_buzz_1.initBus; } });
var bus_buzz_2 = require("./buz/bus.buzz");
Object.defineProperty(exports, "openBus", { enumerable: true, get: function () { return bus_buzz_2.openBus; } });
var bus_buzz_3 = require("./buz/bus.buzz");
Object.defineProperty(exports, "updateBus", { enumerable: true, get: function () { return bus_buzz_3.updateBus; } });
var bus_buzz_4 = require("./buz/bus.buzz");
Object.defineProperty(exports, "connectBus", { enumerable: true, get: function () { return bus_buzz_4.connectBus; } });
var bus_buzz_5 = require("./buz/bus.buzz");
Object.defineProperty(exports, "messageBus", { enumerable: true, get: function () { return bus_buzz_5.messageBus; } });
var bus_buzz_6 = require("./buz/bus.buzz");
Object.defineProperty(exports, "createBus", { enumerable: true, get: function () { return bus_buzz_6.createBus; } });
//# sourceMappingURL=bus.buzzer.js.map
export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BusModel = void 0;
class BusModel {
    constructor() {
        this.host = "mqtt://localhost:1883";
        this.responseSuffix = '-response';
        this.promises = {};
    }
}
exports.BusModel = BusModel;
//# sourceMappingURL=bus.model.js.map
import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reducer = void 0;
const clone = require("clone-deep");
const Act = require("./bus.action");
const bus_model_1 = require("./bus.model");
const Buzz = require("./bus.buzzer");
function reducer(model = new bus_model_1.BusModel(), act, state) {
    switch (act.type) {
        case Act.UPDATE_BUS:
            return Buzz.updateBus(clone(model), act.bale, state);
        case Act.OPEN_BUS:
            return Buzz.openBus(clone(model), act.bale, state);
        case Act.CONNECT_BUS:
            return Buzz.connectBus(clone(model), act.bale, state);
        case Act.CREATE_BUS:
            return Buzz.createBus(clone(model), act.bale, state);
        case Act.MESSAGE_BUS:
            return Buzz.connectBus(clone(model), act.bale, state);
        case Act.INIT_BUS:
            return Buzz.initBus(clone(model), act.bale, state);
        default:
            return model;
    }
}
exports.reducer = reducer;
//# sourceMappingURL=bus.reduce.js.map
import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
const typescript_ioc_1 = require("typescript-ioc");
const state_1 = require("../99.core/state");
let BusUnit = class BusUnit {
    constructor(state) {
    }
};
BusUnit = __decorate([
    typescript_ioc_1.Singleton,
    __metadata("design:paramtypes", [state_1.default])
], BusUnit);
exports.default = BusUnit;
//# sourceMappingURL=bus.unit.js.map
import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateBus = exports.messageBus = exports.connectBus = exports.openBus = exports.createBus = exports.initBus = void 0;
const ActMnu = require("../../98.menu.unit/menu.action");
const ActBus = require("../../99.bus.unit/bus.action");
const ActCol = require("../../97.collect.unit/collect.action");
var lst, idx, bit, src, dat, dex;
const initBus = (cpy, bal, ste) => {
    cpy.actList = [];
    if (bal == null)
        bal = { idx: null };
    if (bal.lst == null)
        bal.lst = [];
    if ((bal.src != null) && (bal.src.constructor == Array))
        lst = bal.src;
    bal.lst.forEach((a) => {
        for (var key in a) {
            cpy.actList.push(a[key]);
        }
    });
    ste.bus = (idx, dat, bit) => (0, exports.updateBus)(cpy, { idx, dat, bit }, ste);
    if (bal.dat != null) {
        cpy.MQTT = bal.dat;
    }
    else {
        console.log("return promise");
    }
    if (lst == null) {
        if (bal.src != null)
            cpy.host = bal.src;
        cpy.client = cpy.MQTT.connect(cpy.host);
        cpy.client.on('message', (tpc, msg) => { (0, exports.messageBus)(cpy, { idx: tpc, src: msg }, ste); });
        cpy.client.on('connect', () => {
            console.log(bal.idx + " connected " + cpy.host);
            (0, exports.openBus)(cpy, { idx: 'init-bus', lst: cpy.actList }, ste);
            if (bal.slv != null)
                bal.slv({ intBit: { idx: "init-bus" } });
        });
    }
    else {
        var complete = (lst) => {
            lst.shift();
            if (lst.length != 0)
                return;
            if (bal.slv != null)
                bal.slv({ intBit: { idx: "init-bus" } });
        };
        lst.forEach(async (a) => {
            bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS });
            var client = bit.clcBit.dat;
            client.on('message', (tpc, msg) => { (0, exports.messageBus)(cpy, { idx: tpc, src: msg, bit: a.idx }, ste); });
            client.on('connect', () => {
                console.log(a.idx + " connected " + a.src);
                (0, exports.openBus)(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste);
                complete(lst);
            });
        });
    }
    return cpy;
};
exports.initBus = initBus;
const createBus = (cpy, bal, ste) => {
    var client = cpy.MQTT.connect(bal.src);
    if (bal.slv != null)
        bal.slv({ busBit: { idx: "create-bus", dat: client } });
    //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
    //client.on('connect', () => {
    //console.log(bal.idx + " connected " + bal.src)
    //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
    //})
    return cpy;
};
exports.createBus = createBus;
const openBus = async (cpy, bal, ste) => {
    var out = [];
    bal.lst.forEach((a) => {
        if (a == null)
            return;
        if (a.includes == null)
            return;
        if (a.includes('[') && a.includes(']') == false)
            return;
        out.push(a);
    });
    var client = cpy.client;
    if (bal.bit != null) {
        bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS });
        client = bit.clcBit.dat;
    }
    out.forEach((a) => {
        client.subscribe(a, (err) => {
            if (!err) {
                console.log('subscribing ' + a);
            }
        });
    });
    return cpy;
};
exports.openBus = openBus;
const connectBus = (cpy, bal, ste) => {
    var lst = [];
    if (bal.val == 1)
        patch(ste, ActMnu.INIT_MENU, { lst });
};
exports.connectBus = connectBus;
const messageBus = async (cpy, bal, ste) => {
    if (bal.src != null)
        dat = bal.src.toString();
    idx = bal.idx;
    dat = JSON.parse(dat);
    var client = cpy.client;
    if (bal.bit != null) {
        bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS });
        client = bit.clcBit.dat;
    }
    if (idx.includes(cpy.responseSuffix) == true) {
        var responseIDX = bal.idx;
        var obj = cpy.promises[responseIDX];
        if (obj.slv != null)
            obj.slv(dat);
        client.unsubscribe(responseIDX, (err) => {
            if (!err) {
                //console.log('hitting ' + responseIDX)
            }
        });
    }
    else {
        var bit = await ste.hunt(idx, dat);
        var cloneBit = clone(bit);
        for (var key in cloneBit) {
            var itm = cloneBit[key];
            if (itm.dat != null) {
                if (itm.dat.bit != null)
                    itm.dat.bit = null;
            }
        }
        cloneBit;
        client.publish(bal.idx + cpy.responseSuffix, JSON.stringify(cloneBit));
    }
    return cpy;
};
exports.messageBus = messageBus;
//has to return a promise
const updateBus = async (cpy, bal, ste) => {
    //how does one create an error message here when bit should be used
    var client = cpy.client;
    if (bal.bit != null) {
        bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS });
        client = bit.clcBit.dat;
    }
    if ((client == null) && (bal.bit == null)) {
        bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS });
        client = bit.clcBit.dat;
    }
    var responseIDX = bal.idx + cpy.responseSuffix;
    var slv;
    const promo = new Promise((rslv, rjct) => (slv = rslv));
    var obj = { slv: (val0) => slv(val0) };
    cpy.promises[responseIDX] = obj;
    client.subscribe(responseIDX, (err) => {
        if (!err) {
            //console.log('hitting ' + responseIDX)
        }
    });
    //03.10.23
    //bit throws errors since sometimes it is not a primitive
    //if (bal.dat == null) bal.dat = {}
    //if (bal.dat.bit != null) bal.dat.bit = null;
    client.publish(bal.idx, JSON.stringify(bal.dat));
    return promo;
};
exports.updateBus = updateBus;
var patch = (ste, type, bale) => ste.dispatch({ type, bale });
const clone = require("clone-deep");
//# sourceMappingURL=bus.buzz.js.map
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });



"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=bus.bit.js.map

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=bus.interface.js.map

import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
    type: string;
    bale?: T;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=action.interface.js.map
export interface Action<T = any> {
  type: string;
  bale?: T;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=model.interface.js.map
export default interface Model {}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const rx_lite_1 = require("rx-lite");
const rx_lite_2 = require("rx-lite");
const BEE_1 = require("../BEE");
const Effect = require("../BEE");
class State extends rx_lite_1.BehaviorSubject {
    constructor(init = new BEE_1.default()) {
        super(init);
        this.dispatcher = new rx_lite_2.Subject();
        this.dispatcher
            .scan((state, action) => this.reducedApp(state, action), init)
            .subscribe((state) => {
            super.onNext(state);
        });
    }
    reducedApp(nextState, key) {
        for (var k in Effect.reducer)
            Effect.reducer[k](nextState[k], key, this);
        return nextState;
    }
    dispatch(value) {
        var result = this.dispatcher.onNext(value);
        return result;
    }
    pat(value) {
        this.dispatch(value);
    }
    next(value) {
        this.dispatcher.onNext(value);
    }
}
exports.default = State;
//# sourceMappingURL=state.js.map
import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CLOCK = "[Clock action] Init Clock";
export const UPDATE_CLOCK = "[Clock action] Update Clock";
export const READ_CLOCK = "[Read action] Read Clock";
export const WRITE_CLOCK = "[Write action] Write Clock";
export const REMOVE_CLOCK = "[Remove action] Remove Clock";
export const CREATE_CLOCK = "[Create action] Create Clock";
export const DELETE_CLOCK = "[Delete action] Delete Clock";
export const BLOCK_CLOCK = "[Block action] Block Clock";
export const LIST_CLOCK = "[List action] List Clock";
export const TEST_CLOCK = "[Test action] Test Clock";
export const INIT_COLOR = "[Color action] Init Color";
export const UPDATE_COLOR = "[Color action] Update Color";
export const OPEN_COLOR = "[Open action] Open Color";
export const READ_COLOR = "[Read action] Read Color";
export const WRITE_COLOR = "[Write action] Write Color";
export const REMOVE_COLOR = "[Remove action] Remove Color";
export const DELETE_COLOR = "[Delete action] Delete Color";
export const CREATE_COLOR = "[Create action] Create Color";
export const LIST_COLOR = "[List action] List Color";
export const RANDOM_COLOR = "[Random action] Random Color";
export const BASKET_COLOR = "[Basket action] Basket Color";
export const ACCESS_COLOR = "[Access action] Access Color";
export const INIT_FOCUS = "[Focus action] Init Focus";
export const AWAKE_FOCUS = "[Focus action] Awake Focus";
export const UPDATE_FOCUS = "[Focus action] Update Focus";
export const OPEN_FOCUS = "[Focus action] Open Focus";
export const CREATE_FOCUS = "[Focus action] Create Focus";
export const READ_FOCUS = "[Read action] Read Focus";
export const WRITE_FOCUS = "[Write action] Write Focus";
export const REMOVE_FOCUS = "[Remove action] Remove Focus";
export const DELETE_FOCUS = "[Delete action] Delete Focus";
export const CORNER_FOCUS = "[Corner action] Corner Focus";
export const LIST_FOCUS = "[List action] List Focus";
 export const SPIN_RIGHT_FOCUS = "[List action] Spin Left Focus";
 export const SPIN_LEFT_FOCUS = "[List action] Spin Right Focus";
 export const FORWARD_FOCUS = "[List action] Forward Focus";
 export const BACKWARD_FOCUS = "[List action] Backward Focus";
 export const CENTER_FOCUS = "[List action] Center Focus";
export const BOND_FOCUS = "[Bond action] Bond Focus";
export const LOCATE_FOCUS = "[Locate action] Locate Focus";
export const VISION_FOCUS = "[Vision action] Vision Focus";
export const SELECT_FOCUS = "[Select action] Select Focus";
 export const MODEL_FOCUS = "[Select action] Model Focus";
 export const BROWNIAN_FOCUS = "[Select action] Brownian Focus";
export const INIT_HEXMAP = "[Hexmap action] Init Hexmap";
export const UPDATE_HEXMAP = "[Hexmap action] Update Hexmap";
export const OPEN_HEXMAP = "[Hexmap action] Open Hexmap";
export const READ_HEXMAP = "[Read action] Read Hexmap";
export const WRITE_HEXMAP = "[Write action] Write Hexmap";
export const CREATE_HEXMAP = "[Create action] Create Hexmap";
export const COPY_HEXMAP = "[Copy action] Copy Hexmap";
export const ATLAS_HEXMAP = "[Atlas action] Atlas Hexmap";
export const GEOJSON_HEXMAP = "[Geojson action] Geojson Hexmap";
export const TOOL_HEXMAP = "[Tool action] Tool Hexmap";
export const SAVE_HEXMAP = "[Save action] Save Hexmap";
export const STORE_HEXMAP = "[Store action] Store Hexmap";
export const SHAPE_HEXMAP = "[Shape action] Shape Hexmap";
export const LOAD_HEXMAP = "[Load action] Load Hexmap";
export const LIST_HEXMAP = "[List action] List Hexmap";
export const REPLACE_HEXMAP = "[Replace action] Replace Hexmap";
export const NAME_HEXMAP = "[Name action] Name Hexmap";
export const SEEK_HEXMAP = "[Seek action] Seek Hexmap";
export const FOCUSING_HEXMAP = "[Focusing action] Focusing Hexmap";
export const DEFOCUS_HEXMAP = "[Defocus action] Defocus Hexmap";
export const SELECT_HEXMAP = "[Select action] Select Hexmap";
export const ADD_HEXMAP = "[Select action] Add Hexmap";
export const POUCH_HEXMAP = "[Select action] Pouch Hexmap";
export const INIT_INCREMENT = "[Increment action] Init Increment";
export const UPDATE_INCREMENT = "[Increment action] Update Increment";
export const READ_INCREMENT = "[Read action] Read Increment";
export const WRITE_INCREMENT = "[Write action] Write Increment";
export const REMOVE_INCREMENT = "[Remove action] Remove Increment";
export const DELETE_INCREMENT = "[Delete action] Delete Increment";
export const CREATE_INCREMENT = "[Create action] Create Increment";
export const LIST_INCREMENT = "[List action] List Increment";
export const INIT_PROGRESS = "[Progress action] Init Progress";
export const UPDATE_PROGRESS = "[Progress action] Update Progress";

export const INIT_SPARK = "[Spark action] Init Spark";
export const UPDATE_SPARK = "[Spark action] Update Spark";
export const READ_SPARK = "[Read action] Read Spark";
export const WRITE_SPARK = "[Write action] Write Spark";
export const REMOVE_SPARK = "[Remove action] Remove Spark";
export const DELETE_SPARK = "[Delete action] Delete Spark";
export const CREATE_SPARK = "[Create action] Create Spark";
export const INIT_TIME = "[Time action] Init Time";
export const UPDATE_TIME = "[Time action] Update Time";
export const TEST_TIME = "[Reduce action] Test Time";
export const RANDOM_TIME = "[Random action] Random Time";

import Model from "./99.core/interface/model.interface";

import EarthUnit from "./00.earth.unit/earth.unit";
import WorldUnit from "./01.world.unit/world.unit";
import FateUnit from "./02.fate.unit/fate.unit";
import ColorUnit from "./03.color.unit/color.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Earth from "./00.earth.unit/fce/earth.interface";
import { EarthModel } from "./00.earth.unit/earth.model";
import World from "./01.world.unit/fce/world.interface";
import { WorldModel } from "./01.world.unit/world.model";
import Fate from "./02.fate.unit/fce/fate.interface";
import { FateModel } from "./02.fate.unit/fate.model";
import Color from "./03.color.unit/fce/color.interface";
import { ColorModel } from "./03.color.unit/color.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [EarthUnit,WorldUnit,FateUnit,ColorUnit,CollectUnit,BusUnit];

import * as reduceFromEarth from "./00.earth.unit/earth.reduce";
import * as reduceFromWorld from "./01.world.unit/world.reduce";
import * as reduceFromFate from "./02.fate.unit/fate.reduce";
import * as reduceFromColor from "./03.color.unit/color.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 earth : reduceFromEarth.reducer, 
 world : reduceFromWorld.reducer,
 fate : reduceFromFate.reducer,
 color : reduceFromColor.reducer,
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 earth : Earth = new EarthModel();
 world : World = new WorldModel();
 fate : Fate = new FateModel();
 color : Color = new ColorModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const HOURS = "incHrs";
export const MINUTES = "incMin";
export const DAYS = "incDay";
export const SECONDS = "incSec";
export const DEFAULT = "incDft";


export const CONTROL = "CONTROL";
export const TIME = "TIME";
export const SPACE = "SPACE";
export const EARTH = "EARTH";
export const SOWER = "SOWER";
export const SHADE = "SHADE";
export const SOLID = "SOLID";
export const MARKET = "MARKET";
export const LIBRARY = "LIBRARY";

import { TimeModel } from '../time.model';
import TimeBit from '../fce/time.bit';
import State from '../../99.core/state';

import * as ActClk from '../../03.clock.unit/clock.action';
import * as ActInc from '../../02.increment.unit/increment.action';
import * as ActTme from '../../00.time.unit/time.action';


import { DateTime } from 'luxon';

var bit, lst, dex, src, dat;

export const initTime = async (cpy: TimeModel, bal: TimeBit, ste: State) => {
  bal.slv({ intBit: { idx: 'init-time' } });
  return cpy;
};



export const updateTime = async (cpy: TimeModel, bal: TimeBit, ste: State) => {
  bal.slv({ tmeBit: { idx: 'update-time', dat: bit.tmeBit.dat } });
  return cpy;
};

export const randomTime = async (cpy: TimeModel, bal: TimeBit, ste: State) => {

  if (bal.idx == null) bal.idx = 'clk00';

  bit = await ste.hunt(ActClk.READ_CLOCK, { idx: bal.idx })

  var data = bit.clkBit.dat

  var year = data.yrs;
  if (year == null) year = 1978;

  if (typeof year !== 'number' || isNaN(year) || year < 1 || year > 9999) {
    // console.error("Invalid year provided. Please provide a valid four-digit year.");
    return null;
  }

  var Chance = require('chance')
  const chance = new Chance();
  const sundaysInYear = [];

  // Start with the first day of the year
  let currentDate = DateTime.local(year, 1, 1);

  if (!currentDate.isValid) {
    // console.error(`Failed to create a valid date for January 1st, ${year}. Reason: ${currentDate.invalidReason}`);
    return null;
  }

  // Find the first Sunday of the year.
  // Luxon's weekday numbers are 1 for Monday to 7 for Sunday.
  // .endOf('week') using default locale (week starts Monday) will give Sunday.
  if (currentDate.weekday !== 7) {
    currentDate = currentDate.endOf('week');
  }
  // Now, currentDate is the first Sunday of the year (e.g., if Jan 1 is Mon, currentDate is Jan 7).
  // If Jan 1 was already Sunday, it remains Jan 1.

  // Collect all Sundays that fall within the specified year
  while (currentDate.year === year) {
    sundaysInYear.push(currentDate);
    currentDate = currentDate.plus({ weeks: 1 });
  }

  if (sundaysInYear.length === 0) {
    // This should ideally not be reached if the year is valid and logic is correct.
    // console.error(`No Sundays found in the year ${year}. This is unexpected.`);
    return null;
  }

  var itm = chance.pickone(sundaysInYear);
  var now = itm.c;

  bit = await ste.hunt(ActClk.ADAPT_CLOCK, { dat: now })

  var clk = bit.clkBit.dat;

  bit = await ste.hunt(ActClk.WRITE_CLOCK, { idx: bal.idx, dat: { clk } })

  bal.slv({ tmeBit: { idx: 'random-time', dat: bit.clkBit.dat } });
  return cpy;
};


export const testTime = async (cpy: TimeModel, bal: TimeBit, ste: State) => {

  var clk = { day: 0, hrs: 0, min: 0, mth: 0, sec: 0, yrs: 1978 }
  bit = await ste.hunt(ActClk.WRITE_CLOCK, { idx: 'clk00', clk })

  var inc = { day: 0, hrs: 0, min: 1, mth: 0, sec: 6, yrs: 0 }
  bit = await ste.hunt(ActInc.WRITE_INCREMENT, { idx: 'inc00', inc })

  var bit = await ste.hunt(ActTme.RANDOM_TIME, { idx:'clk00' })

  bal.slv({ tmeBit: { idx: 'test-time', src: 'testing-time' } });
  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


export default interface ClockBit {
  idx: string;
  opn?: string;
  dex?: number;
  src?: string;
  now?: number;
  val?: number;
  pst?: number;
  qtr?: number;
  yrs?: number;
  mth?: number;
  wek?: number;
  day?: number;
  hrs?: number;
  min?: number;
  sec?: number;
  cnt?: number;
  dat?: any;
  slv?: any;
  prt?:any;
}

import ClockBit from "./clock.bit";

export default interface TimeBit {
  idx: string;
  val?: number;
  src?:string;
  slv?:Function;
  prt?:any;
  dat?:any;
  bit?:any;
  clk?:ClockBit
}


import  TimeBit  from "./time.bit";

export default interface Time {
 // idx:string;
 // timeBitList: TimeBit[];
 // timeBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import TimeBit from "./fce/time.bit";

// Time actions

export const INIT_TIME = "[Time action] Init Time";
export class InitTime implements Action {
  readonly type = INIT_TIME;
  constructor(public bale: TimeBit) {}
}

export const UPDATE_TIME = "[Time action] Update Time";
export class UpdateTime implements Action {
  readonly type = UPDATE_TIME;
  constructor(public bale: TimeBit) {}
}


 export const TEST_TIME = "[Reduce action] Test Time";
 export class TestTime implements Action {
 readonly type = TEST_TIME;
 constructor(public bale: TimeBit) {}
 }
 
export const RANDOM_TIME = "[Random action] Random Time";
 export class RandomTime implements Action {
 readonly type = RANDOM_TIME;
 constructor(public bale: TimeBit) {}
 }
 
export type Actions = InitTime| UpdateTime | TestTime
| RandomTime
export { initTime } from "./buz/time.buzz";
export { updateTime } from "./buz/time.buzz";
export { testTime  } from "./buz/time.buzz";
export { randomTime  } from "./buz/time.buzz";
import Time from "./fce/time.interface";
import TimeBit from "./fce/time.interface";

export class TimeModel implements Time {
 idx:string = '001.time';
 //timeBitList: TimeBit[] = [];
 //timeBits: any = {};
 
}

import * as clone from "clone-deep";
import * as Act from "./time.action";
import { TimeModel } from "./time.model";
import * as Buzz from "./time.buzzer";
import State from "../99.core/state";

export function reducer(model: TimeModel = new TimeModel(), act: Act.Actions, state?: State) {
  switch (act.type) {

    case Act.UPDATE_TIME:
      return Buzz.updateTime(clone(model), act.bale, state);

    case Act.INIT_TIME:
      return Buzz.initTime(clone(model), act.bale, state);


    case Act.TEST_TIME:
      return Buzz.testTime(clone(model), act.bale, state);


case Act.RANDOM_TIME:
 return Buzz.randomTime(clone(model), act.bale, state);
 
    default:
      return model;
  }
}


import State from "../99.core/state";


export default class TimeUnit {

 constructor(state: State) {
 }
}

global.TIME = require("../dist/001.time/hunt");

import { ProgressModel } from "../progress.model";
import ProgressBit from "../fce/progress.bit";
import State from "../../99.core/state";

import * as ActClk from '../../03.clock.unit/clock.action'
import * as ActInc from '../../02.increment.unit/increment.action'

var bit, dat;

export const initProgress = (cpy: ProgressModel, bal: ProgressBit, ste: State) => {
    debugger
    return cpy;
};

export const updateProgress = async (cpy: ProgressModel, bal: ProgressBit, ste: State) => {

    bit = await ste.hunt( ActInc.READ_INCREMENT, { idx: bal.idx })
    var increment = bit.incBit.dat;
    
    

    var obj = { hours: 0, minutes: 0, days: 0, seconds: 0 }

    obj.hours = increment.hrs;
    obj.minutes = increment.min;
    obj.days = increment.day;
    obj.seconds = increment.sec;

    

    bit = await ste.hunt(ActClk.READ_CLOCK, { idx: bal.src })
    dat = bit.clkBit.dat;

    

    dat.bit = dat.bit.plus( obj );
    dat.bit

    bit = await ste.hunt(ActClk.ADAPT_CLOCK, { dat: dat.bit })

    var now =  bit.clkBit.dat
    
    bit = await ste.hunt(ActClk.WRITE_CLOCK, { idx:bal.src, dat: {clk: now } })
    bal.slv({ prgBit: { idx: 'update-progress', dat:bit.clkBit.dat } });
    return cpy;
};




export default interface ProgressBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  ProgressBit  from "./progress.bit";

export default interface Progress {
 // idx:string;
 // progressBitList: ProgressBit[];
 // progressBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  ProgressBit  from "./fce/progress.bit";

// Progress actions

export const INIT_PROGRESS = "[Progress action] Init Progress";
export class InitProgress implements Action {
 readonly type = INIT_PROGRESS;
 constructor(public bale: ProgressBit) {}
}

export const UPDATE_PROGRESS = "[Progress action] Update Progress";
export class UpdateProgress implements Action {
 readonly type = UPDATE_PROGRESS;
 constructor(public bale: ProgressBit) {}
}

export type Actions = | InitProgress | UpdateProgress ;

export { initProgress  } from "./buz/progress.buzz";
export { updateProgress  } from "./buz/progress.buzz";

import Progress from "./fce/progress.interface";
import ProgressBit from "./fce/progress.interface";

export class ProgressModel implements Progress {
 //idx:string;
 //progressBitList: ProgressBit[] = [];
 //progressBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./progress.action";
import { ProgressModel } from "./progress.model";
import * as Buzz from "./progress.buzzer";
import State from "../99.core/state";

export function reducer(model: ProgressModel = new ProgressModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_PROGRESS:
 return Buzz.updateProgress(clone(model), act.bale, state);

 case Act.INIT_PROGRESS:
 return Buzz.initProgress(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ProgressUnit {

 constructor(state: State) {
 }
}

import { IncrementModel } from "../increment.model";
import IncrementBit from "../fce/increment.bit";
import State from "../../99.core/state";
import IncBit from "../fce/inc.bit";


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActInc from "../../02.increment.unit/increment.action";

var bit, val, idx, dex, lst, dat, src;


export const initIncrement = (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    bal.slv({ incBit: { idx: "init-increment" } });
    return cpy;
};


export const updateIncrement = (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    // This function would be triggered after a 'write' to an existing item.
    // Add any logic here that needs to run when an increment's data changes.
    bal.slv({ incBit: { idx: "update-increment" } });
    return cpy;
};


export const readIncrement = async (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'inc00';

    // The READ_COLLECT action is smart: it ensures data exists by attempting a write/create if not found.
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActInc.CREATE_INCREMENT });

    if (bal.slv != null) bal.slv({ incBit: { idx: "read-increment", dat: bit.clcBit.dat } });
    return cpy;
};


export const writeIncrement = async (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    // WRITE_COLLECT handles both creating new and updating existing entries.

    

    if (bal.dat == null ) bal.dat = {}
    if (bal.dat.dat == null) bal.dat.dat = {}
    if (bal.inc != null) bal.dat.inc = bal.inc;


    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActInc.CREATE_INCREMENT });

   
    if (bal.slv != null) bal.slv({ incBit: { idx: "write-increment", dat: bit.clcBit.dat } });
    return cpy;
};


export const removeIncrement = async (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    // REMOVE_COLLECT will internally call the DELETE_INCREMENT action if needed.
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActInc.DELETE_INCREMENT });

    if (bal.slv != null) bal.slv({ incBit: { idx: "remove-increment", dat: bit.clcBit.dat } });
    return cpy;
};


export const deleteIncrement = (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    // For data-only objects, there's often nothing to destroy.
    // This is a hook for more complex, stateful objects.
    if (bal.slv != null) bal.slv({ incBit: { idx: "delete-increment" } });
    return cpy;
};


export const createIncrement = (cpy: IncrementModel, bal: IncrementBit, ste: State) => {

    if (bal.dat == null) bal.dat = {}

    if (bal.dat.inc == null) {

        var incBit: IncBit = { idx: bal.idx }
        incBit.day = 0;
        incBit.hrs = 0;
        incBit.min = 0;
        incBit.mth = 0;
        incBit.sec = 6;
        incBit.yrs = 0;

        bal.dat.inc = incBit

    }

    var inc = bal.dat.inc;
    inc.idx = bal.idx

    for (var key in inc) {

        if (key == 'idx') continue

        if (inc[key] == '' || inc[key] == null) inc[key] = 0
        inc[key] = Number(inc[key])
    }

    inc
    
    //bit = await ste.hunt(ActClk.REFRESH_CLOCK, { val, dat: { clk } })
    //dat = bit.incBit.dat


    bal.slv({ incBit: { idx: "create-increment", dat: inc } });
    return cpy;


    // var dat: IncBit = {
    //     idx: bal.idx,
    //name: "Default Increment",
    //desc: "Generates resources.",
    //cost: 10,
    //baseCost: 10,
    //owned: 0,
    //cps_boost: 0, // cookies-per-second boost
    //cpc_boost: 0, // cookies-per-click boost
    //cost_scale: 1.15, // Cost increases by 15% each time
    // };

    // Overwrite defaults with any provided data
    // if (bal.dat != null) {
    //     for (var key in bal.dat) {
    //         dat[key] = bal.dat[key];
    //      }
    //   }

    //bal.slv({ incBit: { idx: "create-increment", dat: dat } });

};

export const listIncrement = async (cpy: IncrementModel, bal: IncrementBit, ste: State) => {
    dat = null

    bit = await ste.hunt(ActCol.LIST_COLLECT, { val: 0, bit: ActInc.LIST_INCREMENT })
    lst = bit.clcBit.lst

    bal.slv({ clkBit: { idx: 'list-clock', lst } });
};

export default interface TicBit {
    idx:string;
    src?:string;
    typ?:string;
    frm?:string;
    opn?: string;
    dex?: number;
    now?: number;
    val?: number;
    pst?: number;
    qtr?: number;
    yrs?: number;
    mth?: number;
    wek?: number;
    day?: number;
    hrs?: number;
    min?: number;
    sec?: number;
    cnt?: number;
    dat?: any;
    clk?: TicBit
    bit?: any;
}


export default interface IncrementBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
 inc?: null;
}




import  IncrementBit  from "./increment.bit";

export default interface Increment {
 // idx:string;
 // incrementBitList: IncrementBit[];
 // incrementBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  IncrementBit  from "./fce/increment.bit";

// Increment actions

export const INIT_INCREMENT = "[Increment action] Init Increment";
export class InitIncrement implements Action {
 readonly type = INIT_INCREMENT;
 constructor(public bale: IncrementBit) {}
}

export const UPDATE_INCREMENT = "[Increment action] Update Increment";
export class UpdateIncrement implements Action {
 readonly type = UPDATE_INCREMENT;
 constructor(public bale: IncrementBit) {}
}

export const READ_INCREMENT = "[Read action] Read Increment";
 export class ReadIncrement implements Action {
 readonly type = READ_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }
 
export const WRITE_INCREMENT = "[Write action] Write Increment";
 export class WriteIncrement implements Action {
 readonly type = WRITE_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }
 
export const REMOVE_INCREMENT = "[Remove action] Remove Increment";
 export class RemoveIncrement implements Action {
 readonly type = REMOVE_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }
 
export const DELETE_INCREMENT = "[Delete action] Delete Increment";
 export class DeleteIncrement implements Action {
 readonly type = DELETE_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }
 
export const CREATE_INCREMENT = "[Create action] Create Increment";
 export class CreateIncrement implements Action {
 readonly type = CREATE_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }

export const LIST_INCREMENT = "[List action] List Increment";
 export class ListIncrement implements Action {
 readonly type = LIST_INCREMENT;
 constructor(public bale: IncrementBit) {}
 }
 
export type Actions = 
| InitIncrement 
| UpdateIncrement
| ReadIncrement
| WriteIncrement
| RemoveIncrement
| DeleteIncrement
| CreateIncrement
| ListIncrement
// Exporting functions from the buzz file to be used in the reducer
export { initIncrement  } from "./buz/increment.buzz";
export { updateIncrement  } from "./buz/increment.buzz";
export { readIncrement  } from "./buz/increment.buzz";
export { writeIncrement  } from "./buz/increment.buzz";
export { removeIncrement  } from "./buz/increment.buzz";
export { deleteIncrement  } from "./buz/increment.buzz";
export { createIncrement  } from "./buz/increment.buzz";
export { listIncrement  } from "./buz/increment.buzz";
import Increment from "./fce/increment.interface";
import IncrementBit from "./fce/increment.interface";

export class IncrementModel implements Increment {
 //idx:string;
 //incrementBitList: IncrementBit[] = [];
 //incrementBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./increment.action";
import { IncrementModel } from "./increment.model";
import * as Buzz from "./increment.buzzer";
import State from "../99.core/state";

export function reducer(model: IncrementModel = new IncrementModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_INCREMENT:
  return Buzz.updateIncrement(clone(model), act.bale, state);

 case Act.INIT_INCREMENT:
  return Buzz.initIncrement(clone(model), act.bale, state);

 case Act.CREATE_INCREMENT:
  return Buzz.createIncrement(clone(model), act.bale, state);
 
 case Act.READ_INCREMENT:
  return Buzz.readIncrement(clone(model), act.bale, state);

 case Act.WRITE_INCREMENT:
  return Buzz.writeIncrement(clone(model), act.bale, state);

 case Act.REMOVE_INCREMENT:
  return Buzz.removeIncrement(clone(model), act.bale, state);

 case Act.DELETE_INCREMENT:
  return Buzz.deleteIncrement(clone(model), act.bale, state);
 
case Act.LIST_INCREMENT:
 return Buzz.listIncrement(clone(model), act.bale, state);
 
 default:
  return model;
 }
}
import State from "../99.core/state";

export default class IncrementUnit {

 constructor(state: State) {
 }
}

import { ClockModel } from "../clock.model";
import ClockBit from "../fce/clock.bit";
import State from "../../99.core/state";
import TicBit from "../fce/tic.bit";
import { DateTime } from "luxon";
import { BlockBit } from "../fce/blockbit";

//pnpm i --save-dev @types/luxon
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActClk from "../clock.action";

var bit, val, idx, dex, lst, dat;

export const initClock = (cpy: ClockModel, bal: ClockBit, ste: State) => {
  debugger
  return cpy;
};

export const refreshClock = (cpy: ClockModel, bal: ClockBit, ste: State) => {



  var increment = false;
  var day = 0;

  if (bal.dat.clk.yrs != null && bal.dat.clk.yrs == 0) {
    increment = true
    day = bal.dat.clk.day
  }


  var clk = bal.dat.clk;

  var dateObject = {
    day: 0,
    year: 0,
    hour: 0,
    month: 0,
    minute: 0,
    second: 0,
  }

  if (clk.day != null) dateObject.day = clk.day;
  if (clk.yrs != null) dateObject.year = clk.yrs;
  if (clk.hrs != null) dateObject.hour = clk.hrs;
  if (clk.mth != null) dateObject.month = clk.mth;
  if (clk.min != null) dateObject.minute = clk.min;
  if (clk.sec != null) dateObject.second = clk.sec;

  dateObject

  for (var key in dateObject) {
    var itm = dateObject[key]
    if (itm == 0) delete dateObject[key];
  }

  dateObject

  var dt = DateTime.fromObject(dateObject)

  var dat: TicBit = { idx: clk.idx, src: null };
  dat.bit = dt;

  dat.src = dt.toISO()
  dat.qtr = dt.quarter;
  dat.yrs = dt.year;
  dat.mth = dt.month;
  dat.wek = dt.weekNumber;
  dat.hrs = dt.hour;
  dat.day = dt.day;
  dat.sec = dt.second;
  dat.min = dt.minute;

  dat.frm = dt.toLocaleString(DateTime.DATETIME_HUGE_WITH_SECONDS)

  dat.now = dt.valueOf();
  dat.val = 0;
  dat.pst = 0;

  if (increment == true) {
    dat.yrs = 0;
    dat.mth = 0;
    dat.day = day;
    dat.wek = 0;
    dat.qtr = 0;
    dat.src = 'increment'
    dat.frm = 'increment'
    dat.now = 0;
  }

  bal.slv({ clkBit: { idx: "refresh-clock", dat } });
  return cpy;
};


export const updateClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  //var now: TicBit = bal.dat


  bit = await ste.hunt(ActClk.READ_CLOCK, { idx: bal.idx })

  var now = bit.clkBit.dat;

  var clk: TicBit = bal.dat.clk;

  for (var key in clk) {
    now[key] = clk[key]
  }

  now

  bit = await ste.hunt(ActClk.REFRESH_CLOCK, { dat: { clk: now } })
  dat = bit.clkBit.dat

  //bit = await ste.hunt(ActCol.UPDATE_COLLECT, { idx: bal.idx, dat, bit: ActClk.CREATE_CLOCK });
  //var data = bit.clcBit.dat

  bal.slv({ clkBit: { idx: "update-clock", dat: dat } });




  //var ticDat: TicBit = bit.clkBit.dat
  //var dt = ticDat.bit;

  //if (now.yrs == null) now.yrs = 0
  //if (now.mth == null) now.mth = 0
  //if (now.day == null) now.day = 0
  //if (now.hrs == null) now.hrs = 0

  //if (now.min == null) now.min = 0
  //if (now.sec == null) now.sec = 0
  //if (now.wek == null) now.wek = 0
  //if (now.qtr == null) now.qtr = 0;

  //var addition = {
  //  years: now.yrs,
  //  months: now.mth,
  //  days: now.day,
  //  hours: now.hrs,
  //  minutes: now.min,
  //  seconds: now.sec,
  //  weeks: now.wek,
  //  quarters: now.qtr
  // }

  // dt = dt.plus(addition);

  // ticDat.src = dt.toISO()
  // ticDat.qtr = dt.quarter;
  // ticDat.yrs = dt.year;
  // ticDat.mth = dt.month;
  // ticDat.wek = dt.weekNumber;
  // ticDat.day = dt.day;
  // ticDat.sec = dt.second;
  // ticDat.min = dt.minute;
  // ticDat.hrs = dt.hour;

  // ticDat.frm = dt.toLocaleString(DateTime.DATETIME_HUGE_WITH_SECONDS)

  // ticDat.now = dt.valueOf();
  // ticDat.bit = dt;



  //if (dat != null) {

  //}


  //if (bal.clk != null) {

  //  var moment = require('moment'); // require

  //  var now = moment.unix(dat.now + 10000);

  //var date = DateTime.local(dat.yrs, dat.mth, dat.day, dat.hrs, dat.min, dat.sec);
  //var now = date.toUnixInteger()

  //  if (bal.clk.sec == null) bal.clk.sec = 0
  //  if (bal.clk.min == null) bal.clk.min = 0
  //  if (bal.clk.hrs == null) bal.clk.hrs = 0
  //  if (bal.clk.day == null) bal.clk.day = 0
  //  if (bal.clk.wek == null) bal.clk.wek = 0
  //  if (bal.clk.mth == null) bal.clk.mth = 0
  //  if (bal.clk.yrs == null) bal.clk.yrs = 0

  //  var now = moment(dat.now); 
  //  now.add(bal.clk.sec, 's');
  //  now.add(11, 'm');
  //  now.add(bal.clk.hrs, 'h');
  //  now.add(bal.clk.day, 'd');
  //  now.add(bal.clk.wek, 'w');
  //  now.add(bal.clk.mth, 'M');
  //  now.add(bal.clk.yrs, 'y');

  //  dat.src = now.format("dddd, MMMM Do YYYY, h:mm:ss a");
  //  dat.now = now.unix();


  //  dat.hrs = now.hour()
  //  dat.sec = now.second()
  //  dat.min = now.minute()
  //  dat.day = now.day()
  //  dat.wek = now.weeks()
  //  dat.mth = now.month()
  //  dat.yrs = now.year()

  // dat

  //}
  //else {

  // }

  return cpy;
};


export const readClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {


  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "hex00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, src: bal.src, bit: ActClk.CREATE_CLOCK });



  if (slv != null) slv({ clkBit: { idx: "read-clock", dat: bit.clcBit.dat } });

  return cpy;
};

export const writeClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {



  if (bal.dat != null) {
    bit = await ste.hunt(ActClk.UPDATE_CLOCK, { idx: bal.idx, dat: bal.dat });
    bal.dat = bit.clkBit.dat

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActClk.CREATE_CLOCK });
    var data = bit.clcBit.dat

    if (bal.slv != null) bal.slv({ clkBit: { idx: "write-clock", dat: data } });
    return cpy;
  }


  bal.dat = {}
  if (bal.dat.dat == null) bal.dat.dat = {}
  if (bal.clk != null) bal.dat.clk = bal.clk;
  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActClk.CREATE_CLOCK });
  var data = bit.clcBit.dat
  if (bal.slv != null) bal.slv({ clkBit: { idx: "write-clock", dat: data } });
  return cpy;
};

export const removeClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActClk.DELETE_CLOCK })
  if (bal.slv != null) bal.slv({ clkBit: { idx: "remove-clock", dat: bit.clcBit } });

  return cpy;
};

export const createClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  if (bal.dat == null) bal.dat = {}

  if (bal.dat.clk == null) {

    var clkBit: TicBit = { idx: bal.idx }
    clkBit.day = 1;
    clkBit.hrs = 1;
    clkBit.min = 1;
    clkBit.mth = 1;
    clkBit.sec = 1;
    clkBit.yrs = 1111;

    bal.dat.clk = clkBit


  }

  var clk = bal.dat.clk;
  clk.idx = bal.idx

  for (var key in clk) {

    if (key == 'idx') continue

    if (clk[key] == '' || clk[key] == null) clk[key] = 0
    clk[key] = Number(clk[key])
  }

  clk
  
  bit = await ste.hunt(ActClk.REFRESH_CLOCK, { val, dat: { clk } })

  dat = bit.clkBit.dat

  bal.slv({ clkBit: { idx: "create-clock", dat: dat } });

  //for (var key in bal.dat) {
  //  if (key == 'dat') continue
  // dat[key] = bal.dat[key]
  // }

  //if (dat.idx == null) dat.idx = bal.idx;
  //if (dat.src == null) dat.src = "clk-bit";
  //if (dat.qtr == null) dat.qtr = 0;

  //if (dat.yrs == null) dat.yrs = 3210;
  //if (dat.mth == null) dat.mth = 3;
  //if (dat.wek == null) dat.wek = 3;
  //if (dat.day == null) dat.day = 3;
  //if (dat.hrs == null) dat.hrs = 3;
  //if (dat.min == null) dat.min = 3;
  //if (dat.sec == null) dat.sec = 3;

  //var moment = require('moment'); // require
  //var now = moment();

  //now.second(dat.sec)
  //now.minute(dat.min)
  //now.hour(dat.hrs)
  //now.day(dat.day)
  //now.month(dat.mth)
  //now.year(dat.yrs)

  //dat.src = now.format("dddd, MMMM Do YYYY, h:mm:ss a");
  //dat.now = now.unix();

  //var date = DateTime.local(dat.yrs, dat.mth, dat.day, dat.hrs, dat.min, dat.sec);

  //dat.yrs = date.year;
  //dat.mth = date.month;
  //dat.day = date.day;
  //dat.hrs = date.hour;
  //dat.min = date.minute;
  //dat.sec = date.second;
  //dat.cnt = Math.floor(date.diff(DateTime.local(dat.yrs, 1, 1), "days").days);
  //dat.wek = date.weekNumber;
  //dat.qtr = date.quarter;

  //dat.src = date.toFormat("MM-dd-yyyy, hh:mm:ss a");


  return cpy;
};

export const deleteClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {
  debugger
  return cpy;
};


//adds a tic bit of material to clock and return new tic bit of result
export const pushClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  bit = await ste.hunt(ActClk.READ_CLOCK, { idx: bal.idx })
  var dat: TicBit = bit.clkBit.dat
  var date = DateTime.local(dat.yrs, dat.mth, dat.day, dat.hrs, dat.min, dat.sec);

  var upd = bal.dat


  return cpy;
};


export const blockClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  var url = 'https://cardano-mainnet.blockfrost.io/api/v0/blocks/latest/';

  if (bal.idx == null) {
    return bal.slv({ clkBit: { idx: "block-clock-error", src: 'no-blockfrost-idx' } });
  }

  var blockfrost = bal.idx;

  fetch(url, {
    method: 'GET',
    headers: { 'project_id': blockfrost },
  })
    .then(response => response.json())
    .then(async response => {

      const rsp: BlockBit = response;
      var diff;

      if (rsp.epoch_slot == cpy.slot) {
        cpy.tick = false
      }
      else {
        cpy.tick = true

        var dt1 = DateTime.fromSeconds(cpy.slotTime)
        var dt2 = DateTime.fromSeconds(rsp.time)
        diff = dt1.diff(dt2, ["seconds"])

        //console.log(diff.toObject())
        //we need to calculate a time difference 
        //and we will call it score

        cpy.slot = rsp.epoch_slot
        cpy.slotTime = rsp.time

        var obj = diff.toObject();

        for (var key in obj) {
          obj[key] *= -1
        }

        cpy.score = obj.seconds

      }

      val = cpy.tick;
      dex = cpy.slot

      rsp.score = cpy.score

      dat = JSON.stringify(rsp)

      //can we convert some some time
      //going to give it the time of the response
      //covert to label
      //bit = await ste.hunt(ActClk.WRITE_CLOCK, { idx: bal.idx })
      //var clk:TicBit = bit.clkBit.dat;
      //debugger

      return bal.slv({ clkBit: { idx: "block-clock", val, dex, dat } });

    })
    .catch(err => {

      val = cpy.tick
      dex = cpy.slot

      bal.slv({ clkBit: { idx: "block-clock", val, dex } });
      console.error(err);

    })

  return cpy;
};


export const listClock = async (cpy: ClockModel, bal: ClockBit, ste: State) => {

  dat = null

  bit = await ste.hunt(ActCol.LIST_COLLECT, { val: 0, bit: ActClk.CREATE_CLOCK })
  lst = bit.clcBit.lst

  //if (bit.clcBit.dat == null) lst = []
  //else dat = bit.clcBit.dat;

  //if (dat != null) {
  //  dat.bitList.forEach((a) => {
  //    lst = []
  //    lst.push((a.idx))
  //  })
  // }

  bal.slv({ clkBit: { idx: 'list-clock', lst } });

  return cpy;
};

export const adaptClock = (cpy: ClockModel, bal: ClockBit, ste: State) => {

  var now = bal.dat;
  var dat = { day: 0, hrs: 0, min: 0, mth: 0, sec: 0, yrs: 0 }

  if (now.day != null) dat.day = now.day;
  if (now.hour != null) dat.hrs = now.hour;
  if (now.minute != null) dat.min = now.minute;
  if (now.month != null) dat.mth = now.month;
  if (now.second != null) dat.sec = now.second;
  if (now.year != null) dat.yrs = now.year;

  dat

  bal.slv({ clkBit: { idx: 'adapt-clock', dat } });

  return cpy;
};




export const testClock = (cpy: ClockModel, bal: ClockBit, ste: State) => {
  debugger
  return cpy;
};




import { Action } from "../99.core/interface/action.interface";
import  ClockBit  from "./fce/clock.bit";

// Clock actions

export const INIT_CLOCK = "[Clock action] Init Clock";
export class InitClock implements Action {
 readonly type = INIT_CLOCK;
 constructor(public bale: ClockBit) {}
}

export const UPDATE_CLOCK = "[Clock action] Update Clock";
export class UpdateClock implements Action {
 readonly type = UPDATE_CLOCK;
 constructor(public bale: ClockBit) {}
}

export const READ_CLOCK = "[Read action] Read Clock";
 export class ReadClock implements Action {
 readonly type = READ_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const WRITE_CLOCK = "[Write action] Write Clock";
 export class WriteClock implements Action {
 readonly type = WRITE_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const REMOVE_CLOCK = "[Remove action] Remove Clock";
 export class RemoveClock implements Action {
 readonly type = REMOVE_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const CREATE_CLOCK = "[Create action] Create Clock";
 export class CreateClock implements Action {
 readonly type = CREATE_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const DELETE_CLOCK = "[Delete action] Delete Clock";
 export class DeleteClock implements Action {
 readonly type = DELETE_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const BLOCK_CLOCK = "[Block action] Block Clock";
 export class BlockClock implements Action {
 readonly type = BLOCK_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const LIST_CLOCK = "[List action] List Clock";
 export class ListClock implements Action {
 readonly type = LIST_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const TEST_CLOCK = "[Test action] Test Clock";
 export class TestClock implements Action {
 readonly type = TEST_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const ADAPT_CLOCK = "[Adapt action] Adapt Clock";
 export class AdaptClock implements Action {
 readonly type = ADAPT_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export const REFRESH_CLOCK = "[Refresh action] Refresh Clock";
 export class RefreshClock implements Action {
 readonly type = REFRESH_CLOCK;
 constructor(public bale: ClockBit) {}
 }
 
export type Actions = | InitClock | UpdateClock 
| ReadClock
| WriteClock
| RemoveClock
| CreateClock
| DeleteClock
| BlockClock
| ListClock
| TestClock
| AdaptClock
| RefreshClock
export { initClock  } from "./buz/clock.buzz";
export { updateClock  } from "./buz/clock.buzz";
export { readClock  } from "./buz/clock.buzz";
export { writeClock  } from "./buz/clock.buzz";
export { removeClock  } from "./buz/clock.buzz";
export { createClock  } from "./buz/clock.buzz";
export { deleteClock  } from "./buz/clock.buzz";
export { blockClock  } from "./buz/clock.buzz";
export { listClock  } from "./buz/clock.buzz";
export { testClock  } from "./buz/clock.buzz";
export { adaptClock  } from "./buz/clock.buzz";
export { refreshClock  } from "./buz/clock.buzz";
import Clock from "./fce/clock.interface";
import ClockBit from "./fce/clock.interface";

export class ClockModel implements Clock {

    tick:boolean = true;
    slot: Number = 0;
    slotTime:Number = 0;
    score:any;
    //idx:string;
    //clockBitList: ClockBit[] = [];
    //clockBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./clock.action";
import { ClockModel } from "./clock.model";
import * as Buzz from "./clock.buzzer";
import State from "../99.core/state";

export function reducer(model: ClockModel = new ClockModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CLOCK:
 return Buzz.updateClock(clone(model), act.bale, state);

 case Act.INIT_CLOCK:
 return Buzz.initClock(clone(model), act.bale, state);

case Act.READ_CLOCK:
 return Buzz.readClock(clone(model), act.bale, state);
 
case Act.WRITE_CLOCK:
 return Buzz.writeClock(clone(model), act.bale, state);
 
case Act.REMOVE_CLOCK:
 return Buzz.removeClock(clone(model), act.bale, state);
 
case Act.CREATE_CLOCK:
 return Buzz.createClock(clone(model), act.bale, state);
 
case Act.DELETE_CLOCK:
 return Buzz.deleteClock(clone(model), act.bale, state);
 
case Act.BLOCK_CLOCK:
 return Buzz.blockClock(clone(model), act.bale, state);
 
case Act.LIST_CLOCK:
 return Buzz.listClock(clone(model), act.bale, state);
 
case Act.TEST_CLOCK:
 return Buzz.testClock(clone(model), act.bale, state);
 
case Act.ADAPT_CLOCK:
 return Buzz.adaptClock(clone(model), act.bale, state);
 
case Act.REFRESH_CLOCK:
 return Buzz.refreshClock(clone(model), act.bale, state);
 
 default:
 return model;
 }
}


import State from "../99.core/state";


export default class ClockUnit {

 constructor(state: State) {
 }
}


export default interface AmountBit {
 unit?:string;
 quantity?:number;
}

export interface BlockBit {
    block_vrf: string
    confirmations: number
    epoch: number
    epoch_slot: number
    fees: string
    hash: string
    height: number
    next_block: any
    op_cert: string
    op_cert_counter: string
    output: string
    previous_block: string
    size: number
    slot: number
    slot_leader: string
    time: number
    tx_count: number
    score:any;
  }
import AmountBit from "./amount.bit";

export default interface BlockfrostBit {
 address?:string;
 amount?: AmountBit[];
 script?: boolean;
 stake_address?:string;
 type?:string;
}

import TicBit from "./tic.bit";

export default interface ClockBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    bit?: any;
    slv?: Function;
    clk:TicBit
}


import  ClockBit  from "./clock.bit";

export default interface Clock {
 // idx:string;
 // clockBitList: ClockBit[];
 // clockBits:any;

}


export default interface TicBit {
    idx:string;
    src?:string;
    typ?:string;
    frm?:string;
    opn?: string;
    dex?: number;
    now?: number;
    val?: number;
    pst?: number;
    qtr?: number;
    yrs?: number;
    mth?: number;
    wek?: number;
    day?: number;
    hrs?: number;
    min?: number;
    sec?: number;
    cnt?: number;
    dat?: any;
    clk?: TicBit
    bit?: any;
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}


import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

//import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";
//import * as ActCns from "../../83.console.unit/console.action";


var lst, idx, bit, src, dat, dex;

var flag = false

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {


  setTimeout( ()=>{flag = true}, 3333)

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', async () => {

    //  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: bal.idx + " connected " + cpy.host })


      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', async () => {



        if ( flag == true){

         // bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: a.idx + " connected " + a.src })


        }

      
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, async (err) => {

      if (!err) {
      

    // bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'subscribing ' + a })


        
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit

    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify(cloneBit))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";
"use strict";
exports.__esModule = true;
//# sourceMappingURL=bus.bit.js.map

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=bus.interface.js.map

import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CANVAS = "[Canvas action] Init Canvas";
export const UPDATE_CANVAS = "[Canvas action] Update Canvas";
export const READ_CANVAS = "[Read action] Read Canvas";
export const WRITE_CANVAS = "[Write action] Write Canvas";
export const DELETE_CANVAS = "[Delete action] Delete Canvas";
export const REMOVE_CANVAS = "[Remove action] Remove Canvas";
export const CREATE_CANVAS = "[Create action] Create Canvas";
export const NEST_CANVAS = "[Nest action] Nest Canvas";
export const INIT_CHOICE = "[Choice action] Init Choice";
export const UPDATE_CHOICE = "[Choice action] Update Choice";
export const OPEN_CHOICE = "[Open action] Open Choice";
export const KEY_CHOICE = "[Key action] Key Choice";
export const TOWER_CHOICE = "[Tower action] Tower Choice";

export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";
export const INIT_DISK = '[Disk action] Init Disk'
export const UPDATE_DISK = '[Disk action] Update Disk'
export const READ_DISK = '[Disk action] Read Disk'
export const WRITE_DISK = '[Disk action] Write Disk'
export const INDEX_DISK = '[Index action] Index Disk'
export const LOAD_LIST_DISK = '[Load_list action] Load_list Disk'
export const COPY_DISK = '[Copy action] Copy Disk'
export const FRAME_DISK = '[Frame action] Frame Disk'
export const BATCH_DISK = '[Batch action] Batch Disk'
export const TRASH_DISK = '[Trash action] Trash Disk'
export const ENSURE_DISK = '[Ensure action] Ensure Disk'
export const DELETE_DISK = '[Delete action] Delete Disk'
export const INIT_ENGINE = "[Engine action] Init Engine";
export const UPDATE_ENGINE = "[Engine action] Update Engine";
export const MOVEMENT_ENGINE = "[Movement action] Movement Engine";
export const OPEN_ENGINE = "[Open action] Open Engine";
export const CLOSE_ENGINE = "[Close action] Close Engine";
 
export const INIT_GITHUB = "[Github action] Init Github";
export const UPDATE_GITHUB = "[Github action] Update Github";
export const COMMIT_GITHUB = "[Commit action] Commit Github";

import { Action } from "../99.core/interface/action.interface";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const CREATE_GRAPHIC = "[Create action] Create Graphic";

export const INIT_GRID = "[Grid action] Init Grid";
export const UPDATE_GRID = "[Grid action] Update Grid";

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export const READ_HEXAGON = "[Read action] Read Hexagon"; 
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
export const INIT_INPUT = "[Input action] Init Input";
export const UPDATE_INPUT = "[Input action] Update Input";
export const OPEN_INPUT = "[Open action] Open Input";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const READY_SPACE = "[Ready action] Ready Space";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const RUN_TERMINAL = "[Run action] Run Terminal";
export const EDIT_TERMINAL = "[Edit action] Edit Terminal"; 
export const PRINT_TERMINAL = "[Print action] Print Terminal";
export const CLOSE_TERMINAL = "[Close action] Close Terminal";
export const OPTION_TERMINAL = "[Option action] Option Terminal";
export const INPUT_TERMINAL = "[Input action] Input Terminal"; 
export const LAYOUT_TERMINAL = "[Layout action] Layout Terminal";
export const OPEN_TERMINAL = "[Layout action] Open Terminal";
export const CLEAR_TERMINAL = "[Layout action] Clear Terminal";

export const INIT_TEXT = "[Text action] Init Text";
export const UPDATE_TEXT = "[Text action] Update Text";
export const READ_TEXT = "[Read action] Read Text";
export const WRITE_TEXT = "[Write action] Write Text";
export const CREATE_TEXT = "[Create action] Create Text";
export const REMOVE_TEXT = "[Remove action] Remove Text";
export const DELETE_TEXT = "[Delete action] Delete Text";
export const LIST_TEXT = "[List action] List Text";

export const INIT_VISAGE = "[Visage action] Init Visage";
export const UPDATE_VISAGE = "[Visage action] Update Visage";
export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage"; 
export const READ_VISAGE = "[Read action] Read Visage";
export const WRITE_VISAGE = "[Write action] Write Visage"; 
export const CREATE_VISAGE = "[Create action] Create Visage";
export const SIZE_VISAGE = "[Size action] Size Visage";
export const RENDER_VISAGE = "[Render action] Render Visage";
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import TimeUnit from "./00.time.unit/time.unit";
import ProgressUnit from "./01.progress.unit/progress.unit";
import IncrementUnit from "./02.increment.unit/increment.unit";
import ClockUnit from "./03.clock.unit/clock.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Time from "./00.time.unit/fce/time.interface";
import { TimeModel } from "./00.time.unit/time.model";
import Progress from "./01.progress.unit/fce/progress.interface";
import { ProgressModel } from "./01.progress.unit/progress.model";
import Increment from "./02.increment.unit/fce/increment.interface";
import { IncrementModel } from "./02.increment.unit/increment.model";
import Clock from "./03.clock.unit/fce/clock.interface";
import { ClockModel } from "./03.clock.unit/clock.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [TimeUnit,ProgressUnit,IncrementUnit,ClockUnit,CollectUnit,BusUnit];

import * as reduceFromTime from "./00.time.unit/time.reduce";
import * as reduceFromProgress from "./01.progress.unit/progress.reduce";
import * as reduceFromIncrement from "./02.increment.unit/increment.reduce";
import * as reduceFromClock from "./03.clock.unit/clock.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 time : reduceFromTime.reducer, 
progress : reduceFromProgress.reducer, 
increment : reduceFromIncrement.reducer, 
clock : reduceFromClock.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 time : Time = new TimeModel();
progress : Progress = new ProgressModel();
increment : Increment = new IncrementModel();
clock : Clock = new ClockModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const VERTICAL = "vertical";
export const HORIZONTAL = "horizontal";



export const BLACK: string = "black";
export const RED: string = "red";
export const GREEN: string = "green";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";
export const CYAN: string = "cyan";
export const WHITE: string = "white";
export const BLUE: string = "blue";
"use strict";
exports.__esModule = true;
exports.CYAN = exports.MAGENTA = exports.YELLOW = exports.GREEN = exports.RED = void 0;
exports.RED = "\x1b[31m%s\x1b[0m";
exports.GREEN = "\x1b[32m%s\x1b[0m";
exports.YELLOW = "\x1b[33m%s\x1b[0m";
exports.MAGENTA = "\x1b[34m%s\x1b[0m";
exports.CYAN = "\x1b[36m%s\x1b[0m";
//# sourceMappingURL=console.js.map
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

"use strict";
exports.__esModule = true;
exports.WISE_NORTH_EAST = exports.WISE_NORTH = exports.WISE_NORTH_WEST = exports.WISE_WEST = exports.WISE_SOUTH_WEST = exports.WISE_SOUTH = exports.WISE_SOUTH_EAST = exports.WISE_EAST = exports.NORTH_EAST = exports.NORTH = exports.NORTH_WEST = exports.WEST = exports.SOUTH_WEST = exports.SOUTH = exports.SOUTH_EAST = exports.EAST = void 0;
exports.EAST = "E";
exports.SOUTH_EAST = "SE";
exports.SOUTH = "S";
exports.SOUTH_WEST = "SW";
exports.WEST = "W";
exports.NORTH_WEST = "NW";
exports.NORTH = "N";
exports.NORTH_EAST = "NE";
exports.WISE_EAST = "Wise E";
exports.WISE_SOUTH_EAST = "Wise SE";
exports.WISE_SOUTH = "Wise S";
exports.WISE_SOUTH_WEST = "Wise SW";
exports.WISE_WEST = "Wise W";
exports.WISE_NORTH_WEST = "Wise NW";
exports.WISE_NORTH = "Wise N";
exports.WISE_NORTH_EAST = "Wise NE";
//# sourceMappingURL=direction.js.map
export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
"use strict";
exports.__esModule = true;
exports.CIRCLE = exports.ROUNDED_RECTANGLE = exports.RECTANGLE = void 0;
exports.RECTANGLE = "rectangle";
exports.ROUNDED_RECTANGLE = "rounded-rectangle";
exports.CIRCLE = "circle";
//# sourceMappingURL=graphic.js.map
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export type Position <Type> = {
    x: number;
    y: number;
} & Type


export type GridFill =Position<{
    xSpan:number;
    ySpan:number;
}>

export const TOP_FULL_IDX = 'top-fill';
export const MID_FULL_IDX = 'mid-fill';
export const BOT_FULL_IDX  = 'bot-fill';

export const TOP_FULL_BIT:GridFill= {x:0, y:0, xSpan:12, ySpan:4};
export const MID_FULL_BIT:GridFill= {x:0, y:4, xSpan:12, ySpan:5};
export const BOT_FULL_BIT:GridFill= {x:0, y:8, xSpan:12, ySpan:4};

"use strict";
exports.__esModule = true;
exports.HEXMAP = exports.FOCUS = void 0;
exports.FOCUS = "focus";
exports.HEXMAP = "hexmap";
//# sourceMappingURL=hexagon.js.map
export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
"use strict";
exports.__esModule = true;
exports.PASTURE = exports.FANG_SWAMP = exports.GEORGIA = exports.GALLBLADDER = void 0;
exports.GALLBLADDER = "00000.gallbladder";
exports.GEORGIA = "00001.georgia";
exports.FANG_SWAMP = "00002.fang-swamp";
exports.PASTURE = "00003.pasture";
//# sourceMappingURL=hexmap.js.map
export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const WELCOME_WINDOW: string = "welcomeWindow";
export const PLAY_DATA_GROUP: string = "playerDataGroup";
export const ICON_WINDOW: string = "iconWindow";
export const DEBUG_WINDOW: string = "debugWindow";
export const ACTION_BAR: string = "actionBar";
export const CLOCK_BAR: string = "clockBar";
export const ERROR_MESSAGE: string = "errorMessage";
export const COVER_SCREEN: string = "coverScreen";
"use strict";
exports.__esModule = true;
exports.MAGENTA = exports.YELLOW = exports.BLUE = exports.GREEN = exports.RED = exports.CYAN = exports.CLEAN = exports.MENU_SINGLE = exports.TIMELINE = exports.SPACE = void 0;
exports.SPACE = "space";
exports.TIMELINE = "timeline";
exports.MENU_SINGLE = "menu_single";
exports.CLEAN = "clean";
exports.CYAN = "cyan";
exports.RED = "red";
exports.GREEN = "green";
exports.BLUE = "blue";
exports.YELLOW = "yellow";
exports.MAGENTA = "magenta";
//# sourceMappingURL=markup.js.map
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

"use strict";
exports.__esModule = true;
exports.LOOP = exports.VIDEO = exports.HEXAGON = exports.SPRITE = exports.TEXT = exports.GRAPHIC = exports.CONTAINER = exports.SURFACE = exports.VISAGE = void 0;
exports.VISAGE = "visage";
exports.SURFACE = "surface";
exports.CONTAINER = "container";
exports.GRAPHIC = "graphic";
exports.TEXT = "text";
exports.SPRITE = "sprite";
exports.HEXAGON = "hexagon";
exports.VIDEO = "video";
exports.LOOP = "loop";
//# sourceMappingURL=shade.js.map
export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
export const GEOJSON = "geojson";
export const RECTANGLE = "rectangle";
export const TRIANGLE = "triangle";
export const HEXAGON = "hexagon";
export const PARALLELOGRAM = "parallelogram";

export const FOCUS = "focus";
export const HEXMAP = "hexmap";
export const CLOCK: string = "clock";
"use strict";
exports.__esModule = true;
exports.MOUNT_WIDTH = exports.MOUNT_HEIGHT = exports.MOUNT_PART = exports.MOUNT_FULL = exports.SCREEN = void 0;
exports.SCREEN = "screen-visage";
exports.MOUNT_FULL = "mount-visage-full";
exports.MOUNT_PART = "mount-visage-part";
exports.MOUNT_HEIGHT = "mount-visage-height";
exports.MOUNT_WIDTH = "mount-visage-width";
//# sourceMappingURL=visage.js.map
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";
import { SpaceModel } from "../space.model";
import SpaceBit from "../fce/space.bit";
import State from "../../99.core/state";

import * as S from 'string'


import * as ActSpc from "../../00.space.unit/space.action";
import * as ActGeo from "../../03.geojson.unit/geojson.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActCns from "../../act/console.action";


import * as ActPvt from "../../act/pivot.action";
import * as ActDsk from "../../act/disk.action";

import * as ActBus from "../../99.bus.unit/bus.action";

var bit, lst, dex, src, dat;

export const initSpace = async (cpy: SpaceModel, bal: SpaceBit, ste: State) => {

  //bit = await ste.hunt(ActBus.INIT_BUS, { idx: cpy.idx, src: bal.src, lst: [ActSpc, ActGeo, ActMap, ActFoc], dat: bal.dat });

  //if (bal.val == 1) {
  //  bit = await ste.hunt(ActTrm.INIT_TERMINAL, {});

  //  patch(ste, ActMnu.INIT_MENU, {});
  // }

  bal.slv({ intBit: { idx: 'init-space' } });

  return cpy;
};

export const updateSpace = (cpy: SpaceModel, bal: SpaceBit, ste: State) => {

  
  bal.slv({ spcBit: { idx: "update-space" } });

  return cpy;

};

export const testSpace = async (cpy: SpaceModel, bal: SpaceBit, ste: State) => {

  //bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: "cns00", src: "-----------" });
  //bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: "cns00", src: "Testing Space" });
  //bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: "cns00", src: "-----------" });

  bal.slv({ spcBit: { idx: "test-space", src: "testing-space", val: 1 } });

  return cpy;
};



var patch = (ste, type, bale) => ste.dispatch({ type, bale });

export default interface SpaceBit {
    idx: string;
    val?: number;
    src?:string;
    slv?:Function;
    prt?:any;
    dat?:any;
    bit?:any;
}


import  SpaceBit  from "./space.bit";

export default interface Space {
 // idx:string;
 // spaceBitList: SpaceBit[];
 // spaceBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SpaceBit  from "./fce/space.bit";

// Space actions

export const INIT_SPACE = "[Space action] Init Space";
export class InitSpace implements Action {
 readonly type = INIT_SPACE;
 constructor(public bale: SpaceBit) {}
}

export const UPDATE_SPACE = "[Space action] Update Space";
export class UpdateSpace implements Action {
 readonly type = UPDATE_SPACE;
 constructor(public bale: SpaceBit) {}
}

export const TEST_SPACE = "[Test action] Test Space";
 export class TestSpace implements Action {
 readonly type = TEST_SPACE;
 constructor(public bale: SpaceBit) {}
 }
 

export type Actions = | InitSpace | UpdateSpace 
| TestSpace

export { initSpace  } from "./buz/space.buzz";
export { updateSpace  } from "./buz/space.buzz";
export { testSpace  } from "./buz/space.buzz";

import Space from "./fce/space.interface";
import SpaceBit from "./fce/space.interface";

export class SpaceModel implements Space {
 idx:string = '002.space'
 //spaceBitList: SpaceBit[] = [];
 //spaceBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./space.action";
import { SpaceModel } from "./space.model";
import * as Buzz from "./space.buzzer";
import State from "../99.core/state";

export function reducer(model: SpaceModel = new SpaceModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SPACE:
 return Buzz.updateSpace(clone(model), act.bale, state);

 case Act.INIT_SPACE:
 return Buzz.initSpace(clone(model), act.bale, state);

case Act.TEST_SPACE:
 return Buzz.testSpace(clone(model), act.bale, state);
 

 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SpaceUnit {

 constructor(state: State) {
 }
}

global.SPACE = require("../dist/002.space/hunt");

'use server'

import * as Import from "./BEE";
import State from "./99.core/state";

var dex = 0;

let instance = null;

var sim = {
  hunt: (a, b) => { },
  state: null
};

sim.hunt = (typ, obj) => { return host(obj, typ) }

var host = (obj, typ) => {

  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);

  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {

  if (!instance) {

    if (sim.state != null) return;
    sim.state = new State();
    sim.state.pivot = sim;
    sim.state.hunt = sim.hunt
    for (var k in Import.list) new Import.list[k](sim.state);
    instance = sim
  }


  return instance

};


export const space = async (typ, obj) => {
  return sim.hunt(typ, obj)
}
import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'
import SpotBit from "../../02.focus.unit/fce/spot.bit";

import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const initHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  var lst = [ActMap.OPEN_HEXMAP];
  bal.slv({ intBit: { idx: "init-focus", lst } });

  return cpy;
};

export const updateHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  return cpy;
};


export const focusingHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: bal.idx })
  var hexmap: MapBit = bit.mapBit.dat;

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.src })
  var focus: SpotBit = bit.focBit.dat;

  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: focus.idx, dat: { map: hexmap.idx } })
  var focus: SpotBit = bit.focBit.dat;

  if (bal.slv != null) bal.slv({ mapBit: { idx: "focusing-hexmap", dat: { idx: hexmap.idx, src: focus.idx, dat: focus } } });

  return cpy;
};


export const defocusHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  debugger
  return cpy;
};



export const openHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  if (bal.idx.includes('.') == false) bal.idx = bal.src;

  var url = 'https://www.fictiq.com/dat/hexmap/' + bal.idx + '.json';
  bit = await fetch(url, { method: 'GET', headers: { 'head': 'none' } })
  dat = await bit.json()

  bit = await ste.hunt(ActMap.ADD_HEXMAP, { idx: bal.idx, dat: { dat, gph: 'gph00' } })

  if (bal.slv != null) bal.slv({ mapBit: { idx: "open-hexmap", dat } });

  return cpy;
};

export const addHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  if (bal.idx == null) bal.idx = 'hex000'

  dat = { frm: 'geojson', bit: bal.dat.dat, gph: bal.dat.gph }


  bit = await ste.hunt(ActMap.WRITE_HEXMAP, { idx: bal.idx, dat })

  if (bal.slv != null) bal.slv({ mapBit: { idx: "add-hexmap", dat: bit.mapBit.dat } });
  return cpy;
};


export const writeHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  if (bal.idx == null) bal.idx = 'map00'

  if (bal.val != null) bal.dat.val = bal.val

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActMap.CREATE_HEXMAP })



  if (bal.slv != null) bal.slv({ mapBit: { idx: "write-hexmap", dat: bit.clcBit.dat } });

  return cpy;
};


export const readHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = 'map00';
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActMap.CREATE_HEXMAP })


  if (slv != null) slv({ mapBit: { idx: "read-hexmap", dat: bit.clcBit.dat } });

  return cpy;
};


export const copyHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  return cpy;
};


var geojson = false;

export const geojsonHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {



  debugger


  if (bal.slv != null) bal.slv({ mapBit: { idx: "geojson-hexmap", dat: cpy.geoJsonNow } });
  return cpy;
};



export const toolHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  if (geojson == true) {
    if (bal.slv != null) bal.slv({ mapBit: { idx: "tool-hexmap" } });
    return
  }

  geojson = true;

  var link = ["https://geoman.io/geojson-editor", "https://www.keene.edu/campus/maps/tool/"];

  var Chance = require("chance");
  var fate = new Chance();
  var now = fate.pickone(link);

  //const open = require('open')
  //var loc = './vew.shd.bat'
  //bit = await open(now)

  if (bal.slv != null) bal.slv({ mapBit: { idx: "tool-hexmap", src: now } });
  return cpy;
};



export const storeHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  bit = await ste.hunt(ActMap.ADD_HEXMAP, { idx: bal.idx, dat: { gph: bal.src, dat: bal.dat } });
  if (bal.slv != null) bal.slv({ mapBit: { idx: "store-hexmap", dat: bal.dat } });

  return cpy;
};


export const listHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  dat = null
  bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActMap.CREATE_HEXMAP })
  if (bit.clcBit.dat == null) lst = []
  else dat = bit.clcBit.dat;

  if (dat != null) {
    lst = []
    dat.bitList.forEach((a) => {
      lst.push((a.idx))
    })
  }

  bal.slv({ mapBit: { idx: "list-hexmap", lst } });

  return cpy;
};






export const nameHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  cpy.mapNomNow = bal.idx;
  if (bal.slv != null) bal.slv({ mapBit: { idx: "name-hexmap", dat: cpy.atlasNow } });

  return cpy;
};


export const replaceHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  cpy.atlasNow = bal.dat;
  cpy.sizeNow = cpy.atlasNow.length;

  if (bal.slv != null) bal.slv({ mapBit: { idx: "replace-hexmap", dat: cpy.atlasNow } });

  return cpy;
};


export const seekHexmap = (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  debugger
  return cpy;
};


export const selectHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: bal.idx })
  var hexmap: MapBit = bit.mapBit.dat;

  cpy.select = hexmap;

  if (bal.slv != null) bal.slv({ mapBit: { idx: "select-hexmap", dat: cpy.select } });

  return cpy;
};




import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'
import SpotBit from "../../02.focus.unit/fce/spot.bit";


import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActCns from "../../act/console.action";


import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActDsk from "../../act/disk.action";
import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const atlasHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {
  //create a hexmap
  //node ./hand/013.vurt-hexmap -t 0.15

  var detailList = bal.lst

  if ( detailList == null ) detailList = ['black', "white"]
  
  if (bal.idx == null) bal.idx = 'map00'
  if (bal.val == null) bal.val = 10;

  var h3 = require("h3-js");
  var clone = require("clone-deep");
  var Fate = require('chance');
  var fate = new Fate();

  var h3ToGeo = h3.h3ToGeo;
  var hexRing = h3.hexRing;
  var polyfill = h3.polyfill;

  var name = bal.idx;
  var scale = bal.val;
  var data = bal.dat;

  var hex = [];
  var map = [];

  var cords = data.coordinates;
  if (cords == null) {
    if (data.features != null) {
      cords = data.features[0].geometry.coordinates;
    }
  }


  var trim = (val) => {
    var dat = 0;

    switch (val) {
      case 1:
        dat = 0;
        break;
      case 2:
        dat = 0;
        break;
      case 3:
        dat = 0;
        break;
      case 4:
        dat = 1;
        break;
      case 5:
        dat = 1;
        break;
      case 6:
        dat = 5;
        break;
      case 7:
        dat = 5;
        break;
      case 8:
        dat = 5;
        break;
      case 9:
        dat = 5;
        break;
      case 10:
        dat = 5;
        break;
      case 11:
        dat = 6;
        break;
      case 12:
        dat = 6;
        break;
      case 13:
        dat = 6;
        break;
      case 14:
        dat = 6;
        break;
      default:
        dat = 6;
    }

    return dat;
  };

  hex = polyfill(cords, scale, true);
  

  if (hex.length == 0) {
    console.log("no hexes for " + scale);
    if (bal.slv != null) bal.slv({ mapBit: { idx: "no-atlas-hexmap" } });
    return
  }


  //console.log(JSON.stringify(hex));

  var msg = "SCALE : " + scale + " SIZE : " + hex.length;

  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "-----------" })


  var left = null;
  var right = null;
  var top = null;
  var bottom = null;
  var width = 0;
  var height = 0;

  var edge = {};

  //var clr = fate.pickone(matchHue(name)).item;

  hex.forEach((a, b) => {
    var center = h3ToGeo(a);

    var t = trim(scale);

    var xDex = Math.abs(Number(center[1].toFixed(t)));
    var yDex = Math.abs(Number(center[0].toFixed(t)));
    center[1] = xDex = Math.ceil(xDex * Math.pow(10, t));
    center[0] = yDex = Math.ceil(yDex * Math.pow(10, t));

    if (right == null) right = xDex;
    else if (xDex < right) right = xDex;
    if (left == null) left = xDex;
    else if (xDex > left) left = xDex;

    if (top == null) top = yDex;
    else if (yDex > top) top = yDex;
    if (bottom == null) bottom = yDex;
    else if (yDex < bottom) bottom = yDex;

    var saveData = { hex: a, center: center, color: null };

    //console.log("show me center " + clr.hex);

    //if (clr == null) return;
    //if (clr.hex == null) return;

    // saveData.color = makeHue(clr.hex);
    //saveData.color = this.color.leaf(clr.hex);

    //delete saveData.color.rgb;
    //delete saveData.color.distance;

    edge[a] = saveData;

    map.push(saveData);
  });

  map.forEach((a, b) => {
    var center = a.center;
    center[1] = left - center[1];
    center[0] = top - center[0];
    map[b].center = center;
  });

  var grid0 = [];
  map.forEach((a) => {
    var x = a.center[1];
    var y = a.center[0];
    grid0.push({ hex: a.hex, x: x, y: y });
  });

  grid0.sort(function (a, b) {
    return a.y - b.y;
  });

  grid0.forEach((a, b) => {
    grid0[b] = { hex: a.hex, x: a.x, y: b };
  });

  grid0.sort(function (a, b) {
    return a.x - b.x;
  });

  var maxX = 0;
  var maxY = 0;

  grid0.forEach((a, b) => {
    grid0[b] = { hex: a.hex, x: b, y: a.y };
    edge[a.h] = grid0[b];
    if (grid0[b].x > maxX) maxX = grid0[b].x;
    if (grid0[b].y > maxY) maxY = grid0[b].y;
  });

  var connect = {};
  grid0.forEach((a, b) => {
    var hex = a.hex;

    var ring0 = hexRing(hex, 1);
    ring0.forEach((c, d) => {
      ring0[d] = { dex: d, hex: c, x: a.x, y: a.y };
    });

    var ring1 = [];
    ring0.forEach((c) => {
      if (edge[c.hex] == null) return;
      c.x = edge[c.hex].x;
      c.y = edge[c.hex].y;
      ring1.push(c);
    });

    var id = hex;
    connect[id] = ring1;
  });

  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "valley of the cube" })

  var cubeList = [];
  var cube = {};

  var now = { q: 0, r: 0, s: 0 };

  var cubeCount = hex.length;

  var cubeCheck = (hex, q, r, s) => {
    var lst = connect[hex];
    lst.forEach((a) => {
      var next = { hex: a.hex, q: q, r: r, s: s, lst:[] };

      if ( detailList.length > 0 ){
        next.lst.push( fate.pickone( detailList ) )
        next.lst.push( fate.pickone( detailList ) )
        next.lst.push( fate.pickone( detailList ) )
      }


      next.lst
    
      switch (a.dex) {
        case 0:
          next.q += 1;
          next.r -= 1;
          next.s += 0;
          break;
        case 1:
          next.q += 0;
          next.r -= 1;
          next.s += 1;
          break;
        case 2:
          next.q -= 1;
          next.r += 0;
          next.s += 1;
          break;
        case 3:
          next.q -= 1;
          next.r += 1;
          next.s += 0;
          break;
        case 4:
          next.q += 0;
          next.r += 1;
          next.s -= 1;
          break;
        case 5:
          next.q += 1;
          next.r += 0;
          next.s -= 1;
          break;
      }

      if (cube[a.hex] != null) return;
      cube[a.hex] = next;
      cubeCount -= 1;
      process.nextTick(() => cubeCheck(a.hex, next.q, next.r, next.s));
    });
  };

  var open = grid0[0];
  if (open == null) return;
  var value = { hex: open.hex, q: 0, r: 0, s: 0 };
  cube[open.hex] = value;
  cubeCheck(open.hex, 0, 0, 0);

  var endCheck = async () => {
    //console.log("cube count " + cubeCount);

    if (cubeCount > 1) return process.nextTick(endCheck);

    for (var key in cube) cubeList.push(cube[key]);

    var endMap = {};
    map.forEach((a) => {
      endMap[a.hex] = a;
    });

    var dat = {
      name: data.name,
      nom: data.nom,
      type: data.territory,
      ambit: data.territory,
      lot: "lot",
      slot: "slot",
      space: data.nom,
      flavor: "",
      //  shade: colorKey,
      //  exits: exitLst,
      scale: scale,
      size: hex.length,
      width: maxX,
      height: maxY,
      left: 0,
      right: 0,
      top: 0,
      bottom: 0,
      //file: file1,
      //  color: coloring,
      map: endMap,
      //grid: connect,
      cube: cubeList,
      grid: null,
    };

    const Hex = Honeycomb.extendHex({
      size: Number(1), // default: 1
      orientation: "flat",
    });

    const Grid = Honeycomb.defineGrid(Hex);

    var copied = clone(dat);

    copied.cube.forEach((a, b) => {
      const hexPrototype = { size: 1, hex: "value" };
      var Hex = Honeycomb.extendHex(hexPrototype);
      copied.cube[b] = Hex().cubeToCartesian({ q: a.q, r: a.r, s: a.s });
      copied.cube[b].hex = a.hex;
    });

    var lesserX = 0;
    var lesserY = 0;
    var mightyX = 0;
    var mightyY = 0;

    copied.cube.forEach((a) => {
      if (a.x < lesserX) lesserX = a.x;
      if (a.x > mightyX) mightyX = a.x;
      if (a.y < lesserY) lesserY = a.y;
      if (a.y > mightyY) mightyY = a.y;
    });

    dat.left = lesserX;
    dat.right = mightyX;
    dat.top = lesserY;
    dat.bottom = mightyY;

    const grid = Grid(copied.cube);
    var hY = grid.pointHeight();
    var wX = grid.pointWidth();

    dat.width = grid.pointWidth();
    dat.height = grid.pointHeight();
    

    //what the heck juice

    dat.grid = grid;
    
    cpy.atlasNow = dat;
    
    if (bal.slv != null) bal.slv({ mapBit: { idx: "atlas-hexmap", dat } });

  };

  process.nextTick(endCheck);

  return cpy;
};






import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'
import SpotBit from "../../02.focus.unit/fce/spot.bit";

import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActDsk from "../../act/disk.action";
import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const createHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  if (bal == null) bal = { idx, src, frm: null, val, typ: null, dat: {} }

  if (bal.dat == null) bal.dat = {}

  if (bal.dat.bit != null) {
    bal.slv({ mapBit: { idx: "create-hexmap", dat: bal.dat.bit } });
    return
  }

  var clone = require("clone-deep");

  var dat: MapBit = { idx: bal.idx, typ: HEXMAP.AMBT, val: bal.dat.val, ver: '00.00' }


  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  dat



  const Hex = Honeycomb.extendHex({
    size: Number(1), // default: 1
    orientation: "flat", //needs to be flat
  });

  const Grid = Honeycomb.defineGrid(Hex);

  dat.bit

  if (dat.bit == null) {
    bit = await ste.hunt(ActMap.SHAPE_HEXMAP, { dat })
    var shape = bit.mapBit.dat.bit
    dat.bit.grid = shape.bit
  }

  dat.bit.grid

  var copied = clone(dat.bit.grid);

  dat.grid = Grid(copied);

  var size = dat.grid.length

  if (dat.bit == null) {
    if (bal.slv != null) bal.slv({ mapBit: { idx: "create-hexmap-error", dat: { src: "no bit present" } } });
    return
  }

  dat

  bal.slv({ mapBit: { idx: "create-hexmap", val: size, dat } });
  return cpy;
};

import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";

import * as ActMap from "../hexmap.action";
import * as ActDsk from "../../act/disk.action";

let bit;

export const loadHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  bit = await ste.hunt( ActDsk.READ_DISK, { src: bal.src })  
  var mapBit = JSON.parse( bit.dskBit.dat )   
  bit = await ste.hunt( ActMap.WRITE_HEXMAP, { idx:bal.idx, dat: { bit: mapBit }  }) 

  debugger
  

  bal.slv({ mapBit: { idx: "load-hexmap", dat: {} } });

  return cpy;
};


import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'

import SpotBit from "../../02.focus.unit/fce/spot.bit";

import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActDsk from "../../act/disk.action";
import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const pouchHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  var dir = './data/mapbit';
  dat = {}

  bit = await ste.hunt(ActDsk.INDEX_DISK, { src: dir })

  lst = bit.dskBit.lst

  var out = []

  lst.forEach( (a)=>{

    var me = a.split('.')
    me.pop()

    idx = me.join('')

    var data = { idx, src:dir + '/' + a }
    out.push( data )
    
  })

  bit = await ste.hunt(ActDsk.WRITE_DISK, { idx:'./data/mapbit.json', dat: JSON.stringify(out) })


  bal.slv({ mapBit: { idx: "pouch-hexmap", lst:out } });

  return cpy;
};


import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'

import SpotBit from "../../02.focus.unit/fce/spot.bit";

import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActDsk from "../../act/disk.action";
import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const saveHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {


  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: bal.idx  });

  dat = bit.mapBit.dat;

  dat.idx = S(dat.idx).slugify().s

  if (bal.val == null) bal.val = 10

  val = String(bal.val).padStart(5, '0');

  bit = await ste.bus(ActDsk.ENSURE_DISK, { src: cpy.hexmapLoc })

  src = cpy.hexmapLoc + bal.idx + '.' + val + '.json';

  bit = await ste.bus(ActDsk.WRITE_DISK, { idx: null, src, dat, val: 1 })
  
  bal.slv({ mapBit: { idx: "save-hexmap", src, dat } });

  return cpy;
};


import { HexmapModel } from "../hexmap.model";
import HexmapBit from "../fce/hexmap.bit";
import State from "../../99.core/state";
import * as SHAPE from "../../val/shape";
import * as Honeycomb from "honeycomb-grid";

import * as HEXMAP from "../../val/hexmap";
import * as S from 'string'
import MapBit from "../fce/map.bit";
import * as SPACE from '../../val/space'

import SpotBit from "../../02.focus.unit/fce/spot.bit";

import * as ActMap from "../hexmap.action";

import * as ActFoc from "../../02.focus.unit/focus.action";

import * as ActSpc from "../../00.space.unit/space.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActDsk from "../../act/disk.action";
import * as ActVrt from "../../act/vurt.action";

var bit, idx, lst, dat, val, src;

export const shapeHexmap = async (cpy: HexmapModel, bal: HexmapBit, ste: State) => {

  var dat: MapBit = bal.dat
  if (dat == null) return bal.slv({ mapBit: { idx: "shape-hexmap-error" } });

  if (dat.frm == null) dat.frm = SHAPE.RECTANGLE;

  if (dat.w == null) dat.w = 3;
  if (dat.h == null) dat.h = 3;
  
  const Hex: Honeycomb.HexFactory = Honeycomb.extendHex({
    size: Number(1), // default: 1
    orientation: 'flat', // default: 'pointy'
  });

  const Grid: Honeycomb.GridFactory<any> = Honeycomb.defineGrid(Hex);
  var grid;

  switch (dat.frm) {
    case SHAPE.RECTANGLE:
      
    grid = Grid.rectangle({ width: dat.w, height: dat.h });
    
    break;

    case SHAPE.TRIANGLE:
      grid = Grid.triangle({ size: dat.w });
      break;

    case SHAPE.HEXAGON:
      grid = Grid.hexagon({ radius: dat.w, center: [dat.w, dat.w] });
      break;

    case SHAPE.PARALLELOGRAM:
      grid = Grid.parallelogram({ width: dat.w, height: dat.h });
      break;
  }


  var Chance = require('chance');
  var chance = new Chance();


  grid.forEach((a) => {
    a.hex = chance.bb_pin()
  })

  
  dat.bit = grid
  
  //bit = await ste.hunt(ActMap.REPLACE_HEXMAP, { dat: grid })

  var shape = { frm: dat.frm, bit: dat.bit, w: dat.w, h: dat.h }
  
  //bit = await ste.hunt(ActMap.WRITE_HEXMAP, { idx: bal.idx, dat: shape })
  

  if (bal.slv != null) bal.slv({ mapBit: { idx: "shape-hexmap", dat: {idx:bal.idx, bit:shape}  } });

  return cpy;
};


export default interface HexmapBit {
  idx: string;
  src: string;
  frm: string;
  val: number;
  slv?: any;
  dex?: number;
  sze?: number;
  typ: string;
  size?: number;
  orient?: string;
  h?: number;
  w?: number;
  dat?: any;
  lst?: any;
}


import  HexmapBit  from "./hexmap.bit";

export default interface Hexmap {
 // idx:string;
 // hexmapBitList: HexmapBit[];
 // hexmapBits:any;

}

import * as Honeycomb from "honeycomb-grid";

export default interface HoneycombCollection {
  hexFactoryList: Honeycomb.HexFactory[];
  hexFactories: any;

  gridFactoryList: Honeycomb.GridFactory<any>[];
  gridFactories: any;

  gridList: any[];
  grids: any;

  hexList: Honeycomb.Hex<any>[];
  hexs: any;
}

export default interface MapBit {
  idx: string;
  src?:string;
  typ?: string;
  frm?:string;
  dex?: number;
  sze?: number;
  size?: number;
  orient?: string;
  h?: number;
  w?: number;
  dat?:any
  bit?:any;
  grid?:any;
  ver?:any;
  val:number
}

export default interface VergeBit {
  idx: string;
  src?:string;
  slv?: any;
  dex?: number;
  sze?: number;
  typ: string;
  size?: number;
  orient?: string;
  h?: number;
  w?: number;
}

import { Action } from "../99.core/interface/action.interface";
import HexmapBit from "./fce/hexmap.bit";

// Hexmap actions

export const INIT_HEXMAP = "[Hexmap action] Init Hexmap";
export class InitHexmap implements Action {
  readonly type = INIT_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const UPDATE_HEXMAP = "[Hexmap action] Update Hexmap";
export class UpdateHexmap implements Action {
  readonly type = UPDATE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const OPEN_HEXMAP = "[Hexmap action] Open Hexmap";
export class OpenHexmap implements Action {
  readonly type = OPEN_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const READ_HEXMAP = "[Read action] Read Hexmap";
export class ReadHexmap implements Action {
  readonly type = READ_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const WRITE_HEXMAP = "[Write action] Write Hexmap";
export class WriteHexmap implements Action {
  readonly type = WRITE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const CREATE_HEXMAP = "[Create action] Create Hexmap";
export class CreateHexmap implements Action {
  readonly type = CREATE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const COPY_HEXMAP = "[Copy action] Copy Hexmap";
export class CopyHexmap implements Action {
  readonly type = COPY_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const ATLAS_HEXMAP = "[Atlas action] Atlas Hexmap";
export class AtlasHexmap implements Action {
  readonly type = ATLAS_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const GEOJSON_HEXMAP = "[Geojson action] Geojson Hexmap";
export class GeojsonHexmap implements Action {
  readonly type = GEOJSON_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const TOOL_HEXMAP = "[Tool action] Tool Hexmap";
export class ToolHexmap implements Action {
  readonly type = TOOL_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const SAVE_HEXMAP = "[Save action] Save Hexmap";
export class SaveHexmap implements Action {
  readonly type = SAVE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const STORE_HEXMAP = "[Store action] Store Hexmap";
export class StoreHexmap implements Action {
  readonly type = STORE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const SHAPE_HEXMAP = "[Shape action] Shape Hexmap";
export class ShapeHexmap implements Action {
  readonly type = SHAPE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const LOAD_HEXMAP = "[Load action] Load Hexmap";
export class LoadHexmap implements Action {
  readonly type = LOAD_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const LIST_HEXMAP = "[List action] List Hexmap";
export class ListHexmap implements Action {
  readonly type = LIST_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const REPLACE_HEXMAP = "[Replace action] Replace Hexmap";
export class ReplaceHexmap implements Action {
  readonly type = REPLACE_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const NAME_HEXMAP = "[Name action] Name Hexmap";
export class NameHexmap implements Action {
  readonly type = NAME_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const SEEK_HEXMAP = "[Seek action] Seek Hexmap";
export class SeekHexmap implements Action {
  readonly type = SEEK_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const FOCUSING_HEXMAP = "[Focusing action] Focusing Hexmap";
export class FocusingHexmap implements Action {
  readonly type = FOCUSING_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const DEFOCUS_HEXMAP = "[Defocus action] Defocus Hexmap";
export class DefocusHexmap implements Action {
  readonly type = DEFOCUS_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const SELECT_HEXMAP = "[Select action] Select Hexmap";
export class SelectHexmap implements Action {
  readonly type = SELECT_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const ADD_HEXMAP = "[Select action] Add Hexmap";
export class AddHexmap implements Action {
  readonly type = ADD_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export const POUCH_HEXMAP = "[Select action] Pouch Hexmap";
export class PouchHexmap implements Action {
  readonly type = POUCH_HEXMAP;
  constructor(public bale: HexmapBit) { }
}

export type Actions = OpenHexmap | InitHexmap | UpdateHexmap
  | ReadHexmap
  | WriteHexmap
  | CreateHexmap
  | CopyHexmap
  | AtlasHexmap
  | GeojsonHexmap
  | ToolHexmap
  | SaveHexmap
  |StoreHexmap
  | ShapeHexmap
  | ShapeHexmap
  | LoadHexmap
  | ListHexmap
  | ReplaceHexmap
  | NameHexmap
  | SeekHexmap
  | FocusingHexmap
  | DefocusHexmap
  | SelectHexmap
  | AddHexmap
  | PouchHexmap
export { initHexmap } from "./buz/00.hexmap.buzz";
export { updateHexmap } from "./buz/00.hexmap.buzz";
export { openHexmap } from "./buz/00.hexmap.buzz";
export { readHexmap  } from "./buz/00.hexmap.buzz";
export { writeHexmap  } from "./buz/00.hexmap.buzz";
export { createHexmap  } from "./buz/create-hexmap";
export { copyHexmap  } from "./buz/00.hexmap.buzz";
export { atlasHexmap  } from "./buz/atlas-hexmap.buzz";
export { geojsonHexmap  } from "./buz/00.hexmap.buzz";
export { toolHexmap  } from "./buz/00.hexmap.buzz";
export { saveHexmap  } from "./buz/save-hexmap";
export { storeHexmap  } from "./buz/00.hexmap.buzz";
export { shapeHexmap  } from "./buz/shape-hexmap";
export { loadHexmap  } from "./buz/load-hexmap";
export { listHexmap  } from "./buz/00.hexmap.buzz";
export { replaceHexmap  } from "./buz/00.hexmap.buzz";
export { nameHexmap  } from "./buz/00.hexmap.buzz";
export { seekHexmap  } from "./buz/00.hexmap.buzz";
export { focusingHexmap  } from "./buz/00.hexmap.buzz";
export { defocusHexmap  } from "./buz/00.hexmap.buzz";
export { selectHexmap  } from "./buz/00.hexmap.buzz";
export { addHexmap } from "./buz/00.hexmap.buzz";
export { pouchHexmap } from "./buz/pouch-hexmap";
import Hexmap from "./fce/hexmap.interface";
import HexmapBit from "./fce/hexmap.bit";
import HoneycombCollection from "./fce/honeycomb-collection.bit";
import SpotBit from "../02.focus.unit/fce/spot.bit";
import MapBit from "./fce/map.bit";

export class HexmapModel implements Hexmap {
  //idx:string;

  select:MapBit;

  geoJsonNow:any;
  atlasNow:any;
  sizeNow:any = 0;
  mapNomNow:string= 'none'
  
  platBits: any = {};

  hexmapLoc:string = './data/mapbit/';

  //legacy  
  hexmapBitList: HexmapBit[] = [];
  hexmapBits: any = {};


  hc: HoneycombCollection = {
    hexFactoryList: [],
    hexFactories: {},

    gridFactoryList: [],
    gridFactories: {},

    gridList: [],
    grids: {},

    hexList: [],
    hexs: {},
  };

  dex: number = 0;
  count: number = 0;
}

import * as clone from "clone-deep";
import * as Act from "./hexmap.action";
import { HexmapModel } from "./hexmap.model";
import * as Buzz from "./hexmap.buzzer";
import State from "../99.core/state";

export function reducer(model: HexmapModel = new HexmapModel(), act: Act.Actions, state?: State) {
  switch (act.type) {
    case Act.OPEN_HEXMAP:
      return Buzz.openHexmap(clone(model), act.bale, state);

    case Act.UPDATE_HEXMAP:
      return Buzz.updateHexmap(clone(model), act.bale, state);

    case Act.INIT_HEXMAP:
      return Buzz.initHexmap(clone(model), act.bale, state);

    case Act.READ_HEXMAP:
      return Buzz.readHexmap(clone(model), act.bale, state);

    case Act.WRITE_HEXMAP:
      return Buzz.writeHexmap(clone(model), act.bale, state);

    case Act.CREATE_HEXMAP:
      return Buzz.createHexmap(clone(model), act.bale, state);

    case Act.COPY_HEXMAP:
      return Buzz.copyHexmap(clone(model), act.bale, state);

    case Act.ATLAS_HEXMAP:
      return Buzz.atlasHexmap(clone(model), act.bale, state);

    case Act.GEOJSON_HEXMAP:
      return Buzz.geojsonHexmap(clone(model), act.bale, state);

    case Act.TOOL_HEXMAP:
      return Buzz.toolHexmap(clone(model), act.bale, state);

    case Act.SAVE_HEXMAP:
      return Buzz.saveHexmap(clone(model), act.bale, state);

    case Act.STORE_HEXMAP:
      return Buzz.storeHexmap(clone(model), act.bale, state);

    case Act.SHAPE_HEXMAP:
      return Buzz.shapeHexmap(clone(model), act.bale, state);

    case Act.LOAD_HEXMAP:
      return Buzz.loadHexmap(clone(model), act.bale, state);

    case Act.LIST_HEXMAP:
      return Buzz.listHexmap(clone(model), act.bale, state);

    case Act.REPLACE_HEXMAP:
      return Buzz.replaceHexmap(clone(model), act.bale, state);

    case Act.NAME_HEXMAP:
      return Buzz.nameHexmap(clone(model), act.bale, state);

    case Act.SEEK_HEXMAP:
      return Buzz.seekHexmap(clone(model), act.bale, state);

    case Act.FOCUSING_HEXMAP:
      return Buzz.focusingHexmap(clone(model), act.bale, state);

    case Act.DEFOCUS_HEXMAP:
      return Buzz.defocusHexmap(clone(model), act.bale, state);

    case Act.SELECT_HEXMAP:
      return Buzz.selectHexmap(clone(model), act.bale, state);

    case Act.ADD_HEXMAP:
      return Buzz.addHexmap(clone(model), act.bale, state);

    case Act.POUCH_HEXMAP:
      return Buzz.pouchHexmap(clone(model), act.bale, state);

    default:
      return model;
  }
}

import State from "../99.core/state";


export default class HexmapUnit {

 constructor(state: State) {
 }
}

import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"
import * as FOCUS from "../../val/focus"

import MapBit from "../../01.hexmap.unit/fce/map.bit"; 


import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat, src

export const initFocus = (cpy: FocusModel, bal: FocusBit, ste: State) => {

  var lst = [ActFoc.OPEN_FOCUS];
  bal.slv({ intBit: { idx: "init-focus", lst } });

  return cpy;
};

export const readFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {


  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "foc00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, src: bal.src, bit: ActFoc.CREATE_FOCUS });


  if (slv != null) slv({ focBit: { idx: "read-focus", dat: bit.clcBit.dat } });

  return cpy;
};

export const writeFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  //debugger

  if (bal.idx == null) bal.idx = "foc00";
  //if (bal.val != 1) ste.hunt(ActFoc.UPDATE_FOCUS, { idx: bal.idx })

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFoc.CREATE_FOCUS });
  var spot: SpotBit = bit.clcBit.dat

  //debugger
  
  if (bal.slv != null) bal.slv({ focBit: { idx: "write-focus", dat: spot } });

  return cpy;
};

export const removeFocus = (cpy: FocusModel, bal: FocusBit, ste: State) => {
  debugger
  return cpy;
};



export const deleteFocus = (cpy: FocusModel, bal: FocusBit, ste: State) => {
  debugger
  return cpy;
};



export const listFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {
  
  dat = null
  bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActFoc.CREATE_FOCUS })
  if (bit.clcBit.dat == null) lst = []
  else dat = bit.clcBit.dat;

  if (dat != null) {
    lst = []
    dat.bitList.forEach((a) => {
      lst.push((a.idx))
    })
  }

  bal.slv({ focBit: { idx: "list-focus", lst } });

  return cpy;
};



export const centerFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {


  if (bal.slv != null) bal.slv({ focBit: { idx: "center-focus", dat } });
}




export const locateFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var spot: SpotBit = bit.focBit.dat;

  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: spot.map })
  var map: MapBit = bit.mapBit.dat;
  var grid = map.dat;

  var hex = grid.get({ x: spot.x, y: spot.y });

  var idx = spot.map + "-" + spot.x + "-" + spot.y;
  spot.loc = hex;

  if (bal.slv != null) bal.slv({ focBit: { idx: "locate-focus", dat: spot } });

  return cpy;
};



export const selectFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {


  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })

  var spot: SpotBit = bit.focBit.dat;

  cpy.select = spot;

  //bit = await ste.hunt( ActFoc.VISION_FOCUS, { idx: bal.idx })
  if (bal.slv != null) bal.slv({ focBit: { idx: "select-focus", dat: cpy.select } });

  return cpy;
};



export const openFocus = (cpy: FocusModel, bal: FocusBit, ste: State) => {



  if (bal.slv != null) bal.slv({ focBit: { idx: "open-focus", dat: {} } });

  return cpy;
};


//grab all the model data 
export const modelFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  if (bal.src == null) bal.src = 'GET'

  switch (bal.src) {

    case 'GET':

      bit = await ste.hunt(ActCol.GET_COLLECT, { idx: 'focus' })
      dat = bit.clcBit.dat;
      break

    case 'PUT':

      break

  }


  if (bal.slv != null) bal.slv({ focBit: { idx: "model-focus", dat } });

  return cpy;
};






import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"



import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const awakeFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  if ( bal.val == 1 ){

    
  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val:1, dat: { awake:true } })

  bit = await ste.hunt(ActFoc.UPDATE_FOCUS, { idx: bal.idx })
  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val:1 })

  }

  else{


    
  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val:1, dat: { awake:false, viewList:[] } })

  bit = await ste.hunt(ActFoc.UPDATE_FOCUS, { idx: bal.idx })
  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val:1 })





  }

 

  if (bal.slv != null) bal.slv({ focBit: { idx: "awake-focus", dat } });
}



import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"

import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const backwardFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var spot: SpotBit = bit.focBit.dat;

  var x = spot.x;
  var y = spot.y;
  var face = spot.face
  var bonds, bond;

  //bit = await ste.hunt(ActFoc.CENTER_FOCUS, {idx:spot.idx, dat: spot } )

  if (face == DIRECTION.WEST) {

    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.EAST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null ) bond = bonds[DIRECTION.EAST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }

  }

  if (face == DIRECTION.EAST) {

    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.WEST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null )  bond = bonds[DIRECTION.WEST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }

  }

  if (face == DIRECTION.NORTH_WEST) {

    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.SOUTH_EAST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null )  bond = bonds[DIRECTION.SOUTH_EAST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }


  }

  if (face == DIRECTION.NORTH_EAST) {

    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.SOUTH_WEST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null )  bond = bonds[DIRECTION.SOUTH_WEST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }

  }

  if (face == DIRECTION.SOUTH_WEST) {


    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.NORTH_EAST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null )  bond = bonds[DIRECTION.NORTH_EAST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }

  }

  if (face == DIRECTION.SOUTH_EAST) {

    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: spot.idx, src: DIRECTION.NORTH_WEST, dat: spot })
    bonds = bit.focBit.dat
    if ( bonds != null )  bond = bonds[DIRECTION.NORTH_WEST];
    if (bond != null) {
      x = bond.x;
      y = bond.y;
    }


  }

  //patch(ste, ActFoc.LIST_VISON_FOCUS, foci);
  //locateHex(ste, foci);

  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, dat: { x, y, bonds, face } })

  if (bal.slv != null) bal.slv({ focBit: { idx: "backward-focus", dat: spot } });
}




import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"
import MapBit from "../../01.hexmap.unit/fce/map.bit";

import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const bondFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  //bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var spot: SpotBit = bal.dat;

  
  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: spot.src })
  var map: MapBit = bit.mapBit.dat;

  var grid = map.grid;
  

  if (grid == null) throw new Error("no map present for " + bal.src);

  var hex = grid.get({ x: spot.x, y: spot.y });
  var bonds = {};
  var item;

  var face = bal.src

  if ( face == null ) face = spot.face

  item = grid.neighborsOf(hex, compassConvertor(face));

  if ( item[0] == null ){
    bonds = null
  }
  else{

    if (item[0] != null) bonds[face] = { x: item[0].x, y: item[0].y };
  
  }

  bonds
  

  if (bal.slv != null) bal.slv({ focBit: { idx: "bond-focus", dat: bonds, bit:spot } });

  return cpy;
};


const compassConvertor = (val: string) => {
  var result = 0;
  switch (val) {
    case DIRECTION.NORTH_EAST:
      result = 5;
      break;

    case DIRECTION.EAST:
      result = 0;
      break;

    case DIRECTION.SOUTH_EAST:
      result = 1;
      break;

    case DIRECTION.SOUTH_WEST:
      result = 2;
      break;

    case DIRECTION.WEST:
      result = 3;
      break;

    case DIRECTION.NORTH_WEST:
      result = 4;
      break;
  }

  return result;
};


import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"

import MapBit from "../../01.hexmap.unit/fce/map.bit";

import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const brownianFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  
  var spot: SpotBit;

  var now = Math.floor(Math.random() * 11);
  

  switch (now) {

    case 0:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break

    case 1:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 2:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 3:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 4:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 5:
      bit = await ste.hunt(ActFoc.FORWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;

      break


    case 6:
      bit = await ste.hunt(ActFoc.SPIN_LEFT_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 7:
      bit = await ste.hunt(ActFoc.SPIN_RIGHT_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 8:
      bit = await ste.hunt(ActFoc.SPIN_LEFT_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 9:
      bit = await ste.hunt(ActFoc.BACKWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break


    case 10:
      bit = await ste.hunt(ActFoc.BACKWARD_FOCUS, { idx: bal.idx })
      spot = bit.focBit.bit;
      break



  }

  if (bal.slv != null) bal.slv({ focBit: { idx: "vision-focus", bit: spot } });

  return cpy;
};



import * as ActFoc from "../focus.action";

import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as FOCUS from "../../val/focus"
import * as DIRECTION from "../../val/direction"
import MapBit from "../../01.hexmap.unit/fce/map.bit"; 

import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const cornerFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  var spot: SpotBit = bal.dat;

  var grid;
  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: spot.src })

  grid = bit.mapBit.dat.grid;
    
  if ( grid == null ) bal.slv({ focBit: { idx: "corner-focus-error", lst, dat: spot } });
  if ( grid == null ) return

  
  var hex = grid.get({ x: spot.x, y: spot.y });

  const point = hex.toPoint();
  lst = hex.corners().map((corner) => corner.add(point));

  spot.corners = lst

  if (bal.slv != null) bal.slv({ focBit: { idx: "corner-focus", lst, bit: spot } });

  return cpy;
}



import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as FOCUS from "../../val/focus"
import * as DIRECTION from "../../val/direction"
import MapBit from "../../01.hexmap.unit/fce/map.bit"; 

import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const createFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  if ( bal.src === undefined ){ return  bal.slv({ focBit: { idx: "create-focus-error", dat:{ src:'no map present' }  } }); }

  var dat: SpotBit = { idx: bal.idx, src: bal.src, typ: FOCUS.AMBT };

  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  if (dat.gph == null) dat.gph = 'None'

  dat.gph

  if (dat.frm == null) dat.frm = SHAPE.RECTANGLE

  if (dat.x == null) dat.x = 0;
  if (dat.y == null) dat.y = 0;
  if (dat.h == null) dat.h = 1;
  if (dat.w == null) dat.w = 1;

  if (dat.awake == null) dat.awake = false;

  if (dat.face == null) dat.face = 'E'
  if (dat.past == null) dat.past = []
  if (dat.update == null) dat.update = 0;
  if (dat.clock == null) dat.clock = 0;
  if (dat.updateSpeed == null) dat.updateSpeed = 11;
  if (dat.turnSpeed == null) dat.turnSpeed = 11;
  if (dat.spin == null) dat.spin = true

  bit = await ste.hunt(ActFoc.CORNER_FOCUS, { idx: dat.src, dat })
  dat.corners = bit.focBit.lst;

  bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: bal.idx, src: dat.face, dat })

  var bonds = bit.focBit.dat
  dat.bonds = bonds

  bal.slv({ focBit: { idx: "create-focus", dat } });
  return cpy;
}




import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"
import MapBit from "../../01.hexmap.unit/fce/map.bit";

var bit, val, idx, dex, lst, dat;

export const forwardFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var spot: SpotBit = bit.focBit.dat;


  //bit = await ste.hunt(ActFoc.CENTER_FOCUS, {idx:spot.idx, dat: spot } )

  var x = spot.x;
  var y = spot.y;

  var face = spot.face
  var bonds = spot.bonds;



  if (bonds == null) {

    //nothing happens
    bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: bal.idx, src: face, dat: spot })
    var bonds = bit.focBit.dat
    spot.bonds = bonds


  } else {

    const now = bonds[face]

    if (now != null) {
      x = now.x;
      y = now.y;
    }

  }

  spot.x = x
  spot.y = y

  bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: bal.idx, src: face, dat: spot })
  var bonds = bit.focBit.dat
  spot.bonds = bonds

  bit = await ste.hunt(ActFoc.CORNER_FOCUS, { dat: spot })
  spot.corners = bit.focBit.lst;


  spot

  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: spot.idx, src: spot.src, dat: { x, y, bonds, face } })

  if (bal.slv != null) bal.slv({ focBit: { idx: "forward-focus", bit: spot } });
}





import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const spinLeftFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var dat: SpotBit = bit.focBit.dat;

  var face;

  switch (dat.face) {
    case DIRECTION.NORTH_EAST:
      face = DIRECTION.EAST;
      break;
    case DIRECTION.NORTH_WEST:
      face = DIRECTION.NORTH_EAST;
      break;
    case DIRECTION.WEST:
      face = DIRECTION.NORTH_WEST;
      break;
    case DIRECTION.SOUTH_WEST:
      face = DIRECTION.WEST;
      break;
    case DIRECTION.SOUTH_EAST:
      face = DIRECTION.SOUTH_WEST;
      break;
    case DIRECTION.EAST:
      face = DIRECTION.SOUTH_EAST;
      break;
  }

  dat.move = "";
  dat.face = face;

  bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: dat.idx, src:dat.face, dat })
  var bonds = bit.focBit.dat
  dat.bonds = bonds
  

  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: dat.idx, dat })

  if (bal.slv != null) bal.slv({ focBit: { idx: "spin-left-focus", bit:dat } });

  return cpy;
};


import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"


import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const spinRightFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var dat: SpotBit = bit.focBit.dat;

  var face;

  switch (dat.face) {
    case DIRECTION.NORTH_EAST:
      face = DIRECTION.NORTH_WEST;
      break;
    case DIRECTION.NORTH_WEST:
      face = DIRECTION.WEST;
      break;
    case DIRECTION.WEST:
      face = DIRECTION.SOUTH_WEST;
      break;
    case DIRECTION.SOUTH_WEST:
      face = DIRECTION.SOUTH_EAST;
      break;
    case DIRECTION.SOUTH_EAST:
      face = DIRECTION.EAST;
      break;
    case DIRECTION.EAST:
      face = DIRECTION.NORTH_EAST;
      break;
  }

  dat.move = "";
  dat.face = face;

  bit = await ste.hunt(ActFoc.BOND_FOCUS, { idx: dat.idx, src: dat.face, dat })
  var bonds = bit.focBit.dat
  dat.bonds = bonds


  bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: dat.idx, dat })

  if (bal.slv != null) bal.slv({ focBit: { idx: "spin-right-focus", dat: { bit: dat } } });

  return cpy;
};


import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"


import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"

import MapBit from "../../01.hexmap.unit/fce/map.bit";

import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

var flag = false;

export const updateFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  if (flag == false) {
    flag = true;
    if (bal.slv != null) bal.slv({ focBit: { idx: "update-focus" } });
    return
  }

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })

  var spot: SpotBit = bit.focBit.dat;

  var viewList = []

  if (spot.awake == true) {

    bit = await ste.hunt(ActFoc.VISION_FOCUS, { idx: bal.idx })
    viewList = bit.focBit.lst;

   // bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val: 1, dat: { viewList } })


  }
  else {



   // bit = await ste.hunt(ActFoc.WRITE_FOCUS, { idx: bal.idx, val: 1, dat: { viewList } })

  }


  if (bal.slv != null) bal.slv({ focBit: { idx: "update-focus" } });

  return cpy;
};



import { FocusModel } from "../focus.model";
import FocusBit from "../fce/focus.bit";
import State from "../../99.core/state";
import SpotBit from "../fce/spot.bit";
import * as Honeycomb from "honeycomb-grid";
import * as SHAPE from '../../val/shape'
import * as SPACE from "../../val/space"
import * as DIRECTION from "../../val/direction"

import MapBit from "../../01.hexmap.unit/fce/map.bit"; 


import * as ActFoc from "../focus.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var bit, val, idx, dex, lst, dat;

export const visionFocus = async (cpy: FocusModel, bal: FocusBit, ste: State) => {

  bit = await ste.hunt(ActFoc.READ_FOCUS, { idx: bal.idx })
  var spot: SpotBit = bit.focBit.dat;
  
  bit = await ste.hunt(ActMap.READ_HEXMAP, { idx: spot.src })
  var map: MapBit = bit.mapBit.dat;
  
  var grid = map.grid;

  var size = 3;

  var check = [{ face: spot.face, x: spot.x, y: spot.y }];

  switch (spot.face) {
    case DIRECTION.EAST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      break;

    case DIRECTION.WEST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      break;

    case DIRECTION.NORTH_EAST:
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      break;

    case DIRECTION.NORTH_WEST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      break;

    case DIRECTION.SOUTH_EAST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      break;

    case DIRECTION.SOUTH_WEST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x, y: spot.y - 1 });
      break;

    case DIRECTION.SOUTH_EAST:
      check.push({ face: spot.face, x: spot.x, y: spot.y + 1 });
      check.push({ face: spot.face, x: spot.x + 1, y: spot.y - 1 });
      break;
  }

  var output = [];

  check.forEach((a, b) => {
    var last = grid.get({ x: a.x, y: a.y });
    
    for (var i = 0; i < size; i++) {
      if (last != null) {
        var item = grid.neighborsOf(last, compassConvertor(a.face));
        
        if (item[0] != null) {
          var data = { idx: "listing-vison-focus", src: spot.src, x: item[0].x, y: item[0].y, corners: [], h: null };
          last = grid.get({ x: data.x, y: data.y });
          //grabCorners(cpy, data, ste);
          output.push(last.hex);
          
        }
      }
    }
  });


  output
  
  if (bal.slv != null) bal.slv({ focBit: { idx: "vision-focus", lst:output } });

  //var item = grid.neighborsOf(hex, compassConvertor(RCT.EAST));
  //if (item[0] != null) output.push({ x: item[0].x, y: item[0].y });

  //foci.viewList = output;
  //commented out on 3.30

  //cpy.readFocus = foci;
  //commented out on 3.30



  return cpy;
};

const compassConvertor = (val: string) => {
  var result = 0;
  switch (val) {
    case DIRECTION.NORTH_EAST:
      result = 5;
      break;

    case DIRECTION.EAST:
      result = 0;
      break;

    case DIRECTION.SOUTH_EAST:
      result = 1;
      break;

    case DIRECTION.SOUTH_WEST:
      result = 2;
      break;

    case DIRECTION.WEST:
      result = 3;
      break;

    case DIRECTION.NORTH_WEST:
      result = 4;
      break;
  }

  return result;
};






export default interface BondBit {
  x: number;
  y: number;
  d?: string;
}

export default interface FocusBit {
  idx: string;
  src?: string;
  slv?: Function;
  dat?:any;
  bit?:any;
  val:Number
}


import  FocusBit  from "./focus.bit";

export default interface Focus {
 // idx:string;
 // focusBitList: FocusBit[];
 // focusBits:any;

}

import BondBit from "./bond.bit.interface";

export default interface SpotBit {
  idx: string;
  src?: string;
  typ?: string;
  frm?: string;
  map?: string;
  gph?:string; //this is so the display has an id on which to paint upon
  slv?: Function;
  sze?: number;
  ort?: string;
  x?: number;
  y?: number;
  w?: number;
  h?: number;

  awake?:boolean;

  loc?: any;

  face?: string;
  past?: any[];
  creation?: number;
  bit?: any;
  grid?: any;
  update?: number;
  clock?: number;
  updateSpeed?: number;
  turnSpeed?: number;
  camX?: number;
  camY?: number;
  spin?: boolean
  move?:string;
  corners?:any;
  area?: any;
  vision?: any;

  viewList?: BondBit[];

  bonds?: any;
  bondList?: BondBit[];
  pastList?: string[];
}

import { Action } from "../99.core/interface/action.interface";
import FocusBit from "./fce/focus.bit";

// Focus actions
export const INIT_FOCUS = "[Focus action] Init Focus";
export class InitFocus implements Action {
  readonly type = INIT_FOCUS;
  constructor(public bale: FocusBit) {}
}

export const AWAKE_FOCUS = "[Focus action] Awake Focus";
export class AwakeFocus implements Action {
  readonly type = AWAKE_FOCUS;
  constructor(public bale: FocusBit) {}
}

export const UPDATE_FOCUS = "[Focus action] Update Focus";
export class UpdateFocus implements Action {
  readonly type = UPDATE_FOCUS;
  constructor(public bale: FocusBit) {}
}

export const OPEN_FOCUS = "[Focus action] Open Focus";
export class OpenFocus implements Action {
  readonly type = OPEN_FOCUS;
  constructor(public bale: FocusBit) {}
}

export const CREATE_FOCUS = "[Focus action] Create Focus";
export class CreateFocus implements Action {
  readonly type = CREATE_FOCUS;
  constructor(public bale: FocusBit) {}
}

export const READ_FOCUS = "[Read action] Read Focus";
 export class ReadFocus implements Action {
 readonly type = READ_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const WRITE_FOCUS = "[Write action] Write Focus";
 export class WriteFocus implements Action {
 readonly type = WRITE_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const REMOVE_FOCUS = "[Remove action] Remove Focus";
 export class RemoveFocus implements Action {
 readonly type = REMOVE_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const DELETE_FOCUS = "[Delete action] Delete Focus";
 export class DeleteFocus implements Action {
 readonly type = DELETE_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const CORNER_FOCUS = "[Corner action] Corner Focus";
 export class CornerFocus implements Action {
 readonly type = CORNER_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const LIST_FOCUS = "[List action] List Focus";
 export class ListFocus implements Action {
 readonly type = LIST_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const SPIN_RIGHT_FOCUS = "[List action] Spin Left Focus";
 export class SpinRightFocus implements Action {
 readonly type = SPIN_RIGHT_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const SPIN_LEFT_FOCUS = "[List action] Spin Right Focus";
 export class SpinLeftFocus implements Action {
 readonly type = SPIN_LEFT_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const FORWARD_FOCUS = "[List action] Forward Focus";
 export class ForwardFocus implements Action {
 readonly type = FORWARD_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const BACKWARD_FOCUS = "[List action] Backward Focus";
 export class BackwardFocus implements Action {
 readonly type = BACKWARD_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const CENTER_FOCUS = "[List action] Center Focus";
 export class CenterFocus implements Action {
 readonly type = CENTER_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const BOND_FOCUS = "[Bond action] Bond Focus";
 export class BondFocus implements Action {
 readonly type = BOND_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const LOCATE_FOCUS = "[Locate action] Locate Focus";
 export class LocateFocus implements Action {
 readonly type = LOCATE_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const VISION_FOCUS = "[Vision action] Vision Focus";
 export class VisionFocus implements Action {
 readonly type = VISION_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export const SELECT_FOCUS = "[Select action] Select Focus";
 export class SelectFocus implements Action {
 readonly type = SELECT_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const MODEL_FOCUS = "[Select action] Model Focus";
 export class ModelFocus implements Action {
 readonly type = MODEL_FOCUS;
 constructor(public bale: FocusBit) {}
 }

 export const BROWNIAN_FOCUS = "[Select action] Brownian Focus";
 export class BrownianFocus implements Action {
 readonly type = BROWNIAN_FOCUS;
 constructor(public bale: FocusBit) {}
 }
 
export type Actions = OpenFocus | InitFocus | UpdateFocus |CreateFocus
| ReadFocus
| WriteFocus
| RemoveFocus
| DeleteFocus
| CornerFocus
| ListFocus
| SpinLeftFocus
| SpinRightFocus
| BackwardFocus
| ForwardFocus
| CenterFocus
| BondFocus
| LocateFocus
| VisionFocus
| SelectFocus
| AwakeFocus
| ModelFocus
| BrownianFocus
export { initFocus } from "./buz/00.focus.buzz";
export { awakeFocus } from "./buz/awake-focus.buzz";
export { updateFocus } from "./buz/update-focus.buzz";
export { openFocus } from "./buz/00.focus.buzz";
export { createFocus } from "./buz/create-focus.buzz";
export { readFocus } from "./buz/00.focus.buzz";
export { writeFocus } from "./buz/00.focus.buzz";
export { removeFocus } from "./buz/00.focus.buzz";
export { deleteFocus } from "./buz/00.focus.buzz";
export { cornerFocus } from "./buz/corner-focus.buzz";
export { listFocus } from "./buz/00.focus.buzz";
export { spinLeftFocus } from "./buz/spin-left-focus.buzz";
export { spinRightFocus } from "./buz/spin-right-focus.buzz";
export { forwardFocus } from "./buz/forward-focus.buzz";
export { backwardFocus } from "./buz/backward-focus.buzz";
export { centerFocus } from "./buz/00.focus.buzz";
export { bondFocus } from "./buz/bond-focus.buzz";
export { locateFocus } from "./buz/00.focus.buzz";
export { visionFocus } from "./buz/vision-focus.buzz";
export { selectFocus } from "./buz/00.focus.buzz";
export { modelFocus } from "./buz/00.focus.buzz";
export { brownianFocus } from "./buz/brownian-focus.buzz";
import Focus from "./fce/focus.interface";
import FocusBit from "./fce/focus.bit";
import SpotBit from "./fce/spot.bit";

export class FocusModel implements Focus {
  //idx:string;
  focusBitList: FocusBit[] = [];
  focusBits: any = {};
  
  select: SpotBit
}

import * as clone from "clone-deep";
import * as Act from "./focus.action";
import { FocusModel } from "./focus.model";
import * as Buzz from "./focus.buzzer";
import State from "../99.core/state";

export function reducer(model: FocusModel = new FocusModel(), act: Act.Actions, state?: State) {
  switch (act.type) {
    case Act.UPDATE_FOCUS:
      return Buzz.updateFocus(clone(model), act.bale, state);

    case Act.AWAKE_FOCUS:
      return Buzz.awakeFocus(clone(model), act.bale, state);

    case Act.OPEN_FOCUS:
      return Buzz.openFocus(clone(model), act.bale, state);

    case Act.CREATE_FOCUS:
      return Buzz.createFocus(clone(model), act.bale, state);

    case Act.INIT_FOCUS:
      return Buzz.initFocus(clone(model), act.bale, state);

    case Act.READ_FOCUS:
      return Buzz.readFocus(clone(model), act.bale, state);

    case Act.WRITE_FOCUS:
      return Buzz.writeFocus(clone(model), act.bale, state);

    case Act.REMOVE_FOCUS:
      return Buzz.removeFocus(clone(model), act.bale, state);

    case Act.DELETE_FOCUS:
      return Buzz.deleteFocus(clone(model), act.bale, state);

    case Act.CORNER_FOCUS:
      return Buzz.cornerFocus(clone(model), act.bale, state);

    case Act.LIST_FOCUS:
      return Buzz.listFocus(clone(model), act.bale, state);

    case Act.SPIN_LEFT_FOCUS:
      return Buzz.spinLeftFocus(clone(model), act.bale, state);

    case Act.SPIN_RIGHT_FOCUS:
      return Buzz.spinRightFocus(clone(model), act.bale, state);

    case Act.FORWARD_FOCUS:
      return Buzz.forwardFocus(clone(model), act.bale, state);

    case Act.BACKWARD_FOCUS:
      return Buzz.backwardFocus(clone(model), act.bale, state);

    case Act.CENTER_FOCUS:
      return Buzz.centerFocus(clone(model), act.bale, state);

    case Act.BOND_FOCUS:
      return Buzz.bondFocus(clone(model), act.bale, state);

    case Act.LOCATE_FOCUS:
      return Buzz.locateFocus(clone(model), act.bale, state);

    case Act.VISION_FOCUS:
      return Buzz.visionFocus(clone(model), act.bale, state);

    case Act.SELECT_FOCUS:
      return Buzz.selectFocus(clone(model), act.bale, state);

    case Act.MODEL_FOCUS:
      return Buzz.modelFocus(clone(model), act.bale, state);

      case Act.BROWNIAN_FOCUS:
      return Buzz.brownianFocus(clone(model), act.bale, state);

    default:
      return model;
  }
}

import State from "../99.core/state";


export default class FocusUnit {

 constructor(state: State) {
 }
}

import * as ActGeo from "../geojson.action";
import * as ActMap from "../../01.hexmap.unit/hexmap.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import * as ActCns from "../../act/console.action";
//import * as ActDsk from "../../96.disk.unit/disk.action";


import { GeojsonModel } from "../geojson.model";
import GeojsonBit from "../fce/geojson.bit";
import State from "../../99.core/state";


var bit, val, idx, dex, lst, dat, src;

export const initGeojson = (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {
    debugger
    return cpy;
};

export const updateGeojson = (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {
    return cpy;
};

export const loadGeojson = async (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {

    src = bal.src

    if (bal.val != null) {

        val = bal.val

        //here we will load 
       // bit = await ste.hunt(ActDsk.INDEX_DISK, { src: cpy.geoSrc + '/' })

        lst = bit.dskBit.lst

        var itm = lst[val]

        var want = cpy.geoSrc + '/' + itm;
        
        //bit = await ste.hunt(ActDsk.READ_DISK, { src: want  })
        dat = bit.dskBit.dat;
        src = itm.split('.')[0] + '.' + itm.split('.')[1]
        cpy.geojsonData = JSON.parse( dat)

        dat = cpy.geojsonData

        


        bal.slv({ geoBit: { idx: "load-geojson", dat, src } });

    } else {

       // bit = await ste.hunt(ActDsk.READ_DISK, { src: cpy.geoSrc + '/' + src, val: 1 })
        dat = bit.dskBit.dat;
        cpy.geojsonData = dat;
        src = bal.src.split('.')[0] + '.' + bal.src.split('.')[1]
        bal.slv({ geoBit: { idx: "load-geojson", dat, src } });

    }

    bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "loading.. "+ src })
    
    return cpy;
};


export const indexGeojson = async (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {

    dat = null

    //bit = await ste.bus(ActDsk.INDEX_DISK, { src: cpy.geoSrc })
    lst = bit.dskBit.lst

    if (bal.slv != null) bal.slv({ geoBit: { idx: "list-geojson", lst } });

    return cpy;
};


export const captureGeojson = async (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {

    //var open = require('open')
    //await open(bal.src);

    if (bal.slv != null) bal.slv({ geoBit: { idx: "capture-geojson", src: bal.src } });
    return cpy;
};


export const saveGeojson = async (cpy: GeojsonModel, bal: GeojsonBit, ste: State) => {


    //bit = await ste.bus(ActDsk.INDEX_DISK, { src: "./data/geojson/" })
    lst = bit.dskBit.lst;

    var dex = lst.length
    var out = String(dex).padStart(3, '0');

    var srcDir = "./data/geojson/" + out + '.' + bal.src + '.json';

    //var clipboardy = require("clipboardy");

    var geo;

    try {
       // geo = clipboardy.readSync();
    } catch (e) {
        console.log("hmmm " + e);
        if (bal.slv != null) bal.slv({ geoBit: { idx: "save-geojson-error" } });
        return;
    }

    if (geo.includes("coordinates") == false) {
        if (bal.slv != null) bal.slv({ geoBit: { idx: "save-geojson-error" } });
        return
    }

    if (geo.includes("type") == false) {
        if (bal.slv != null) bal.slv({ geoBit: { idx: "save-geojson-error" } });
        return
    }


    //bit = await ste.bus(ActDsk.WRITE_DISK, { idx: srcDir, dat: geo })


    if (bal.slv != null) bal.slv({ geoBit: { idx: "save-geojson", src: bal.src } });
    return cpy;

};





export default interface GeojsonBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
}


import  GeojsonBit  from "./geojson.bit";

export default interface Geojson {
 // idx:string;
 // geojsonBitList: GeojsonBit[];
 // geojsonBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import GeojsonBit from "./fce/geojson.bit";

export const INIT_GEOJSON = "[Geojson action] Init Geojson";
export class InitGeojson implements Action {
    readonly type = INIT_GEOJSON;
    constructor(public bale: GeojsonBit) { }
}

export const UPDATE_GEOJSON = "[Geojson action] Update Geojson";
export class UpdateGeojson implements Action {
    readonly type = UPDATE_GEOJSON;
    constructor(public bale: GeojsonBit) { }
}

export const LOAD_GEOJSON = "[Load action] Load Geojson";
export class LoadGeojson implements Action {
    readonly type = LOAD_GEOJSON;
    constructor(public bale: GeojsonBit) { }
}

export const INDEX_GEOJSON = "[Index action] Index Geojson";
export class IndexGeojson implements Action {
    readonly type = INDEX_GEOJSON;
    constructor(public bale: GeojsonBit) { }
}

export const CAPTURE_GEOJSON = "[Capture action] Capture Geojson";
 export class CaptureGeojson implements Action {
 readonly type = CAPTURE_GEOJSON;
 constructor(public bale: GeojsonBit) {}
 }
 
export const SAVE_GEOJSON = "[Save action] Save Geojson";
 export class SaveGeojson implements Action {
 readonly type = SAVE_GEOJSON;
 constructor(public bale: GeojsonBit) {}
 }
 
export type Actions = | InitGeojson | UpdateGeojson
    | LoadGeojson
    | IndexGeojson
| CaptureGeojson
| SaveGeojson
export { initGeojson  } from "./buz/geojson.buzz";
export { updateGeojson  } from "./buz/geojson.buzz";
export { loadGeojson  } from "./buz/geojson.buzz";
export { indexGeojson  } from "./buz/geojson.buzz";
export { captureGeojson  } from "./buz/geojson.buzz";
export { saveGeojson  } from "./buz/geojson.buzz";
import Geojson from "./fce/geojson.interface";
import GeojsonBit from "./fce/geojson.interface";

export class GeojsonModel implements Geojson {
 //idx:string;
 //geojsonBitList: GeojsonBit[] = [];
 //geojsonBits: any = {};
 geojsonData:any;
 geoSrc:string = './data/geojson'
 captureLocationList: any = ['https://geoman.io/geojson-editor', 'https://www.keene.edu/campus/maps/tool/' ]
}

import * as clone from "clone-deep";
import * as Act from "./geojson.action";
import { GeojsonModel } from "./geojson.model";
import * as Buzz from "./geojson.buzzer";
import State from "../99.core/state";

export function reducer(model: GeojsonModel = new GeojsonModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_GEOJSON:
 return Buzz.updateGeojson(clone(model), act.bale, state);

 case Act.INIT_GEOJSON:
 return Buzz.initGeojson(clone(model), act.bale, state);

case Act.LOAD_GEOJSON:
 return Buzz.loadGeojson(clone(model), act.bale, state);
 
case Act.INDEX_GEOJSON:
 return Buzz.indexGeojson(clone(model), act.bale, state);
 
case Act.CAPTURE_GEOJSON:
 return Buzz.captureGeojson(clone(model), act.bale, state);
 
case Act.SAVE_GEOJSON:
 return Buzz.saveGeojson(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class GeojsonUnit {

 constructor(state: State) {
 }
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });



"use strict";
exports.__esModule = true;
//# sourceMappingURL=bus.bit.js.map

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=bus.interface.js.map

import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CANVAS = "[Canvas action] Init Canvas";
export const UPDATE_CANVAS = "[Canvas action] Update Canvas";
export const READ_CANVAS = "[Read action] Read Canvas";
export const WRITE_CANVAS = "[Write action] Write Canvas";
export const DELETE_CANVAS = "[Delete action] Delete Canvas";
export const REMOVE_CANVAS = "[Remove action] Remove Canvas";
export const CREATE_CANVAS = "[Create action] Create Canvas";
export const NEST_CANVAS = "[Nest action] Nest Canvas";
export const INIT_CHOICE = "[Choice action] Init Choice";
export const UPDATE_CHOICE = "[Choice action] Update Choice";
export const OPEN_CHOICE = "[Open action] Open Choice";
export const KEY_CHOICE = "[Key action] Key Choice";
export const TOWER_CHOICE = "[Tower action] Tower Choice";

export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";
export const INIT_DISK = '[Disk action] Init Disk'
export const UPDATE_DISK = '[Disk action] Update Disk'
export const READ_DISK = '[Disk action] Read Disk'
export const WRITE_DISK = '[Disk action] Write Disk'
export const INDEX_DISK = '[Index action] Index Disk'
export const LOAD_LIST_DISK = '[Load_list action] Load_list Disk'
export const COPY_DISK = '[Copy action] Copy Disk'
export const FRAME_DISK = '[Frame action] Frame Disk'
export const BATCH_DISK = '[Batch action] Batch Disk'
export const TRASH_DISK = '[Trash action] Trash Disk'
export const ENSURE_DISK = '[Ensure action] Ensure Disk'
export const DELETE_DISK = '[Delete action] Delete Disk'
export const INIT_ENGINE = "[Engine action] Init Engine";
export const UPDATE_ENGINE = "[Engine action] Update Engine";
export const MOVEMENT_ENGINE = "[Movement action] Movement Engine";
export const OPEN_ENGINE = "[Open action] Open Engine";
export const CLOSE_ENGINE = "[Close action] Close Engine";
 
export const INIT_GITHUB = "[Github action] Init Github";
export const UPDATE_GITHUB = "[Github action] Update Github";
export const COMMIT_GITHUB = "[Commit action] Commit Github";

import { Action } from "../99.core/interface/action.interface";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const CREATE_GRAPHIC = "[Create action] Create Graphic";

export const INIT_GRID = "[Grid action] Init Grid";
export const UPDATE_GRID = "[Grid action] Update Grid";

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export const READ_HEXAGON = "[Read action] Read Hexagon"; 
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
export const INIT_INPUT = "[Input action] Init Input";
export const UPDATE_INPUT = "[Input action] Update Input";
export const OPEN_INPUT = "[Open action] Open Input";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const READY_SPACE = "[Ready action] Ready Space";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const RUN_TERMINAL = "[Run action] Run Terminal";
export const EDIT_TERMINAL = "[Edit action] Edit Terminal"; 
export const PRINT_TERMINAL = "[Print action] Print Terminal";
export const CLOSE_TERMINAL = "[Close action] Close Terminal";
export const OPTION_TERMINAL = "[Option action] Option Terminal";
export const INPUT_TERMINAL = "[Input action] Input Terminal"; 
export const LAYOUT_TERMINAL = "[Layout action] Layout Terminal";
export const OPEN_TERMINAL = "[Layout action] Open Terminal";
export const CLEAR_TERMINAL = "[Layout action] Clear Terminal";

export const INIT_TEXT = "[Text action] Init Text";
export const UPDATE_TEXT = "[Text action] Update Text";
export const READ_TEXT = "[Read action] Read Text";
export const WRITE_TEXT = "[Write action] Write Text";
export const CREATE_TEXT = "[Create action] Create Text";
export const REMOVE_TEXT = "[Remove action] Remove Text";
export const DELETE_TEXT = "[Delete action] Delete Text";
export const LIST_TEXT = "[List action] List Text";

export const INIT_VISAGE = "[Visage action] Init Visage";
export const UPDATE_VISAGE = "[Visage action] Update Visage";
export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage"; 
export const READ_VISAGE = "[Read action] Read Visage";
export const WRITE_VISAGE = "[Write action] Write Visage"; 
export const CREATE_VISAGE = "[Create action] Create Visage";
export const SIZE_VISAGE = "[Size action] Size Visage";
export const RENDER_VISAGE = "[Render action] Render Visage";
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import SpaceUnit from "./00.space.unit/space.unit";
import HexmapUnit from "./01.hexmap.unit/hexmap.unit";
import FocusUnit from "./02.focus.unit/focus.unit";
import GeojsonUnit from "./03.geojson.unit/geojson.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Space from "./00.space.unit/fce/space.interface";
import { SpaceModel } from "./00.space.unit/space.model";
import Hexmap from "./01.hexmap.unit/fce/hexmap.interface";
import { HexmapModel } from "./01.hexmap.unit/hexmap.model";
import Focus from "./02.focus.unit/fce/focus.interface";
import { FocusModel } from "./02.focus.unit/focus.model";
import Geojson from "./03.geojson.unit/fce/geojson.interface";
import { GeojsonModel } from "./03.geojson.unit/geojson.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [SpaceUnit,HexmapUnit,FocusUnit,GeojsonUnit,CollectUnit,BusUnit];

import * as reduceFromSpace from "./00.space.unit/space.reduce";
import * as reduceFromHexmap from "./01.hexmap.unit/hexmap.reduce";
import * as reduceFromFocus from "./02.focus.unit/focus.reduce";
import * as reduceFromGeojson from "./03.geojson.unit/geojson.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 space : reduceFromSpace.reducer, 
hexmap : reduceFromHexmap.reducer, 
focus : reduceFromFocus.reducer, 
geojson : reduceFromGeojson.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 space : Space = new SpaceModel();
hexmap : Hexmap = new HexmapModel();
focus : Focus = new FocusModel();
geojson : Geojson = new GeojsonModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const VERTICAL = "vertical";
export const HORIZONTAL = "horizontal";



export const BLACK: string = "black";
export const RED: string = "red";
export const GREEN: string = "green";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";
export const CYAN: string = "cyan";
export const WHITE: string = "white";
export const BLUE: string = "blue";
"use strict";
exports.__esModule = true;
exports.CYAN = exports.MAGENTA = exports.YELLOW = exports.GREEN = exports.RED = void 0;
exports.RED = "\x1b[31m%s\x1b[0m";
exports.GREEN = "\x1b[32m%s\x1b[0m";
exports.YELLOW = "\x1b[33m%s\x1b[0m";
exports.MAGENTA = "\x1b[34m%s\x1b[0m";
exports.CYAN = "\x1b[36m%s\x1b[0m";
//# sourceMappingURL=console.js.map
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

"use strict";
exports.__esModule = true;
exports.WISE_NORTH_EAST = exports.WISE_NORTH = exports.WISE_NORTH_WEST = exports.WISE_WEST = exports.WISE_SOUTH_WEST = exports.WISE_SOUTH = exports.WISE_SOUTH_EAST = exports.WISE_EAST = exports.NORTH_EAST = exports.NORTH = exports.NORTH_WEST = exports.WEST = exports.SOUTH_WEST = exports.SOUTH = exports.SOUTH_EAST = exports.EAST = void 0;
exports.EAST = "E";
exports.SOUTH_EAST = "SE";
exports.SOUTH = "S";
exports.SOUTH_WEST = "SW";
exports.WEST = "W";
exports.NORTH_WEST = "NW";
exports.NORTH = "N";
exports.NORTH_EAST = "NE";
exports.WISE_EAST = "Wise E";
exports.WISE_SOUTH_EAST = "Wise SE";
exports.WISE_SOUTH = "Wise S";
exports.WISE_SOUTH_WEST = "Wise SW";
exports.WISE_WEST = "Wise W";
exports.WISE_NORTH_WEST = "Wise NW";
exports.WISE_NORTH = "Wise N";
exports.WISE_NORTH_EAST = "Wise NE";
//# sourceMappingURL=direction.js.map
export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
"use strict";
exports.__esModule = true;
exports.CIRCLE = exports.ROUNDED_RECTANGLE = exports.RECTANGLE = void 0;
exports.RECTANGLE = "rectangle";
exports.ROUNDED_RECTANGLE = "rounded-rectangle";
exports.CIRCLE = "circle";
//# sourceMappingURL=graphic.js.map
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export type Position <Type> = {
    x: number;
    y: number;
} & Type


export type GridFill =Position<{
    xSpan:number;
    ySpan:number;
}>

export const TOP_FULL_IDX = 'top-fill';
export const MID_FULL_IDX = 'mid-fill';
export const BOT_FULL_IDX  = 'bot-fill';

export const TOP_FULL_BIT:GridFill= {x:0, y:0, xSpan:12, ySpan:4};
export const MID_FULL_BIT:GridFill= {x:0, y:4, xSpan:12, ySpan:5};
export const BOT_FULL_BIT:GridFill= {x:0, y:8, xSpan:12, ySpan:4};

"use strict";
exports.__esModule = true;
exports.HEXMAP = exports.FOCUS = void 0;
exports.FOCUS = "focus";
exports.HEXMAP = "hexmap";
//# sourceMappingURL=hexagon.js.map
export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
"use strict";
exports.__esModule = true;
exports.PASTURE = exports.FANG_SWAMP = exports.GEORGIA = exports.GALLBLADDER = void 0;
exports.GALLBLADDER = "00000.gallbladder";
exports.GEORGIA = "00001.georgia";
exports.FANG_SWAMP = "00002.fang-swamp";
exports.PASTURE = "00003.pasture";
//# sourceMappingURL=hexmap.js.map
export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const WELCOME_WINDOW: string = "welcomeWindow";
export const PLAY_DATA_GROUP: string = "playerDataGroup";
export const ICON_WINDOW: string = "iconWindow";
export const DEBUG_WINDOW: string = "debugWindow";
export const ACTION_BAR: string = "actionBar";
export const CLOCK_BAR: string = "clockBar";
export const ERROR_MESSAGE: string = "errorMessage";
export const COVER_SCREEN: string = "coverScreen";
"use strict";
exports.__esModule = true;
exports.MAGENTA = exports.YELLOW = exports.BLUE = exports.GREEN = exports.RED = exports.CYAN = exports.CLEAN = exports.MENU_SINGLE = exports.TIMELINE = exports.SPACE = void 0;
exports.SPACE = "space";
exports.TIMELINE = "timeline";
exports.MENU_SINGLE = "menu_single";
exports.CLEAN = "clean";
exports.CYAN = "cyan";
exports.RED = "red";
exports.GREEN = "green";
exports.BLUE = "blue";
exports.YELLOW = "yellow";
exports.MAGENTA = "magenta";
//# sourceMappingURL=markup.js.map
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

"use strict";
exports.__esModule = true;
exports.LOOP = exports.VIDEO = exports.HEXAGON = exports.SPRITE = exports.TEXT = exports.GRAPHIC = exports.CONTAINER = exports.SURFACE = exports.VISAGE = void 0;
exports.VISAGE = "visage";
exports.SURFACE = "surface";
exports.CONTAINER = "container";
exports.GRAPHIC = "graphic";
exports.TEXT = "text";
exports.SPRITE = "sprite";
exports.HEXAGON = "hexagon";
exports.VIDEO = "video";
exports.LOOP = "loop";
//# sourceMappingURL=shade.js.map
export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
export const GEOJSON = "geojson";
export const RECTANGLE = "rectangle";
export const TRIANGLE = "triangle";
export const HEXAGON = "hexagon";
export const PARALLELOGRAM = "parallelogram";

export const FOCUS = "focus";
export const HEXMAP = "hexmap";
export const CLOCK: string = "clock";
"use strict";
exports.__esModule = true;
exports.MOUNT_WIDTH = exports.MOUNT_HEIGHT = exports.MOUNT_PART = exports.MOUNT_FULL = exports.SCREEN = void 0;
exports.SCREEN = "screen-visage";
exports.MOUNT_FULL = "mount-visage-full";
exports.MOUNT_PART = "mount-visage-part";
exports.MOUNT_HEIGHT = "mount-visage-height";
exports.MOUNT_WIDTH = "mount-visage-width";
//# sourceMappingURL=visage.js.map
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";
import { SowerModel } from "../sower.model";
import SowerBit from "../fce/sower.bit";
import State from "../../99.core/state";

import * as ActSow from "../../00.sower.unit/sower.action";
import * as ActCns from "../../act/console.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action";

import * as ActPmt from "../../act/prompt.action";
import * as ActOlm from "../../act/ollama.action";
import * as ActGeo from "../../act/geojson.action";
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";

var bit, val, idx, dex, lst, dat, src;

export const initSower = async (cpy: SowerModel, bal: SowerBit, ste: State) => {

    bal.slv({ intBit: { idx: "init-sower", bit } });
    return cpy;
};

export const openSower = async (cpy: SowerModel, bal: SowerBit, ste: State) => {

    bal.slv({ sowBit: { idx: "open-sower", dat: { lst: [] } } });
    return cpy;
};

export const updateSower = (cpy: SowerModel, bal: SowerBit, ste: State) => {

    bal.slv({ sowBit: { idx: "update-sower", dat: { lst: [] } } });
    return cpy;
};



export const testSower = (cpy: SowerModel, bal: SowerBit, ste: State) => {

    bal.slv({ sowBit: { idx: "test-sower", val: 1 } });
    return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

export default interface SowerBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  SowerBit  from "./sower.bit";

export default interface Sower {
 // idx:string;
 // sowerBitList: SowerBit[];
 // sowerBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SowerBit  from "./fce/sower.bit";

// Sower actions

export const INIT_SOWER = "[Sower action] Init Sower";
export class InitSower implements Action {
 readonly type = INIT_SOWER;
 constructor(public bale: SowerBit) {}
}

export const UPDATE_SOWER = "[Sower action] Update Sower";
export class UpdateSower implements Action {
 readonly type = UPDATE_SOWER;
 constructor(public bale: SowerBit) {}
}

export const DEV_SOWER = "[Dev action] Dev Sower";
 export class DevSower implements Action {
 readonly type = DEV_SOWER;
 constructor(public bale: SowerBit) {}
 }
 
export const OPEN_SOWER = "[Open action] Open Sower";
 export class OpenSower implements Action {
 readonly type = OPEN_SOWER;
 constructor(public bale: SowerBit) {}
 }
 
export const TEST_SOWER = "[Test action] Test Sower";
 export class TestSower implements Action {
 readonly type = TEST_SOWER;
 constructor(public bale: SowerBit) {}
 }
 
export type Actions = | InitSower | UpdateSower 
| DevSower
| OpenSower
| TestSower
export { initSower  } from "./buz/sower.buzz";
export { updateSower  } from "./buz/sower.buzz";
export { openSower  } from "./buz/sower.buzz";
export { testSower  } from "./buz/sower.buzz";
import Sower from "./fce/sower.interface";
import SowerBit from "./fce/sower.interface";

export class SowerModel implements Sower {
 idx:string = '111.sower'
 //sowerBitList: SowerBit[] = [];
 //sowerBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./sower.action";
import { SowerModel } from "./sower.model";
import * as Buzz from "./sower.buzzer";
import State from "../99.core/state";

export function reducer(model: SowerModel = new SowerModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SOWER:
 return Buzz.updateSower(clone(model), act.bale, state);

 case Act.INIT_SOWER:
 return Buzz.initSower(clone(model), act.bale, state);

 
case Act.OPEN_SOWER:
 return Buzz.openSower(clone(model), act.bale, state);
 
case Act.TEST_SOWER:
 return Buzz.testSower(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SowerUnit {

 constructor(state: State) {
 }
}

global.SOWER = require("../dist/111.sower/hunt");
global.SOWER.MQTT = require("async-mqtt");
global.SOWER.ActSwr = require("../dist/111.sower/00.sower.unit/sower.action");






import { SparkModel } from "../spark.model";
import SparkBit from "../fce/spark.bit";
import State from "../../99.core/state";
import OrbBit from "../fce/orb.bit";

//import * as ActClr from "../../../000.earth/03.color.unit/color.action";
import * as ActSpk from "../../03.spark.unit/spark.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"

import EtherealBit from "../fce/talent/etheric.bit";

var bit, val, idx, dex, lst, dat, src;

export const createSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {

    var dat: OrbBit = { idx: bal.idx, src: bal.src }

    var etri:EtherealBit = { bliyte:null, grusit:null, flxuow:null, kldadu:null };
    dat.bit = etri;

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  dat.bit.bliyte = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  dat.bit.flxuow = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  dat.bit.grusit = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  dat.bit.kldadu = bit.clrBit.dat

    dat

    bal.slv({ spkBit: { idx: "create-spark", dat } });

    return cpy;
};

import * as ActSpk from "../../03.spark.unit/spark.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";


import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"


var bit, val, idx, dex, lst, dat, src;

export const initSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {

    //set up colors 
    //src = '000.color.name.json'
    //bit = await ste.bus(ActDsk.READ_DISK, { src: './data/color-list/' + src })
    //var colorList = bit.dskBit.dat;

    //lst = JSON.parse(colorList)
   
    //bit = await ste.bus(ActClr.WRITE_COLOR, { idx: 'clr00', dat: { lst } });

    //var staveDataLoc = './data/stave/'
    //src = staveDataLoc + '002.genisi.txt';

    //bit = await ste.bus(ActStv.WRITE_STAVE, { src });
    
    bal.slv({ intBit: { idx: "init-spark" } });

    return cpy;
};


export const updateSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {
    return cpy;
};


export const readSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {

    if (bal.idx == null) bal.idx = 'spk00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActSpk.CREATE_SPARK })

    bal.slv({ spkBit: { idx: "read-spark", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActSpk.CREATE_SPARK })

    if (bal.slv != null) bal.slv({ spkBit: { idx: "write-spark", dat: bit.clcBit.dat } });
    return cpy;
};



export const removeSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {
    debugger
    return cpy;
};


export const deleteSpark = async (cpy: SparkModel, bal: SparkBit, ste: State) => {
    debugger
    return cpy;
};




import { SparkModel } from "../spark.model";
import SparkBit from "../fce/spark.bit";
import State from "../../99.core/state";
import OrbBit from "../fce/orb.bit";

import EthericBit from "./talent/etheric.bit";

export default interface OrbBit {
 idx:string;
 src?:string;
 bit?:EthericBit
}


export default interface SparkBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  SparkBit  from "./spark.bit";

export default interface Spark {
 // idx:string;
 // sparkBitList: SparkBit[];
 // sparkBits:any;

}


export default interface AuthenticBit {
    direction: string;
    purpose: string;
    cohesion: string;
}


export default interface CapacitiveBit {
    cognition: string;
    vocabulary: string;
    reminiscence: string;
}



export default interface EthericBit {
    bliyte: string;
    grusit: string;
    flxuow: string;
    kldadu: string
}


export default interface ImaginativeBit {
    style: string;
    ingenuity: string;
    vision: string;
}



export default interface LegitimateBit {
    fidelity: string;
    recognition: string;
    sovereignty: string;
}


export default interface PivotalBit {
    contribution: string;
    gravity: string;
    providence: string;
}



export default interface ReactiveBit {
    discernment: string;
    impulse: string;
    sensation: string;
}



export default interface SignificantBit {
    force: string;
    charge: string;
    scale: string;
}


export default interface VigorousBit {
    pizazz: string;
    oomph: string;
    zing: string;
}

import { Action } from "../99.core/interface/action.interface";
import  SparkBit  from "./fce/spark.bit";

// Spark actions

export const INIT_SPARK = "[Spark action] Init Spark";
export class InitSpark implements Action {
 readonly type = INIT_SPARK;
 constructor(public bale: SparkBit) {}
}

export const UPDATE_SPARK = "[Spark action] Update Spark";
export class UpdateSpark implements Action {
 readonly type = UPDATE_SPARK;
 constructor(public bale: SparkBit) {}
}

export const READ_SPARK = "[Read action] Read Spark";
 export class ReadSpark implements Action {
 readonly type = READ_SPARK;
 constructor(public bale: SparkBit) {}
 }
 
export const WRITE_SPARK = "[Write action] Write Spark";
 export class WriteSpark implements Action {
 readonly type = WRITE_SPARK;
 constructor(public bale: SparkBit) {}
 }
 
export const REMOVE_SPARK = "[Remove action] Remove Spark";
 export class RemoveSpark implements Action {
 readonly type = REMOVE_SPARK;
 constructor(public bale: SparkBit) {}
 }
 
export const DELETE_SPARK = "[Delete action] Delete Spark";
 export class DeleteSpark implements Action {
 readonly type = DELETE_SPARK;
 constructor(public bale: SparkBit) {}
 }
 
export const CREATE_SPARK = "[Create action] Create Spark";
 export class CreateSpark implements Action {
 readonly type = CREATE_SPARK;
 constructor(public bale: SparkBit) {}
 }
 
export type Actions = | InitSpark | UpdateSpark 
| ReadSpark
| WriteSpark
| RemoveSpark
| DeleteSpark
| CreateSpark
export { initSpark  } from "./buz/spark.buzz";
export { updateSpark  } from "./buz/spark.buzz";
export { readSpark  } from "./buz/spark.buzz";
export { writeSpark  } from "./buz/spark.buzz";
export { removeSpark  } from "./buz/spark.buzz";
export { deleteSpark  } from "./buz/spark.buzz";
export { createSpark  } from "./buz/createSpark.buzz";
import Spark from "./fce/spark.interface";
import SparkBit from "./fce/spark.interface";

export class SparkModel implements Spark {
 //idx:string;
 //sparkBitList: SparkBit[] = [];
 //sparkBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./spark.action";
import { SparkModel } from "./spark.model";
import * as Buzz from "./spark.buzzer";
import State from "../99.core/state";

export function reducer(model: SparkModel = new SparkModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SPARK:
 return Buzz.updateSpark(clone(model), act.bale, state);

 case Act.INIT_SPARK:
 return Buzz.initSpark(clone(model), act.bale, state);

case Act.READ_SPARK:
 return Buzz.readSpark(clone(model), act.bale, state);
 
case Act.WRITE_SPARK:
 return Buzz.writeSpark(clone(model), act.bale, state);
 
case Act.REMOVE_SPARK:
 return Buzz.removeSpark(clone(model), act.bale, state);
 
case Act.DELETE_SPARK:
 return Buzz.deleteSpark(clone(model), act.bale, state);
 
case Act.CREATE_SPARK:
 return Buzz.createSpark(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SparkUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  AmbitBit  from "./fce/ambit.bit";

// Ambit actions

export const INIT_AMBIT = "[Ambit action] Init Ambit";
export class InitAmbit implements Action {
 readonly type = INIT_AMBIT;
 constructor(public bale: AmbitBit) {}
}

export const UPDATE_AMBIT = "[Ambit action] Update Ambit";
export class UpdateAmbit implements Action {
 readonly type = UPDATE_AMBIT;
 constructor(public bale: AmbitBit) {}
}

export const READ_AMBIT = "[Read action] Read Ambit";
 export class ReadAmbit implements Action {
 readonly type = READ_AMBIT;
 constructor(public bale: AmbitBit) {}
 }
 
export const WRITE_AMBIT = "[Write action] Write Ambit";
 export class WriteAmbit implements Action {
 readonly type = WRITE_AMBIT;
 constructor(public bale: AmbitBit) {}
 }
 
export const REMOVE_AMBIT = "[Remove action] Remove Ambit";
 export class RemoveAmbit implements Action {
 readonly type = REMOVE_AMBIT;
 constructor(public bale: AmbitBit) {}
 }
 
export const DELETE_AMBIT = "[Delete action] Delete Ambit";
 export class DeleteAmbit implements Action {
 readonly type = DELETE_AMBIT;
 constructor(public bale: AmbitBit) {}
 }
 
export const CREATE_AMBIT = "[Create action] Create Ambit";
 export class CreateAmbit implements Action {
 readonly type = CREATE_AMBIT;
 constructor(public bale: AmbitBit) {}
 }
 
export type Actions = | InitAmbit | UpdateAmbit 
| ReadAmbit
| WriteAmbit
| RemoveAmbit
| DeleteAmbit
| CreateAmbit
export { initAmbit  } from "./buz/ambit.buzz";
export { updateAmbit  } from "./buz/ambit.buzz";
export { readAmbit  } from "./buz/ambit.buzz";
export { writeAmbit  } from "./buz/ambit.buzz";
export { removeAmbit  } from "./buz/ambit.buzz";
export { deleteAmbit  } from "./buz/ambit.buzz";
export { createAmbit  } from "./buz/createAmbit.buzz";
import Ambit from "./fce/ambit.interface";
import AmbitBit from "./fce/ambit.interface";

export class AmbitModel implements Ambit {
 //idx:string;
 //ambitBitList: AmbitBit[] = [];
 //ambitBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./ambit.action";
import { AmbitModel } from "./ambit.model";
import * as Buzz from "./ambit.buzzer";
import State from "../99.core/state";

export function reducer(model: AmbitModel = new AmbitModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_AMBIT:
 return Buzz.updateAmbit(clone(model), act.bale, state);

 case Act.INIT_AMBIT:
 return Buzz.initAmbit(clone(model), act.bale, state);

case Act.READ_AMBIT:
 return Buzz.readAmbit(clone(model), act.bale, state);
 
case Act.WRITE_AMBIT:
 return Buzz.writeAmbit(clone(model), act.bale, state);
 
case Act.REMOVE_AMBIT:
 return Buzz.removeAmbit(clone(model), act.bale, state);
 
case Act.DELETE_AMBIT:
 return Buzz.deleteAmbit(clone(model), act.bale, state);
 
case Act.CREATE_AMBIT:
 return Buzz.createAmbit(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class AmbitUnit {

 constructor(state: State) {
 }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAbt from "../ambit.action";

import { AmbitModel } from "../ambit.model";
import AmbitBit from "../fce/ambit.bit";
import AmbBit from "../fce/amb.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initAmbit = (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-ambit" } });
    return cpy;
};

export const updateAmbit = (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    bal.slv({ abtBit: { idx: "update-ambit" } });
    return cpy;
};

export const readAmbit = async (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'abt00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActAbt.CREATE_AMBIT });
    if (bal.slv != null) bal.slv({ abtBit: { idx: "read-ambit", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeAmbit = async (cpy: AmbitModel, bal: AmbitBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'amb00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActAbt.CREATE_AMBIT });
    if (bal.slv != null) bal.slv({ abtBit: { idx: "write-ambit", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeAmbit = async (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActAbt.DELETE_AMBIT });
    if (bal.slv != null) bal.slv({ abtBit: { idx: "remove-ambit", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteAmbit = (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    if (bal.slv != null) bal.slv({ abtBit: { idx: "delete-ambit" } });
    return cpy;
};

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAbt from "../ambit.action";

import { AmbitModel } from "../ambit.model";
import AmbitBit from "../fce/ambit.bit";
import AmbBit from "../fce/amb.bit";
import State from "../../99.core/state";

//import * as ActClr from "../../../000.earth/03.color.unit/color.action";
import * as ActSpk from '../../03.spark.unit/spark.action'
import PivotalBit from "010.sower/03.spark.unit/fce/talent/pivotal.bit";

var bit, val, idx, dex, lst, dat, src;

export const createAmbit = async (cpy: AmbitModel, bal: AmbitBit, ste: State) => {
    var dat: AmbBit = { idx: bal.idx, src: "default-ambit-source", orb:null };
    
    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    bit = await ste.hunt( ActSpk.CREATE_SPARK, {idx:bal.idx})
    dat.orb = bit.spkBit.dat.bit;

    var pvl:PivotalBit = { contribution:null, gravity:null, providence:null };
    
   // bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // pvl.contribution = bit.clrBit.dat

   // bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // pvl.gravity = bit.clrBit.dat

    //bit = await ste.hunt( ActClr.BASKET_COLOR, {})
    //pvl.providence = bit.clrBit.dat
    
    dat.pvl = pvl;
    
    bal.slv({ abtBit: { idx: "create-ambit", dat: dat } });
    return cpy;
};
import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";
import PivotalBit from "010.sower/03.spark.unit/fce/talent/pivotal.bit";

export default interface AmbBit {
 idx: string;
 src?: string;
 orb?: OrbBit
 pvl?: PivotalBit 
}




export default interface AmbitBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  AmbitBit  from "./ambit.bit";

export default interface Ambit {
 // idx:string;
 // ambitBitList: AmbitBit[];
 // ambitBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  AvaouBit  from "./fce/avaou.bit";

// Avaou actions

export const INIT_AVAOU = "[Avaou action] Init Avaou";
export class InitAvaou implements Action {
 readonly type = INIT_AVAOU;
 constructor(public bale: AvaouBit) {}
}

export const UPDATE_AVAOU = "[Avaou action] Update Avaou";
export class UpdateAvaou implements Action {
 readonly type = UPDATE_AVAOU;
 constructor(public bale: AvaouBit) {}
}

export const READ_AVAOU = "[Read action] Read Avaou";
 export class ReadAvaou implements Action {
 readonly type = READ_AVAOU;
 constructor(public bale: AvaouBit) {}
 }
 
export const WRITE_AVAOU = "[Write action] Write Avaou";
 export class WriteAvaou implements Action {
 readonly type = WRITE_AVAOU;
 constructor(public bale: AvaouBit) {}
 }
 
export const REMOVE_AVAOU = "[Remove action] Remove Avaou";
 export class RemoveAvaou implements Action {
 readonly type = REMOVE_AVAOU;
 constructor(public bale: AvaouBit) {}
 }
 
export const DELETE_AVAOU = "[Delete action] Delete Avaou";
 export class DeleteAvaou implements Action {
 readonly type = DELETE_AVAOU;
 constructor(public bale: AvaouBit) {}
 }
 
export const CREATE_AVAOU = "[Create action] Create Avaou";
 export class CreateAvaou implements Action {
 readonly type = CREATE_AVAOU;
 constructor(public bale: AvaouBit) {}
 }
 
export type Actions = | InitAvaou | UpdateAvaou 
| ReadAvaou
| WriteAvaou
| RemoveAvaou
| DeleteAvaou
| CreateAvaou
export { initAvaou  } from "./buz/avaou.buzz";
export { updateAvaou  } from "./buz/avaou.buzz";
export { readAvaou  } from "./buz/avaou.buzz";
export { writeAvaou  } from "./buz/avaou.buzz";
export { removeAvaou  } from "./buz/avaou.buzz";
export { deleteAvaou  } from "./buz/avaou.buzz";
export { createAvaou  } from "./buz/createAvaou.buzz";
import Avaou from "./fce/avaou.interface";
import AvaouBit from "./fce/avaou.interface";

export class AvaouModel implements Avaou {
 //idx:string;
 //avaouBitList: AvaouBit[] = [];
 //avaouBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./avaou.action";
import { AvaouModel } from "./avaou.model";
import * as Buzz from "./avaou.buzzer";
import State from "../99.core/state";

export function reducer(model: AvaouModel = new AvaouModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_AVAOU:
 return Buzz.updateAvaou(clone(model), act.bale, state);

 case Act.INIT_AVAOU:
 return Buzz.initAvaou(clone(model), act.bale, state);

case Act.READ_AVAOU:
 return Buzz.readAvaou(clone(model), act.bale, state);
 
case Act.WRITE_AVAOU:
 return Buzz.writeAvaou(clone(model), act.bale, state);
 
case Act.REMOVE_AVAOU:
 return Buzz.removeAvaou(clone(model), act.bale, state);
 
case Act.DELETE_AVAOU:
 return Buzz.deleteAvaou(clone(model), act.bale, state);
 
case Act.CREATE_AVAOU:
 return Buzz.createAvaou(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class AvaouUnit {

 constructor(state: State) {
 }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAvo from "../avaou.action";

import { AvaouModel } from "../avaou.model";
import AvaouBit from "../fce/avaou.bit";
import AvoBit from "../fce/avo.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initAvaou = (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-avaou" } });
    return cpy;
};

export const updateAvaou = (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    bal.slv({ avoBit: { idx: "update-avaou" } });
    return cpy;
};

export const readAvaou = async (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'avo00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActAvo.CREATE_AVAOU });
    if (bal.slv != null) bal.slv({ avoBit: { idx: "read-avaou", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeAvaou = async (cpy: AvaouModel, bal: AvaouBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'avo00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActAvo.CREATE_AVAOU });
    if (bal.slv != null) bal.slv({ avoBit: { idx: "write-avaou", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeAvaou = async (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActAvo.DELETE_AVAOU });
    if (bal.slv != null) bal.slv({ avoBit: { idx: "remove-avaou", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteAvaou = (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    if (bal.slv != null) bal.slv({ avoBit: { idx: "delete-avaou" } });
    return cpy;
};


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAvo from "../avaou.action";

import { AvaouModel } from "../avaou.model";
import AvaouBit from "../fce/avaou.bit";
import AvoBit from "../fce/avo.bit";
import State from "../../99.core/state";

//import * as ActClr from "../../../000.earth/03.color.unit/color.action";

import * as ActSpk from '../../03.spark.unit/spark.action'
import VigorousBit from "010.sower/03.spark.unit/fce/talent/vigorous.bit";


var bit, val, idx, dex, lst, dat, src;


export const createAvaou = async (cpy: AvaouModel, bal: AvaouBit, ste: State) => {
    var dat: AvoBit = { idx: bal.idx, src: "default-avaou-source" };
    
    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    bit = await ste.hunt( ActSpk.CREATE_SPARK, {idx:bal.idx})
    dat.orb = bit.spkBit.dat.bit;

    var vig:VigorousBit = { pizazz:null, oomph:null, zing:null };
    
   // bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // vig.pizazz = bit.clrBit.dat

   // bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // vig.oomph = bit.clrBit.dat

   // bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // vig.zing = bit.clrBit.dat
    
    dat.vig = vig;
    
    bal.slv({ avoBit: { idx: "create-avaou", dat: dat } });
    return cpy;
};

export default interface AvaouBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  AvaouBit  from "./avaou.bit";

export default interface Avaou {
 // idx:string;
 // avaouBitList: AvaouBit[];
 // avaouBits:any;

}

import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";
import VigorousBit from "010.sower/03.spark.unit/fce/talent/vigorous.bit";

export default interface AvoBit {
 idx: string;
 src?: string;
 orb?: OrbBit
 vig?: VigorousBit;
}



import { Action } from "../99.core/interface/action.interface";
import  AvideBit  from "./fce/avide.bit";

// Avide actions

export const INIT_AVIDE = "[Avide action] Init Avide";
export class InitAvide implements Action {
 readonly type = INIT_AVIDE;
 constructor(public bale: AvideBit) {}
}

export const UPDATE_AVIDE = "[Avide action] Update Avide";
export class UpdateAvide implements Action {
 readonly type = UPDATE_AVIDE;
 constructor(public bale: AvideBit) {}
}

export const READ_AVIDE = "[Read action] Read Avide";
 export class ReadAvide implements Action {
 readonly type = READ_AVIDE;
 constructor(public bale: AvideBit) {}
 }
 
export const WRITE_AVIDE = "[Write action] Write Avide";
 export class WriteAvide implements Action {
 readonly type = WRITE_AVIDE;
 constructor(public bale: AvideBit) {}
 }
 
export const REMOVE_AVIDE = "[Remove action] Remove Avide";
 export class RemoveAvide implements Action {
 readonly type = REMOVE_AVIDE;
 constructor(public bale: AvideBit) {}
 }
 
export const DELETE_AVIDE = "[Delete action] Delete Avide";
 export class DeleteAvide implements Action {
 readonly type = DELETE_AVIDE;
 constructor(public bale: AvideBit) {}
 }
 
export const CREATE_AVIDE = "[Create action] Create Avide";
 export class CreateAvide implements Action {
 readonly type = CREATE_AVIDE;
 constructor(public bale: AvideBit) {}
 }
 
export type Actions = | InitAvide | UpdateAvide 
| ReadAvide
| WriteAvide
| RemoveAvide
| DeleteAvide
| CreateAvide
export { initAvide  } from "./buz/avide.buzz";
export { updateAvide  } from "./buz/avide.buzz";
export { readAvide  } from "./buz/avide.buzz";
export { writeAvide  } from "./buz/avide.buzz";
export { removeAvide  } from "./buz/avide.buzz";
export { deleteAvide  } from "./buz/avide.buzz";
export { createAvide  } from "./buz/createAvide.buzz";
import Avide from "./fce/avide.interface";
import AvideBit from "./fce/avide.interface";

export class AvideModel implements Avide {
 //idx:string;
 //avideBitList: AvideBit[] = [];
 //avideBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./avide.action";
import { AvideModel } from "./avide.model";
import * as Buzz from "./avide.buzzer";
import State from "../99.core/state";

export function reducer(model: AvideModel = new AvideModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_AVIDE:
 return Buzz.updateAvide(clone(model), act.bale, state);

 case Act.INIT_AVIDE:
 return Buzz.initAvide(clone(model), act.bale, state);

case Act.READ_AVIDE:
 return Buzz.readAvide(clone(model), act.bale, state);
 
case Act.WRITE_AVIDE:
 return Buzz.writeAvide(clone(model), act.bale, state);
 
case Act.REMOVE_AVIDE:
 return Buzz.removeAvide(clone(model), act.bale, state);
 
case Act.DELETE_AVIDE:
 return Buzz.deleteAvide(clone(model), act.bale, state);
 
case Act.CREATE_AVIDE:
 return Buzz.createAvide(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class AvideUnit {

 constructor(state: State) {
 }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAvd from "../avide.action";

import { AvideModel } from "../avide.model";
import AvideBit from "../fce/avide.bit";
import AvdBit from "../fce/avd.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initAvide = (cpy: AvideModel, bal: AvideBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-avide" } });
    return cpy;
};

export const updateAvide = (cpy: AvideModel, bal: AvideBit, ste: State) => {
    bal.slv({ avdBit: { idx: "update-avide" } });
    return cpy;
};

export const readAvide = async (cpy: AvideModel, bal: AvideBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'avd00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActAvd.CREATE_AVIDE });
    if (bal.slv != null) bal.slv({ avdBit: { idx: "read-avide", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeAvide = async (cpy: AvideModel, bal: AvideBit, ste: State) => {
    
    if( bal.idx == null ) bal.idx = 'avd00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActAvd.CREATE_AVIDE });
    if (bal.slv != null) bal.slv({ avdBit: { idx: "write-avide", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeAvide = async (cpy: AvideModel, bal: AvideBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActAvd.DELETE_AVIDE });
    if (bal.slv != null) bal.slv({ avdBit: { idx: "remove-avide", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteAvide = (cpy: AvideModel, bal: AvideBit, ste: State) => {
    if (bal.slv != null) bal.slv({ avdBit: { idx: "delete-avide" } });
    return cpy;
};


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActAvd from "../avide.action";

import { AvideModel } from "../avide.model";
import AvideBit from "../fce/avide.bit";
import AvdBit from "../fce/avd.bit";
import State from "../../99.core/state";

import * as ActSpk from '../../03.spark.unit/spark.action'
import VigorousBit from "010.sower/03.spark.unit/fce/talent/vigorous.bit";


//import * as ActClr from "../../../000.earth/03.color.unit/color.action";

var bit, val, idx, dex, lst, dat, src;

export const createAvide = async (cpy: AvideModel, bal: AvideBit, ste: State) => {
    var dat: AvdBit = { idx: bal.idx, src: "default-avide-source" };

    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    bit = await ste.hunt( ActSpk.CREATE_SPARK, {idx:bal.idx})
    dat.orb = bit.spkBit.dat.bit;

    var vig:VigorousBit = { pizazz:null, oomph:null, zing:null };
    
  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
   // vig.pizazz = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  vig.oomph = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  vig.zing = bit.clrBit.dat
    
    dat.vig = vig;

    bal.slv({ avdBit: { idx: "create-avide", dat: dat } });
    return cpy;
};
import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";
import VigorousBit from "010.sower/03.spark.unit/fce/talent/vigorous.bit";

export default interface AvdBit {
 idx: string;
 src?: string;
 orb?: OrbBit
 vig?: VigorousBit
}




export default interface AvideBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  AvideBit  from "./avide.bit";

export default interface Avide {
 // idx:string;
 // avideBitList: AvideBit[];
 // avideBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  ArtesBit  from "./fce/artes.bit";

// Artes actions

export const INIT_ARTES = "[Artes action] Init Artes";
export class InitArtes implements Action {
 readonly type = INIT_ARTES;
 constructor(public bale: ArtesBit) {}
}

export const UPDATE_ARTES = "[Artes action] Update Artes";
export class UpdateArtes implements Action {
 readonly type = UPDATE_ARTES;
 constructor(public bale: ArtesBit) {}
}

export const READ_ARTES = "[Read action] Read Artes";
 export class ReadArtes implements Action {
 readonly type = READ_ARTES;
 constructor(public bale: ArtesBit) {}
 }
 
export const WRITE_ARTES = "[Write action] Write Artes";
 export class WriteArtes implements Action {
 readonly type = WRITE_ARTES;
 constructor(public bale: ArtesBit) {}
 }
 
export const REMOVE_ARTES = "[Remove action] Remove Artes";
 export class RemoveArtes implements Action {
 readonly type = REMOVE_ARTES;
 constructor(public bale: ArtesBit) {}
 }
 
export const DELETE_ARTES = "[Delete action] Delete Artes";
 export class DeleteArtes implements Action {
 readonly type = DELETE_ARTES;
 constructor(public bale: ArtesBit) {}
 }
 
export const CREATE_ARTES = "[Create action] Create Artes";
 export class CreateArtes implements Action {
 readonly type = CREATE_ARTES;
 constructor(public bale: ArtesBit) {}
 }
 
export type Actions = | InitArtes | UpdateArtes 
| ReadArtes
| WriteArtes
| RemoveArtes
| DeleteArtes
| CreateArtes
export { initArtes  } from "./buz/artes.buzz";
export { updateArtes  } from "./buz/artes.buzz";
export { readArtes  } from "./buz/artes.buzz";
export { writeArtes  } from "./buz/artes.buzz";
export { removeArtes  } from "./buz/artes.buzz";
export { deleteArtes  } from "./buz/artes.buzz";
export { createArtes  } from "./buz/createArtes.buzz";

import Artes from "./fce/artes.interface";
import ArtesBit from "./fce/artes.interface";

export class ArtesModel implements Artes {
 //idx:string;
 //artesBitList: ArtesBit[] = [];
 //artesBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./artes.action";
import { ArtesModel } from "./artes.model";
import * as Buzz from "./artes.buzzer";
import State from "../99.core/state";

export function reducer(model: ArtesModel = new ArtesModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_ARTES:
 return Buzz.updateArtes(clone(model), act.bale, state);

 case Act.INIT_ARTES:
 return Buzz.initArtes(clone(model), act.bale, state);

case Act.READ_ARTES:
 return Buzz.readArtes(clone(model), act.bale, state);
 
case Act.WRITE_ARTES:
 return Buzz.writeArtes(clone(model), act.bale, state);
 
case Act.REMOVE_ARTES:
 return Buzz.removeArtes(clone(model), act.bale, state);
 
case Act.DELETE_ARTES:
 return Buzz.deleteArtes(clone(model), act.bale, state);
 
case Act.CREATE_ARTES:
 return Buzz.createArtes(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class ArtesUnit {

 constructor(state: State) {
 }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActArt from "../artes.action";

import { ArtesModel } from "../artes.model";
import ArtesBit from "../fce/artes.bit";
import ArtBit from "../fce/art.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initArtes = (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-artes" } });
    return cpy;
};

export const updateArtes = (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    bal.slv({ artBit: { idx: "update-artes" } });
    return cpy;
};

export const readArtes = async (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'art00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActArt.CREATE_ARTES });
    if (bal.slv != null) bal.slv({ artBit: { idx: "read-artes", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeArtes = async (cpy: ArtesModel, bal: ArtesBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'art00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActArt.CREATE_ARTES });
    if (bal.slv != null) bal.slv({ artBit: { idx: "write-artes", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeArtes = async (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActArt.DELETE_ARTES });
    if (bal.slv != null) bal.slv({ artBit: { idx: "remove-artes", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteArtes = (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    if (bal.slv != null) bal.slv({ artBit: { idx: "delete-artes" } });
    return cpy;
};


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActArt from "../artes.action";

import { ArtesModel } from "../artes.model";
import ArtesBit from "../fce/artes.bit";
import ArtBit from "../fce/art.bit";
import State from "../../99.core/state";

//import * as ActClr from "../../../000.earth/03.color.unit/color.action";
import * as ActSpk from '../../03.spark.unit/spark.action'

import ImaginativeBit from "010.sower/03.spark.unit/fce/talent/imaginative.bit";

var bit, val, idx, dex, lst, dat, src;

export const createArtes = async (cpy: ArtesModel, bal: ArtesBit, ste: State) => {
    var dat: ArtBit = { idx: bal.idx, src: "default-artes-source" };
    
    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    bit = await ste.hunt( ActSpk.CREATE_SPARK, {idx:bal.idx})
    dat.orb = bit.spkBit.dat.bit;

    var img:ImaginativeBit = { style:null, ingenuity:null, vision:null };

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  img.style = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  img.ingenuity = bit.clrBit.dat

  //  bit = await ste.hunt( ActClr.BASKET_COLOR, {})
  //  img.vision = bit.clrBit.dat
    
    dat.img = img;

    
    bal.slv({ artBit: { idx: "create-artes", dat: dat } });
    return cpy;
};
import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";
import ImaginativeBit from "010.sower/03.spark.unit/fce/talent/imaginative.bit";

export default interface ArtBit {
 idx: string;
 src?: string;
 orb?: OrbBit
 img?: ImaginativeBit
}




export default interface ArtesBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  ArtesBit  from "./artes.bit";

export default interface Artes {
 // idx:string;
 // artesBitList: ArtesBit[];
 // artesBits:any;

}

import { SupernalModel } from "../supernal.model";
import SupernalBit from "../fce/supernal.bit";
import State from "../../99.core/state";
import SuperBit from "../fce/super.bit";

import * as ActAvo from '../../05.avaou.unit/avaou.action'

import * as ActSup from "../../10.supernal.unit/supernal.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"


var bit, val, idx, dex, lst, dat, src;


export const createSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {
    var dat: SuperBit = { idx: bal.idx, src: bal.src }

    bit = await ste.hunt( ActAvo.CREATE_AVAOU, {idx:bal.idx})
    dat.avo = bit.avoBit.dat;

    bal.slv({ supBit: { idx: "create-supernal", dat } });
    return cpy;
};



import { SupernalModel } from "../supernal.model";
import SupernalBit from "../fce/supernal.bit";
import State from "../../99.core/state";
import SuperBit from "../fce/super.bit";

import * as ActSup from "../../10.supernal.unit/supernal.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"


var bit, val, idx, dex, lst, dat, src;

export const initSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {
    debugger
    return cpy;
};




export const updateSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {
    return cpy;
};


export const readSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {

    if (bal.idx == null) bal.idx = 'sup00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActSup.CREATE_SUPERNAL })

    bal.slv({ spkBit: { idx: "read-spark", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {

    if ( bal.idx == null ) bal.idx ='spr00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActSup.CREATE_SUPERNAL })

    if (bal.slv != null) bal.slv({ spkBit: { idx: "write-spark", dat: bit.clcBit.dat } });
    return cpy;
};


export const removeSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {
    debugger
    return cpy;
};
export const deleteSupernal = async (cpy: SupernalModel, bal: SupernalBit, ste: State) => {
    debugger
    return cpy;
};



export default interface SuperBit {
    idx: string;
    src?: string;
    avo?: string;
}


export default interface SupernalBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  SupernalBit  from "./supernal.bit";

export default interface Supernal {
 // idx:string;
 // supernalBitList: SupernalBit[];
 // supernalBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SupernalBit  from "./fce/supernal.bit";

// Supernal actions

export const INIT_SUPERNAL = "[Supernal action] Init Supernal";
export class InitSupernal implements Action {
 readonly type = INIT_SUPERNAL;
 constructor(public bale: SupernalBit) {}
}

export const UPDATE_SUPERNAL = "[Supernal action] Update Supernal";
export class UpdateSupernal implements Action {
 readonly type = UPDATE_SUPERNAL;
 constructor(public bale: SupernalBit) {}
}

export const READ_SUPERNAL = "[Read action] Read Supernal";
 export class ReadSupernal implements Action {
 readonly type = READ_SUPERNAL;
 constructor(public bale: SupernalBit) {}
 }
 
export const WRITE_SUPERNAL = "[Write action] Write Supernal";
 export class WriteSupernal implements Action {
 readonly type = WRITE_SUPERNAL;
 constructor(public bale: SupernalBit) {}
 }
 
export const REMOVE_SUPERNAL = "[Remove action] Remove Supernal";
 export class RemoveSupernal implements Action {
 readonly type = REMOVE_SUPERNAL;
 constructor(public bale: SupernalBit) {}
 }
 
export const DELETE_SUPERNAL = "[Delete action] Delete Supernal";
 export class DeleteSupernal implements Action {
 readonly type = DELETE_SUPERNAL;
 constructor(public bale: SupernalBit) {}
 }
 
export const CREATE_SUPERNAL = "[Create action] Create Supernal";
 export class CreateSupernal implements Action {
 readonly type = CREATE_SUPERNAL;
 constructor(public bale: SupernalBit) {}
 }
 
export type Actions = | InitSupernal | UpdateSupernal 
| ReadSupernal
| WriteSupernal
| RemoveSupernal
| DeleteSupernal
| CreateSupernal
export { initSupernal  } from "./buz/supernal.buzz";
export { updateSupernal  } from "./buz/supernal.buzz";
export { readSupernal  } from "./buz/supernal.buzz";
export { writeSupernal  } from "./buz/supernal.buzz";
export { removeSupernal  } from "./buz/supernal.buzz";
export { deleteSupernal  } from "./buz/supernal.buzz";
export { createSupernal  } from "./buz/createSupernal.buzz";
import Supernal from "./fce/supernal.interface";
import SupernalBit from "./fce/supernal.interface";

export class SupernalModel implements Supernal {
 //idx:string;
 //supernalBitList: SupernalBit[] = [];
 //supernalBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./supernal.action";
import { SupernalModel } from "./supernal.model";
import * as Buzz from "./supernal.buzzer";
import State from "../99.core/state";

export function reducer(model: SupernalModel = new SupernalModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SUPERNAL:
 return Buzz.updateSupernal(clone(model), act.bale, state);

 case Act.INIT_SUPERNAL:
 return Buzz.initSupernal(clone(model), act.bale, state);

case Act.READ_SUPERNAL:
 return Buzz.readSupernal(clone(model), act.bale, state);
 
case Act.WRITE_SUPERNAL:
 return Buzz.writeSupernal(clone(model), act.bale, state);
 
case Act.REMOVE_SUPERNAL:
 return Buzz.removeSupernal(clone(model), act.bale, state);
 
case Act.DELETE_SUPERNAL:
 return Buzz.deleteSupernal(clone(model), act.bale, state);
 
case Act.CREATE_SUPERNAL:
 return Buzz.createSupernal(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SupernalUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  BlessedBit  from "./fce/blessed.bit";

// Blessed actions

export const INIT_BLESSED = "[Blessed action] Init Blessed";
export class InitBlessed implements Action {
 readonly type = INIT_BLESSED;
 constructor(public bale: BlessedBit) {}
}

export const UPDATE_BLESSED = "[Blessed action] Update Blessed";
export class UpdateBlessed implements Action {
 readonly type = UPDATE_BLESSED;
 constructor(public bale: BlessedBit) {}
}

export const READ_BLESSED = "[Read action] Read Blessed";
 export class ReadBlessed implements Action {
 readonly type = READ_BLESSED;
 constructor(public bale: BlessedBit) {}
 }
 
export const WRITE_BLESSED = "[Write action] Write Blessed";
 export class WriteBlessed implements Action {
 readonly type = WRITE_BLESSED;
 constructor(public bale: BlessedBit) {}
 }
 
export const REMOVE_BLESSED = "[Remove action] Remove Blessed";
 export class RemoveBlessed implements Action {
 readonly type = REMOVE_BLESSED;
 constructor(public bale: BlessedBit) {}
 }
 
export const DELETE_BLESSED = "[Delete action] Delete Blessed";
 export class DeleteBlessed implements Action {
 readonly type = DELETE_BLESSED;
 constructor(public bale: BlessedBit) {}
 }
 
export const CREATE_BLESSED = "[Create action] Create Blessed";
 export class CreateBlessed implements Action {
 readonly type = CREATE_BLESSED;
 constructor(public bale: BlessedBit) {}
 }
 
export type Actions = | InitBlessed | UpdateBlessed 
| ReadBlessed
| WriteBlessed
| RemoveBlessed
| DeleteBlessed
| CreateBlessed
export { initBlessed  } from "./buz/blessed.buzz";
export { updateBlessed  } from "./buz/blessed.buzz";
export { readBlessed  } from "./buz/blessed.buzz";
export { writeBlessed  } from "./buz/blessed.buzz";
export { removeBlessed  } from "./buz/blessed.buzz";
export { deleteBlessed  } from "./buz/blessed.buzz";
export { createBlessed  } from "./buz/createBlessed.buzz";
import Blessed from "./fce/blessed.interface";
import BlessedBit from "./fce/blessed.interface";

export class BlessedModel implements Blessed {
 //idx:string;
 //blessedBitList: BlessedBit[] = [];
 //blessedBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./blessed.action";
import { BlessedModel } from "./blessed.model";
import * as Buzz from "./blessed.buzzer";
import State from "../99.core/state";

export function reducer(model: BlessedModel = new BlessedModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BLESSED:
 return Buzz.updateBlessed(clone(model), act.bale, state);

 case Act.INIT_BLESSED:
 return Buzz.initBlessed(clone(model), act.bale, state);

case Act.READ_BLESSED:
 return Buzz.readBlessed(clone(model), act.bale, state);
 
case Act.WRITE_BLESSED:
 return Buzz.writeBlessed(clone(model), act.bale, state);
 
case Act.REMOVE_BLESSED:
 return Buzz.removeBlessed(clone(model), act.bale, state);
 
case Act.DELETE_BLESSED:
 return Buzz.deleteBlessed(clone(model), act.bale, state);
 
case Act.CREATE_BLESSED:
 return Buzz.createBlessed(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BlessedUnit {

 constructor(state: State) {
 }
}

import * as ActBls from "../../20.blessed.unit/blessed.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";


var bit, val, idx, dex, lst, dat, src;


export const initBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {
    debugger
    return cpy;
};


export const updateBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {
    return cpy;
};


export const readBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {

    if (bal.idx == null) bal.idx = 'bls00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActBls.CREATE_BLESSED })

    bal.slv({ blsBit: { idx: "read-blessed", dat: bit.clcBit.dat } });
    return cpy;

};

export const writeBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'bls00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActBls.CREATE_BLESSED })

    if (bal.slv != null) bal.slv({ blsBit: { idx: "write-blessed", dat: bit.clcBit.dat } });
    return cpy;


};


export const removeBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {
    debugger
    return cpy;
};
export const deleteBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {
    debugger
    return cpy;
};



import { BlessedModel } from "../blessed.model";
import BlessedBit from "../fce/blessed.bit";
import State from "../../99.core/state";
import BlessBit from "../fce/bless.bit";

import { BlessedModel } from "../blessed.model";
import BlessedBit from "../fce/blessed.bit";
import State from "../../99.core/state";
import BlessBit from "../fce/bless.bit";

import * as ActAvd from '../../06.avide.unit/avide.action'

import * as ActBls from "../../20.blessed.unit/blessed.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

var bit, val, idx, dex, lst, dat, src;


export const createBlessed = async (cpy: BlessedModel, bal: BlessedBit, ste: State) => {
    var dat: BlessBit = { idx: bal.idx, src: bal.src }

    bit = await ste.hunt( ActAvd.CREATE_AVIDE, {idx:bal.idx})
    dat.avd = bit.avdBit.dat;

    bal.slv({ blsBit: { idx: "create-blessed", dat } });
    return cpy;
};


import AvideBit from "010.sower/06.avide.unit/fce/avide.bit";

export default interface BlessBit {
    idx: string;
    src?: string;
    avd?: AvideBit;
}


export default interface BlessedBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  BlessedBit  from "./blessed.bit";

export default interface Blessed {
 // idx:string;
 // blessedBitList: BlessedBit[];
 // blessedBits:any;

}

import { PastoralModel } from "../pastoral.model";
import PastoralBit from "../fce/pastoral.bit";
import State from "../../99.core/state";
import PastureBit from "../fce/pasture.bit"; import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";


import * as ActAvo from '../../05.avaou.unit/avaou.action'

import * as ActPst from "../../30.pastoral.unit/pastoral.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActSpk from '../../03.spark.unit/spark.action'

var bit, val, idx, dex, lst, dat, src;

export const createPastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   var dat: PastureBit = { idx: bal.idx, src: bal.src }

   bit = await ste.hunt( ActAvo.CREATE_AVAOU, {idx:bal.idx})
   dat.avo = bit.avoBit.dat;

   bal.slv({ pasBit: { idx: "create-pastoral", dat } });
   return cpy;
};




import * as ActPst from "../../30.pastoral.unit/pastoral.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActSpk from '../../03.spark.unit/spark.action'

var bit, val, idx, dex, lst, dat, src;

export const initPastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   debugger
   return cpy;
};


export const updatePastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   return cpy;
};



export const readPastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   if (bal.idx == null) bal.idx = 'pst00';
   bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActPst.CREATE_PASTORAL })

   bal.slv({ pstBit: { idx: "read-pastoral", dat: bit.clcBit.dat } });
   return cpy;
};


export const writePastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {

   if (bal.idx == null) bal.idx = 'pas00'

   bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActPst.CREATE_PASTORAL })

   if (bal.slv != null) bal.slv({ pstBit: { idx: "write-pastoral", dat: bit.clcBit.dat } });
   return cpy;

};
export const removePastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   debugger
   return cpy;
};
export const deletePastoral = async (cpy: PastoralModel, bal: PastoralBit, ste: State) => {
   debugger
   return cpy;
};



import { PastoralModel } from "../pastoral.model";
import PastoralBit from "../fce/pastoral.bit";
import State from "../../99.core/state";
import PastureBit from "../fce/pasture.bit"; import OrbBit from "010.sower/03.spark.unit/fce/orb.bit";



export default interface PastoralBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  PastoralBit  from "./pastoral.bit";

export default interface Pastoral {
 // idx:string;
 // pastoralBitList: PastoralBit[];
 // pastoralBits:any;

}

import AvaouBit from "010.sower/05.avaou.unit/fce/avaou.bit";

export default interface PastureBit {
    idx: string;
    src?: string;
    avo?:AvaouBit
}

import { Action } from "../99.core/interface/action.interface";
import  PastoralBit  from "./fce/pastoral.bit";

// Pastoral actions

export const INIT_PASTORAL = "[Pastoral action] Init Pastoral";
export class InitPastoral implements Action {
 readonly type = INIT_PASTORAL;
 constructor(public bale: PastoralBit) {}
}

export const UPDATE_PASTORAL = "[Pastoral action] Update Pastoral";
export class UpdatePastoral implements Action {
 readonly type = UPDATE_PASTORAL;
 constructor(public bale: PastoralBit) {}
}

export const READ_PASTORAL = "[Read action] Read Pastoral";
 export class ReadPastoral implements Action {
 readonly type = READ_PASTORAL;
 constructor(public bale: PastoralBit) {}
 }
 
export const WRITE_PASTORAL = "[Write action] Write Pastoral";
 export class WritePastoral implements Action {
 readonly type = WRITE_PASTORAL;
 constructor(public bale: PastoralBit) {}
 }
 
export const REMOVE_PASTORAL = "[Remove action] Remove Pastoral";
 export class RemovePastoral implements Action {
 readonly type = REMOVE_PASTORAL;
 constructor(public bale: PastoralBit) {}
 }
 
export const DELETE_PASTORAL = "[Delete action] Delete Pastoral";
 export class DeletePastoral implements Action {
 readonly type = DELETE_PASTORAL;
 constructor(public bale: PastoralBit) {}
 }
 
export const CREATE_PASTORAL = "[Create action] Create Pastoral";
 export class CreatePastoral implements Action {
 readonly type = CREATE_PASTORAL;
 constructor(public bale: PastoralBit) {}
 }
 
export type Actions = | InitPastoral | UpdatePastoral 
| ReadPastoral
| WritePastoral
| RemovePastoral
| DeletePastoral
| CreatePastoral
export { initPastoral  } from "./buz/pastoral.buzz";
export { updatePastoral  } from "./buz/pastoral.buzz";
export { readPastoral  } from "./buz/pastoral.buzz";
export { writePastoral  } from "./buz/pastoral.buzz";
export { removePastoral  } from "./buz/pastoral.buzz";
export { deletePastoral  } from "./buz/pastoral.buzz";
export { createPastoral  } from "./buz/createPastoral.buzz";
import Pastoral from "./fce/pastoral.interface";
import PastoralBit from "./fce/pastoral.interface";

export class PastoralModel implements Pastoral {
 //idx:string;
 //pastoralBitList: PastoralBit[] = [];
 //pastoralBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./pastoral.action";
import { PastoralModel } from "./pastoral.model";
import * as Buzz from "./pastoral.buzzer";
import State from "../99.core/state";

export function reducer(model: PastoralModel = new PastoralModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_PASTORAL:
 return Buzz.updatePastoral(clone(model), act.bale, state);

 case Act.INIT_PASTORAL:
 return Buzz.initPastoral(clone(model), act.bale, state);

case Act.READ_PASTORAL:
 return Buzz.readPastoral(clone(model), act.bale, state);
 
case Act.WRITE_PASTORAL:
 return Buzz.writePastoral(clone(model), act.bale, state);
 
case Act.REMOVE_PASTORAL:
 return Buzz.removePastoral(clone(model), act.bale, state);
 
case Act.DELETE_PASTORAL:
 return Buzz.deletePastoral(clone(model), act.bale, state);
 
case Act.CREATE_PASTORAL:
 return Buzz.createPastoral(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class PastoralUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  BoundedBit  from "./fce/bounded.bit";

// Bounded actions

export const INIT_BOUNDED = "[Bounded action] Init Bounded";
export class InitBounded implements Action {
 readonly type = INIT_BOUNDED;
 constructor(public bale: BoundedBit) {}
}

export const UPDATE_BOUNDED = "[Bounded action] Update Bounded";
export class UpdateBounded implements Action {
 readonly type = UPDATE_BOUNDED;
 constructor(public bale: BoundedBit) {}
}

export const READ_BOUNDED = "[Read action] Read Bounded";
 export class ReadBounded implements Action {
 readonly type = READ_BOUNDED;
 constructor(public bale: BoundedBit) {}
 }
 
export const WRITE_BOUNDED = "[Write action] Write Bounded";
 export class WriteBounded implements Action {
 readonly type = WRITE_BOUNDED;
 constructor(public bale: BoundedBit) {}
 }
 
export const REMOVE_BOUNDED = "[Remove action] Remove Bounded";
 export class RemoveBounded implements Action {
 readonly type = REMOVE_BOUNDED;
 constructor(public bale: BoundedBit) {}
 }
 
export const DELETE_BOUNDED = "[Delete action] Delete Bounded";
 export class DeleteBounded implements Action {
 readonly type = DELETE_BOUNDED;
 constructor(public bale: BoundedBit) {}
 }
 
export const CREATE_BOUNDED = "[Create action] Create Bounded";
 export class CreateBounded implements Action {
 readonly type = CREATE_BOUNDED;
 constructor(public bale: BoundedBit) {}
 }
 
export type Actions = | InitBounded | UpdateBounded 
| ReadBounded
| WriteBounded
| RemoveBounded
| DeleteBounded
| CreateBounded
export { initBounded  } from "./buz/bounded.buzz";
export { updateBounded  } from "./buz/bounded.buzz";
export { readBounded  } from "./buz/bounded.buzz";
export { writeBounded  } from "./buz/bounded.buzz";
export { removeBounded  } from "./buz/bounded.buzz";
export { deleteBounded  } from "./buz/bounded.buzz";
export { createBounded  } from "./buz/createBounded.buzz";
import Bounded from "./fce/bounded.interface";
import BoundedBit from "./fce/bounded.interface";

export class BoundedModel implements Bounded {
 //idx:string;
 //boundedBitList: BoundedBit[] = [];
 //boundedBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./bounded.action";
import { BoundedModel } from "./bounded.model";
import * as Buzz from "./bounded.buzzer";
import State from "../99.core/state";

export function reducer(model: BoundedModel = new BoundedModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_BOUNDED:
            return Buzz.updateBounded(clone(model), act.bale, state);

        case Act.INIT_BOUNDED:
            return Buzz.initBounded(clone(model), act.bale, state);

        case Act.READ_BOUNDED:
            return Buzz.readBounded(clone(model), act.bale, state);

        case Act.WRITE_BOUNDED:
            return Buzz.writeBounded(clone(model), act.bale, state);

        case Act.REMOVE_BOUNDED:
            return Buzz.removeBounded(clone(model), act.bale, state);

        case Act.DELETE_BOUNDED:
            return Buzz.deleteBounded(clone(model), act.bale, state);

        case Act.CREATE_BOUNDED:
            return Buzz.createBounded(clone(model), act.bale, state);

        default:
            return model;
    }
}

import State from "../99.core/state";


export default class BoundedUnit {

 constructor(state: State) {
 }
}

import { BoundedModel } from "../bounded.model";
import BoundedBit from "../fce/bounded.bit";
import State from "../../99.core/state";
import BoundBit from "../fce/bound.bit";

import * as ActBnd from "../../40.bounded.unit/bounded.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"

var bit, val, idx, dex, lst, dat, src;

export const initBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {
    debugger
    return cpy;
};


export const updateBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {
    return cpy;
};


export const readBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {

    if (bal.idx == null) bal.idx = 'bnd00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActBnd.CREATE_BOUNDED })

    bal.slv({ bndBit: { idx: "read-bounded", dat: bit.clcBit.dat } });
    return cpy;

};

export const writeBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'bnd00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActBnd.CREATE_BOUNDED })

    if (bal.slv != null) bal.slv({ bndBit: { idx: "write-bounded", dat: bit.clcBit.dat } });
    return cpy;

};


export const removeBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {
    debugger
    return cpy;
};
export const deleteBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {
    debugger
    return cpy;
};



import { BoundedModel } from "../bounded.model";
import BoundedBit from "../fce/bounded.bit";
import State from "../../99.core/state";
import BoundBit from "../fce/bound.bit";

import * as ActAvd from '../../06.avide.unit/avide.action'

import * as ActBnd from "../../40.bounded.unit/bounded.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"

var bit, val, idx, dex, lst, dat, src;

export const createBounded = async (cpy: BoundedModel, bal: BoundedBit, ste: State) => {
    var dat: BoundBit = { idx: bal.idx, src: bal.src }

    bit = await ste.hunt( ActAvd.CREATE_AVIDE, {idx:bal.idx})
    dat.avd = bit.avdBit.dat;

    bal.slv({ bndBit: { idx: "create-bound", dat } });
    return cpy;
};


import AvideBit from "010.sower/06.avide.unit/fce/avide.bit";

export default interface BoundBit {
    idx: string;
    src?: string;
    avd?: AvideBit
}


export default interface BoundedBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  BoundedBit  from "./bounded.bit";

export default interface Bounded {
 // idx:string;
 // boundedBitList: BoundedBit[];
 // boundedBits:any;

}

import { PrimalModel } from "../primal.model";
import PrimalBit from "../fce/primal.bit";
import State from "../../99.core/state";
import PrimeBit from "../fce/prime.bit";

import * as ActAvo from '../../05.avaou.unit/avaou.action'

import * as ActPrm from "../../50.primal.unit/primal.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"

var bit, val, idx, dex, lst, dat, src;


export const createPrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    var dat: PrimeBit = { idx: bal.idx, src: bal.src }

    bit = await ste.hunt( ActAvo.CREATE_AVAOU, {idx:bal.idx})
    dat.avo = bit.avoBit.dat;
    
    bal.slv({ priBit: { idx: "create-primal", dat } });
    return cpy;
};

import * as ActPrm from "../../50.primal.unit/primal.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActVrt from "../../act/vurt.action"
import * as ActDsk from "../../act/disk.action"
import * as ActPvt from "../../act/pivot.action"


var bit, val, idx, dex, lst, dat, src;


export const initPrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    debugger
    return cpy;
};



export const updatePrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    return cpy;
};


export const readPrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'bnd00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActPrm.CREATE_PRIMAL })

    bal.slv({ priBit: { idx: "read-primal", dat: bit.clcBit.dat } });
    return cpy;
};

export const writePrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {

    if ( bal.idx == null ) bal.idx = 'prm00'

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActPrm.CREATE_PRIMAL })

    if (bal.slv != null) bal.slv({ priBit: { idx: "write-primal", dat: bit.clcBit.dat } });
    return cpy;
};


export const removePrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    debugger
    return cpy;
};
export const deletePrimal = async (cpy: PrimalModel, bal: PrimalBit, ste: State) => {
    debugger
    return cpy;
};



import { PrimalModel } from "../primal.model";
import PrimalBit from "../fce/primal.bit";
import State from "../../99.core/state";
import PrimeBit from "../fce/prime.bit";


export default interface PrimalBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  PrimalBit  from "./primal.bit";

export default interface Primal {
 // idx:string;
 // primalBitList: PrimalBit[];
 // primalBits:any;

}

import AvaouBit from "010.sower/05.avaou.unit/fce/avaou.bit";

export default interface PrimeBit {
    idx: string;
    src?: string;
    avo?: AvaouBit
}

import { Action } from "../99.core/interface/action.interface";
import  PrimalBit  from "./fce/primal.bit";

// Primal actions

export const INIT_PRIMAL = "[Primal action] Init Primal";
export class InitPrimal implements Action {
 readonly type = INIT_PRIMAL;
 constructor(public bale: PrimalBit) {}
}

export const UPDATE_PRIMAL = "[Primal action] Update Primal";
export class UpdatePrimal implements Action {
 readonly type = UPDATE_PRIMAL;
 constructor(public bale: PrimalBit) {}
}

export const READ_PRIMAL = "[Read action] Read Primal";
 export class ReadPrimal implements Action {
 readonly type = READ_PRIMAL;
 constructor(public bale: PrimalBit) {}
 }
 
export const WRITE_PRIMAL = "[Write action] Write Primal";
 export class WritePrimal implements Action {
 readonly type = WRITE_PRIMAL;
 constructor(public bale: PrimalBit) {}
 }
 
export const REMOVE_PRIMAL = "[Remove action] Remove Primal";
 export class RemovePrimal implements Action {
 readonly type = REMOVE_PRIMAL;
 constructor(public bale: PrimalBit) {}
 }
 
export const DELETE_PRIMAL = "[Delete action] Delete Primal";
 export class DeletePrimal implements Action {
 readonly type = DELETE_PRIMAL;
 constructor(public bale: PrimalBit) {}
 }
 
export const CREATE_PRIMAL = "[Create action] Create Primal";
 export class CreatePrimal implements Action {
 readonly type = CREATE_PRIMAL;
 constructor(public bale: PrimalBit) {}
 }
 
export type Actions = | InitPrimal | UpdatePrimal 
| ReadPrimal
| WritePrimal
| RemovePrimal
| DeletePrimal
| CreatePrimal
export { initPrimal  } from "./buz/primal.buzz";
export { updatePrimal  } from "./buz/primal.buzz";
export { readPrimal  } from "./buz/primal.buzz";
export { writePrimal  } from "./buz/primal.buzz";
export { removePrimal  } from "./buz/primal.buzz";
export { deletePrimal  } from "./buz/primal.buzz";
export { createPrimal  } from "./buz/createPrimal.buzz";
import Primal from "./fce/primal.interface";
import PrimalBit from "./fce/primal.interface";

export class PrimalModel implements Primal {
 //idx:string;
 //primalBitList: PrimalBit[] = [];
 //primalBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./primal.action";
import { PrimalModel } from "./primal.model";
import * as Buzz from "./primal.buzzer";
import State from "../99.core/state";

export function reducer(model: PrimalModel = new PrimalModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_PRIMAL:
 return Buzz.updatePrimal(clone(model), act.bale, state);

 case Act.INIT_PRIMAL:
 return Buzz.initPrimal(clone(model), act.bale, state);

case Act.READ_PRIMAL:
 return Buzz.readPrimal(clone(model), act.bale, state);
 
case Act.WRITE_PRIMAL:
 return Buzz.writePrimal(clone(model), act.bale, state);
 
case Act.REMOVE_PRIMAL:
 return Buzz.removePrimal(clone(model), act.bale, state);
 
case Act.DELETE_PRIMAL:
 return Buzz.deletePrimal(clone(model), act.bale, state);
 
case Act.CREATE_PRIMAL:
 return Buzz.createPrimal(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class PrimalUnit {

 constructor(state: State) {
 }
}


import * as ActPlr from "../player.action";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActBus from "../../99.bus.unit/bus.action";

var bit, val, idx, dex, lst, dat, src;


export const initPlayer = (cpy: PlayerModel, bal: PlayerBit, ste: State) => {
    debugger
    return cpy;
};


export const createPlayer = async (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    if (bal.dat == null) bal.dat = {}
    var dat: ChampBit = { idx: bal.idx };

    //const mapId = $dataSystem.startMapId;
    //const x = $dataSystem.startX;
    //const y = $dataSystem.startY;

    bal.slv({ plyBit: { idx: 'create-player', dat } });
    return cpy;
};

export const updatePlayer = async (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    bit = await ste.hunt(ActPlr.READ_PLAYER, { idx: bal.idx });
    dat = bit.plyBit;

    bal.slv({ plyBit: { idx: "update-player", dat } });
    return cpy;
};


export const readPlayer = async (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'ply00';

    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActPlr.CREATE_PLAYER });

    var item = bit.clcBit.dat;

    if (slv != null) slv({ plyBit: { idx: "read-player", dat: item } });
    return cpy;
};


export const writePlayer = async (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    var slv = bal.slv;

    if (bal.idx == null) bal.idx = 'ply00';

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActPlr.CREATE_PLAYER });
    var item = bit.clcBit.dat;

    if (bit.clcBit.val == 1) await ste.hunt(ActPlr.UPDATE_PLAYER, { idx: bal.idx, dat: bal.dat });

    if (slv != null) slv({ plyBit: { idx: "write-player", dat: item } });
    return cpy;

};
export const removePlayer = async (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActPlr.DELETE_PLAYER })
    if (bal.slv != null) bal.slv({ plyBit: { idx: "remove-player", dat: bit.clcBit } });

    return cpy;
};


export const deletePlayer = (cpy: PlayerModel, bal: PlayerBit, ste: State) => {
    debugger
    return cpy;
};


export const openPlayer = (cpy: PlayerModel, bal: PlayerBit, ste: State) => {

    return cpy;
};




import { PlayerModel } from "../player.model";
import PlayerBit from "../fce/player.bit";
import State from "../../99.core/state";
import ChampBit from "../fce/champ.bit";


export default interface ChampBit {
    idx: string;
}


export default interface PlayerBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
    bit?: any;
    lst?: any[];
}


import  PlayerBit  from "./player.bit";

export default interface Player {
 // idx:string;
 // playerBitList: PlayerBit[];
 // playerBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  PlayerBit  from "./fce/player.bit";

// Player actions

export const INIT_PLAYER = "[Player action] Init Player";
export class InitPlayer implements Action {
 readonly type = INIT_PLAYER;
 constructor(public bale: PlayerBit) {}
}

export const UPDATE_PLAYER = "[Player action] Update Player";
export class UpdatePlayer implements Action {
 readonly type = UPDATE_PLAYER;
 constructor(public bale: PlayerBit) {}
}

export const READ_PLAYER = "[Read action] Read Player";
 export class ReadPlayer implements Action {
 readonly type = READ_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export const WRITE_PLAYER = "[Write action] Write Player";
 export class WritePlayer implements Action {
 readonly type = WRITE_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export const REMOVE_PLAYER = "[Remove action] Remove Player";
 export class RemovePlayer implements Action {
 readonly type = REMOVE_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export const DELETE_PLAYER = "[Delete action] Delete Player";
 export class DeletePlayer implements Action {
 readonly type = DELETE_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export const CREATE_PLAYER = "[Create action] Create Player";
 export class CreatePlayer implements Action {
 readonly type = CREATE_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export const OPEN_PLAYER = "[Open action] Open Player";
 export class OpenPlayer implements Action {
 readonly type = OPEN_PLAYER;
 constructor(public bale: PlayerBit) {}
 }
 
export type Actions = | InitPlayer | UpdatePlayer 
| ReadPlayer
| WritePlayer
| RemovePlayer
| DeletePlayer
| CreatePlayer
| OpenPlayer
export { initPlayer  } from "./buz/player.buzz";
export { updatePlayer  } from "./buz/player.buzz";
export { readPlayer  } from "./buz/player.buzz";
export { writePlayer  } from "./buz/player.buzz";
export { removePlayer  } from "./buz/player.buzz";
export { deletePlayer  } from "./buz/player.buzz";
export { createPlayer  } from "./buz/player.buzz";
export { openPlayer  } from "./buz/player.buzz";
import Player from "./fce/player.interface";
import PlayerBit from "./fce/player.interface";

export class PlayerModel implements Player {
 //idx:string;
 //playerBitList: PlayerBit[] = [];
 //playerBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./player.action";
import { PlayerModel } from "./player.model";
import * as Buzz from "./player.buzzer";
import State from "../99.core/state";

export function reducer(model: PlayerModel = new PlayerModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_PLAYER:
 return Buzz.updatePlayer(clone(model), act.bale, state);

 case Act.INIT_PLAYER:
 return Buzz.initPlayer(clone(model), act.bale, state);

case Act.READ_PLAYER:
 return Buzz.readPlayer(clone(model), act.bale, state);
 
case Act.WRITE_PLAYER:
 return Buzz.writePlayer(clone(model), act.bale, state);
 
case Act.REMOVE_PLAYER:
 return Buzz.removePlayer(clone(model), act.bale, state);
 
case Act.DELETE_PLAYER:
 return Buzz.deletePlayer(clone(model), act.bale, state);
 
case Act.CREATE_PLAYER:
 return Buzz.createPlayer(clone(model), act.bale, state);
 
case Act.OPEN_PLAYER:
 return Buzz.openPlayer(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class PlayerUnit {

 constructor(state: State) {
 }
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
    type: string;
    bale?: T;
}

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
//# sourceMappingURL=action.interface.js.map
export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CANVAS = "[Canvas action] Init Canvas";
export const UPDATE_CANVAS = "[Canvas action] Update Canvas";
export const READ_CANVAS = "[Read action] Read Canvas";
export const WRITE_CANVAS = "[Write action] Write Canvas";
export const DELETE_CANVAS = "[Delete action] Delete Canvas";
export const REMOVE_CANVAS = "[Remove action] Remove Canvas";
export const CREATE_CANVAS = "[Create action] Create Canvas";
export const NEST_CANVAS = "[Nest action] Nest Canvas";
export const INIT_CHOICE = "[Choice action] Init Choice";
export const UPDATE_CHOICE = "[Choice action] Update Choice";
export const OPEN_CHOICE = "[Open action] Open Choice";
export const KEY_CHOICE = "[Key action] Key Choice";
export const TOWER_CHOICE = "[Tower action] Tower Choice";

export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";
export const INIT_DEPTH = "[Depth action] Init Depth";
export const UPDATE_DEPTH = "[Depth action] Update Depth";
export const OPEN_DEPTH = "[Depth action] Open Depth";
export const TEST_DEPTH = "[Test action] Test Depth";

export const INIT_DISK = '[Disk action] Init Disk'
export const UPDATE_DISK = '[Disk action] Update Disk'
export const READ_DISK = '[Disk action] Read Disk'
export const WRITE_DISK = '[Disk action] Write Disk'
export const INDEX_DISK = '[Index action] Index Disk'
export const LOAD_LIST_DISK = '[Load_list action] Load_list Disk'
export const COPY_DISK = '[Copy action] Copy Disk'
export const FRAME_DISK = '[Frame action] Frame Disk'
export const BATCH_DISK = '[Batch action] Batch Disk'
export const TRASH_DISK = '[Trash action] Trash Disk'
export const ENSURE_DISK = '[Ensure action] Ensure Disk'
export const DELETE_DISK = '[Delete action] Delete Disk'
export const INIT_ENGINE = "[Engine action] Init Engine";
export const UPDATE_ENGINE = "[Engine action] Update Engine";
export const MOVEMENT_ENGINE = "[Movement action] Movement Engine";
export const OPEN_ENGINE = "[Open action] Open Engine";
export const CLOSE_ENGINE = "[Close action] Close Engine";
 
export const INIT_FOCUS = "[Focus action] Init Focus";
export const AWAKE_FOCUS = "[Focus action] Awake Focus";
export const UPDATE_FOCUS = "[Focus action] Update Focus";
export const OPEN_FOCUS = "[Focus action] Open Focus";
export const CREATE_FOCUS = "[Focus action] Create Focus";
export const READ_FOCUS = "[Read action] Read Focus";
export const WRITE_FOCUS = "[Write action] Write Focus";
export const REMOVE_FOCUS = "[Remove action] Remove Focus";
export const DELETE_FOCUS = "[Delete action] Delete Focus";
export const CORNER_FOCUS = "[Corner action] Corner Focus";
export const LIST_FOCUS = "[List action] List Focus";
 export const SPIN_RIGHT_FOCUS = "[List action] Spin Left Focus";
 export const SPIN_LEFT_FOCUS = "[List action] Spin Right Focus";
 export const FORWARD_FOCUS = "[List action] Forward Focus";
 export const BACKWARD_FOCUS = "[List action] Backward Focus";
 export const CENTER_FOCUS = "[List action] Center Focus";
export const BOND_FOCUS = "[Bond action] Bond Focus";
export const LOCATE_FOCUS = "[Locate action] Locate Focus";
export const VISION_FOCUS = "[Vision action] Vision Focus";
export const SELECT_FOCUS = "[Select action] Select Focus";
 export const MODEL_FOCUS = "[Select action] Model Focus";
 export const BROWNIAN_FOCUS = "[Select action] Brownian Focus";
export const INIT_GEOJSON = '[Geojson action] Init Geojson';
export const UPDATE_GEOJSON = '[Geojson action] Update Geojson';
export const LOAD_GEOJSON = '[Load action] Load Geojson';
export const INDEX_GEOJSON = '[Index action] Index Geojson';
export const CAPTURE_GEOJSON = '[Capture action] Capture Geojson';
export const SAVE_GEOJSON = '[Save action] Save Geojson';

import { Action } from "../99.core/interface/action.interface";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const CREATE_GRAPHIC = "[Create action] Create Graphic";

export const INIT_GRID = "[Grid action] Init Grid";
export const UPDATE_GRID = "[Grid action] Update Grid";

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export const READ_HEXAGON = "[Read action] Read Hexagon"; 
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
export const INIT_HEXMAP = '[Hexmap action] Init Hexmap';
export const UPDATE_HEXMAP = '[Hexmap action] Update Hexmap';
export const OPEN_HEXMAP = '[Hexmap action] Open Hexmap';
export const READ_HEXMAP = '[Read action] Read Hexmap';
export const WRITE_HEXMAP = '[Write action] Write Hexmap';
export const CREATE_HEXMAP = '[Create action] Create Hexmap';
export const COPY_HEXMAP = '[Copy action] Copy Hexmap';
export const ATLAS_HEXMAP = '[Atlas action] Atlas Hexmap';
export const GEOJSON_HEXMAP = '[Geojson action] Geojson Hexmap';
export const TOOL_HEXMAP = '[Tool action] Tool Hexmap';
export const SAVE_HEXMAP = '[Save action] Save Hexmap';
export const STORE_HEXMAP = '[Store action] Store Hexmap';
export const SHAPE_HEXMAP = '[Shape action] Shape Hexmap';
export const LOAD_HEXMAP = '[Load action] Load Hexmap';
export const LIST_HEXMAP = '[List action] List Hexmap';
export const REPLACE_HEXMAP = '[Replace action] Replace Hexmap';
export const NAME_HEXMAP = '[Name action] Name Hexmap';
export const SEEK_HEXMAP = '[Seek action] Seek Hexmap';
export const FOCUSING_HEXMAP = '[Focusing action] Focusing Hexmap';
export const DEFOCUS_HEXMAP = '[Defocus action] Defocus Hexmap';
export const SELECT_HEXMAP = '[Select action] Select Hexmap';
export const ADD_HEXMAP = '[Select action] Add Hexmap';

export const INIT_INPUT = "[Input action] Init Input";
export const UPDATE_INPUT = "[Input action] Update Input";
export const OPEN_INPUT = "[Open action] Open Input";
export const INIT_OBS = "[Obs action] Init Obs";
export const UPDATE_OBS = "[Obs action] Update Obs";
export const OPEN_OBS = "[Open action] Open Obs";

export const INIT_OLLAMA = '[Ollama action] Init Ollama';
export const UPDATE_OLLAMA = '[Ollama action] Update Ollama';
export const WRITE_OLLAMA = '[Write action] Write Ollama';
export const INPUT_OLLAMA = '[Input action] Input Ollama';

export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_PROMPT = "[Prompt action] Init Prompt";
export const UPDATE_PROMPT = "[Prompt action] Update Prompt";
export const LIST_PROMPT = "[List action] List Prompt"; 
export const READ_PROMPT = "[Read action] Read Prompt";
export const WRITE_PROMPT = "[Write action] Write Prompt";

export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const READY_SPACE = "[Ready action] Ready Space";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const OPEN_TERMINAL = "[Terminal action] Open Terminal";
export const FOCUS_TERMINAL = "[Terminal action] Focus Terminal";
export const WRITE_TERMINAL = "[Terminal action] Write Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const CLEAR_TERMINAL = "[Terminal action] Clear Terminal";
export const INPUT_TERMINAL = "[Terminal action] Input Terminal";
export const TABLE_TERMINAL = "[Terminal action] Table Terminal";
export const CLOSE_TERMINAL = "[Terminal action] Close Terminal";
export const ROOT_TERMINAL = "[Terminal action] Root Terminal";
export const CONTENT_TERMINAL = "[Terminal action] Content Terminal";
export const ADD_PORT = "[Terminal action] Add Port";

export const INIT_VISAGE = "[Visage action] Init Visage";
export const UPDATE_VISAGE = "[Visage action] Update Visage";
export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage"; 
export const READ_VISAGE = "[Read action] Read Visage";
export const WRITE_VISAGE = "[Write action] Write Visage"; 
export const CREATE_VISAGE = "[Create action] Create Visage";
export const SIZE_VISAGE = "[Size action] Size Visage";
export const RENDER_VISAGE = "[Render action] Render Visage";
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import SowerUnit from "./00.sower.unit/sower.unit";
import SparkUnit from "./03.spark.unit/spark.unit";
import AmbitUnit from "./04.ambit.unit/ambit.unit";
import AvaouUnit from "./05.avaou.unit/avaou.unit";
import AvideUnit from "./06.avide.unit/avide.unit";
import ArtesUnit from "./07.artes.unit/artes.unit";
import SupernalUnit from "./10.supernal.unit/supernal.unit";
import BlessedUnit from "./20.blessed.unit/blessed.unit";
import PastoralUnit from "./30.pastoral.unit/pastoral.unit";
import BoundedUnit from "./40.bounded.unit/bounded.unit";
import PrimalUnit from "./50.primal.unit/primal.unit";
import PlayerUnit from "./90.player.unit/player.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Sower from "./00.sower.unit/fce/sower.interface";
import { SowerModel } from "./00.sower.unit/sower.model";
import Spark from "./03.spark.unit/fce/spark.interface";
import { SparkModel } from "./03.spark.unit/spark.model";
import Ambit from "./04.ambit.unit/fce/ambit.interface";
import { AmbitModel } from "./04.ambit.unit/ambit.model";
import Avaou from "./05.avaou.unit/fce/avaou.interface";
import { AvaouModel } from "./05.avaou.unit/avaou.model";
import Avide from "./06.avide.unit/fce/avide.interface";
import { AvideModel } from "./06.avide.unit/avide.model";
import Artes from "./07.artes.unit/fce/artes.interface";
import { ArtesModel } from "./07.artes.unit/artes.model";
import Supernal from "./10.supernal.unit/fce/supernal.interface";
import { SupernalModel } from "./10.supernal.unit/supernal.model";
import Blessed from "./20.blessed.unit/fce/blessed.interface";
import { BlessedModel } from "./20.blessed.unit/blessed.model";
import Pastoral from "./30.pastoral.unit/fce/pastoral.interface";
import { PastoralModel } from "./30.pastoral.unit/pastoral.model";
import Bounded from "./40.bounded.unit/fce/bounded.interface";
import { BoundedModel } from "./40.bounded.unit/bounded.model";
import Primal from "./50.primal.unit/fce/primal.interface";
import { PrimalModel } from "./50.primal.unit/primal.model";
import Player from "./90.player.unit/fce/player.interface";
import { PlayerModel } from "./90.player.unit/player.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [SowerUnit,SparkUnit,AmbitUnit,AvaouUnit,AvideUnit,ArtesUnit,SupernalUnit,BlessedUnit,PastoralUnit,BoundedUnit,PrimalUnit,PlayerUnit,CollectUnit,BusUnit];

import * as reduceFromSower from "./00.sower.unit/sower.reduce";
import * as reduceFromSpark from "./03.spark.unit/spark.reduce";
import * as reduceFromAmbit from "./04.ambit.unit/ambit.reduce";
import * as reduceFromAvaou from "./05.avaou.unit/avaou.reduce";
import * as reduceFromAvide from "./06.avide.unit/avide.reduce";
import * as reduceFromArtes from "./07.artes.unit/artes.reduce";
import * as reduceFromSupernal from "./10.supernal.unit/supernal.reduce";
import * as reduceFromBlessed from "./20.blessed.unit/blessed.reduce";
import * as reduceFromPastoral from "./30.pastoral.unit/pastoral.reduce";
import * as reduceFromBounded from "./40.bounded.unit/bounded.reduce";
import * as reduceFromPrimal from "./50.primal.unit/primal.reduce";
import * as reduceFromPlayer from "./90.player.unit/player.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 sower : reduceFromSower.reducer, 
spark : reduceFromSpark.reducer, 
ambit : reduceFromAmbit.reducer, 
avaou : reduceFromAvaou.reducer, 
avide : reduceFromAvide.reducer, 
artes : reduceFromArtes.reducer, 
supernal : reduceFromSupernal.reducer, 
blessed : reduceFromBlessed.reducer, 
pastoral : reduceFromPastoral.reducer, 
bounded : reduceFromBounded.reducer, 
primal : reduceFromPrimal.reducer, 
player : reduceFromPlayer.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 sower : Sower = new SowerModel();
spark : Spark = new SparkModel();
ambit : Ambit = new AmbitModel();
avaou : Avaou = new AvaouModel();
avide : Avide = new AvideModel();
artes : Artes = new ArtesModel();
supernal : Supernal = new SupernalModel();
blessed : Blessed = new BlessedModel();
pastoral : Pastoral = new PastoralModel();
bounded : Bounded = new BoundedModel();
primal : Primal = new PrimalModel();
player : Player = new PlayerModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
 hunt:null,
 bus:null,
 state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}


var host = (obj, typ) => {
 

 
 init();

 var slv;
 const promo = new Promise((rslv, rjct) => (slv = rslv));

 if (obj == null) obj = {};
 if (obj.slv == null) obj.slv = (val0) => slv(val0);
 
 sim.state.dispatch({ type: typ, bale: obj });
 return promo;
};

var init = () => {
 if (sim.state != null) return;
 sim.state = new State();
 sim.state.pivot = sim;
 sim.state.hunt = sim.hunt
 for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const VERTICAL = "vertical";
export const HORIZONTAL = "horizontal";



export const BLACK: string = "black";
export const RED: string = "red";
export const GREEN: string = "green";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";
export const CYAN: string = "cyan";
export const WHITE: string = "white";
export const BLUE: string = "blue";
"use strict";
exports.__esModule = true;
exports.CYAN = exports.MAGENTA = exports.YELLOW = exports.GREEN = exports.RED = void 0;
exports.RED = "\x1b[31m%s\x1b[0m";
exports.GREEN = "\x1b[32m%s\x1b[0m";
exports.YELLOW = "\x1b[33m%s\x1b[0m";
exports.MAGENTA = "\x1b[34m%s\x1b[0m";
exports.CYAN = "\x1b[36m%s\x1b[0m";
//# sourceMappingURL=console.js.map
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

"use strict";
exports.__esModule = true;
exports.WISE_NORTH_EAST = exports.WISE_NORTH = exports.WISE_NORTH_WEST = exports.WISE_WEST = exports.WISE_SOUTH_WEST = exports.WISE_SOUTH = exports.WISE_SOUTH_EAST = exports.WISE_EAST = exports.NORTH_EAST = exports.NORTH = exports.NORTH_WEST = exports.WEST = exports.SOUTH_WEST = exports.SOUTH = exports.SOUTH_EAST = exports.EAST = void 0;
exports.EAST = "E";
exports.SOUTH_EAST = "SE";
exports.SOUTH = "S";
exports.SOUTH_WEST = "SW";
exports.WEST = "W";
exports.NORTH_WEST = "NW";
exports.NORTH = "N";
exports.NORTH_EAST = "NE";
exports.WISE_EAST = "Wise E";
exports.WISE_SOUTH_EAST = "Wise SE";
exports.WISE_SOUTH = "Wise S";
exports.WISE_SOUTH_WEST = "Wise SW";
exports.WISE_WEST = "Wise W";
exports.WISE_NORTH_WEST = "Wise NW";
exports.WISE_NORTH = "Wise N";
exports.WISE_NORTH_EAST = "Wise NE";
//# sourceMappingURL=direction.js.map
export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
"use strict";
exports.__esModule = true;
exports.CIRCLE = exports.ROUNDED_RECTANGLE = exports.RECTANGLE = void 0;
exports.RECTANGLE = "rectangle";
exports.ROUNDED_RECTANGLE = "rounded-rectangle";
exports.CIRCLE = "circle";
//# sourceMappingURL=graphic.js.map
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export type Position <Type> = {
    x: number;
    y: number;
} & Type


export type GridFill =Position<{
    xSpan:number;
    ySpan:number;
}>

export const TOP_FULL_IDX = 'top-fill';
export const MID_FULL_IDX = 'mid-fill';
export const BOT_FULL_IDX  = 'bot-fill';

export const TOP_FULL_BIT:GridFill= {x:0, y:0, xSpan:12, ySpan:4};
export const MID_FULL_BIT:GridFill= {x:0, y:4, xSpan:12, ySpan:5};
export const BOT_FULL_BIT:GridFill= {x:0, y:8, xSpan:12, ySpan:4};

"use strict";
exports.__esModule = true;
exports.HEXMAP = exports.FOCUS = void 0;
exports.FOCUS = "focus";
exports.HEXMAP = "hexmap";
//# sourceMappingURL=hexagon.js.map
export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
"use strict";
exports.__esModule = true;
exports.PASTURE = exports.FANG_SWAMP = exports.GEORGIA = exports.GALLBLADDER = void 0;
exports.GALLBLADDER = "00000.gallbladder";
exports.GEORGIA = "00001.georgia";
exports.FANG_SWAMP = "00002.fang-swamp";
exports.PASTURE = "00003.pasture";
//# sourceMappingURL=hexmap.js.map
export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
"use strict";
exports.__esModule = true;
exports.MAGENTA = exports.YELLOW = exports.BLUE = exports.GREEN = exports.RED = exports.CYAN = exports.CLEAN = exports.MENU_SINGLE = exports.TIMELINE = exports.SPACE = void 0;
exports.SPACE = "space";
exports.TIMELINE = "timeline";
exports.MENU_SINGLE = "menu_single";
exports.CLEAN = "clean";
exports.CYAN = "cyan";
exports.RED = "red";
exports.GREEN = "green";
exports.BLUE = "blue";
exports.YELLOW = "yellow";
exports.MAGENTA = "magenta";
//# sourceMappingURL=markup.js.map
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

"use strict";
exports.__esModule = true;
exports.LOOP = exports.VIDEO = exports.HEXAGON = exports.SPRITE = exports.TEXT = exports.GRAPHIC = exports.CONTAINER = exports.SURFACE = exports.VISAGE = void 0;
exports.VISAGE = "visage";
exports.SURFACE = "surface";
exports.CONTAINER = "container";
exports.GRAPHIC = "graphic";
exports.TEXT = "text";
exports.SPRITE = "sprite";
exports.HEXAGON = "hexagon";
exports.VIDEO = "video";
exports.LOOP = "loop";
//# sourceMappingURL=shade.js.map
export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
export const GEOJSON = "geojson";
export const RECTANGLE = "rectangle";
export const TRIANGLE = "triangle";
export const HEXAGON = "hexagon";
export const PARALLELOGRAM = "parallelogram";

export const FOCUS = "focus";
export const HEXMAP = "hexmap";
export const CLOCK: string = "clock";
"use strict";
exports.__esModule = true;
exports.MOUNT_WIDTH = exports.MOUNT_HEIGHT = exports.MOUNT_PART = exports.MOUNT_FULL = exports.SCREEN = void 0;
exports.SCREEN = "screen-visage";
exports.MOUNT_FULL = "mount-visage-full";
exports.MOUNT_PART = "mount-visage-part";
exports.MOUNT_HEIGHT = "mount-visage-height";
exports.MOUNT_WIDTH = "mount-visage-width";
//# sourceMappingURL=visage.js.map
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";
import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action";
import * as ActSrf from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActFcg from "../../08.focigon.unit/focigon.action";

import * as ActVid from "../../11.video.unit/video.action";
import * as ActTun from "../../10.toon.unit/toon.action";
import * as ActSpc from "../../act/space.action"

import * as ActPvt from "../../act/pivot.action";
import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";

import * as ActCns from "../../act/console.action";



var bit, val, idx, dex, lst, dat, src;

var once = false

export const initShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {

    if (once == true) return

    once = true

    if (bal.dat != null) bit = await ste.hunt(ActBus.INIT_BUS, { idx: cpy.idx, lst: [ActShd, ActVsg, ActSrf, ActCan, ActGph, ActTxt, ActSpr, ActHex, ActVid, ActTun], dat: bal.dat, src: bal.src })

    if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, bal);

    //ste.bus(ActSpc.READY_SPACE, {})

    if (bal.slv != null) bal.slv({ intBit: { idx: "init-shade" } });

    return cpy;
};

export const openShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {

    var batch;

    const { spawn } = require('child_process');
    const path = require('path');



    // Simulate some work
    //setTimeout(() => {
    //  console.log('Work completed.');
    //  process.exit(0); // Exit with success code
    //}, 10000);

    function launchBatchFile(userInputPath) {
        const sanitizedPath = path.normalize(userInputPath); // Sanitize the path

        batch = spawn('cmd', ['/c', sanitizedPath]);

        batch.stdout.on('data', async (data) => {
            bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: `stdout: ${data}` })
        });

        batch.stderr.on('data', async (data) => {
            bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: `stderr: ${data}` })
        });

        batch.on('close', async (code) => {
            console.log();
            bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: `child process exited with code ${code}` })
            //FS.emptyDir( dest, ()=>{
            //  FS.copySync('./dist/win-unpacked/' , dest )
            //})


        });

    }

    launchBatchFile(process.env.SHADE_BAT);

    bal.slv({ shdBit: { idx: "open-shade", dat: {} } });

    return cpy;
};

export const runShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {


    setTimeout(() => {
        if (bal.slv != null) bal.slv({ shdBit: { idx: "run-shade" } });
    })

    return cpy;
};


export const browserShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {


    setTimeout(() => {
        if (bal.slv != null) bal.slv({ shdBit: { idx: "browser-shade" } });
    }, 33)

    return cpy;
};

export const updateShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {



    var unitList = [
        '00.shade.unit',
        '02.surface.unit',
        '03.container.unit',
        '04.graphic.unit',
        '05.text.unit',
        '06.sprite.unit',
        '07.hexagon.unit',
        '08.focigon.unit',
        '09.loop.unit',
        '10.toon.unit',
        '11.video.unit',
        '12.frame.unit',
        '13.camera.unit',
        '21.visage.unit',
        '24.chrome.unit',
    ]

    const path = require('path');
    var FS = require('fs-extra')

    var containers = FS.readdirSync('../')

    containers = containers.map(dirName => "../" + dirName);
    containers = containers.filter(dirName => dirName !== "../110.shade");

    function isDirectorySync(path) {
        if (!FS.existsSync(path)) {
            return false; // Path doesn't exist
        }

        const stats = FS.lstatSync(path);
        return stats.isDirectory();
    }


    var check = []

    containers.forEach((a) => {

        if (isDirectorySync(a) == false) return
        check.push(a)

    })

    check
    var yes = []

    check.forEach((a) => {

        var looking = FS.readdirSync(a)

        looking.forEach((b) => {
            if (b != '110.shade') return
            yes.push(a)
        })

    })

    yes
    debugger

    yes.forEach((a, b) => {

        var remove = a + '/110.shade'
        //FS.removeSync(remove);

        bit = ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'removing --- ' + remove })

        unitList.forEach((c) => {

            var dest = a + ''

            var source = './110.shade/' + c;
            var output = a + '/110.shade/' + c

            bit = ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: source + ' --- ' + output })

            FS.copySync(source, output);

        })
    })


    bal.slv({ shdBit: { idx: "update-shade" } });


    return cpy;
};

export const bodyShade = (cpy: ShadeModel, bal: ShadeBit, ste: State) => {


    if (bal.slv != null) bal.slv({ shdBit: { idx: "body-shade", src: bal.src } });

    return cpy;
};


export const editShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {


    if (bal.slv != null) bal.slv({ symBit: { idx: "edit-symbol", dat: {} } });

    return cpy;
};

export const patchShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {

    bit = await ste.bus(ActDsk.COPY_DISK, { src: '../gillisse/src', idx: './source' })
    if (bal.slv != null) bal.slv({ symBit: { idx: "edit-symbol", dat: {} } });

    return cpy;
};


export const testShade = async (cpy: ShadeModel, bal: ShadeBit, ste: State) => {

    if (bal.slv != null) bal.slv({ shdBit: { idx: "test-shade", dat: {} } });


    return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

import { ShadeModel } from "../shade.model";
import ShadeBit from "../fce/shade.bit";
import State from "../../99.core/state";
import * as doT from "dot";


export default interface ShadeBit {
 idx:string;
 src?:string;
 val?:number;
 dat?:any;
 slv?:Function;
}


import  ShadeBit  from "./shade.bit";

export default interface Shade {
 // idx:string;
 // shadeBitList: ShadeBit[];
 // shadeBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  ShadeBit  from "./fce/shade.bit";

// Shade actions

export const INIT_SHADE = "[Shade action] Init Shade";
export class InitShade implements Action {
 readonly type = INIT_SHADE;
 constructor(public bale: ShadeBit) {}
}

export const UPDATE_SHADE = "[Shade action] Update Shade";
export class UpdateShade implements Action {
 readonly type = UPDATE_SHADE;
 constructor(public bale: ShadeBit) {}
}

export const OPEN_SHADE = "[Open action] Open Shade";
 export class OpenShade implements Action {
 readonly type = OPEN_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const BODY_SHADE = "[Body action] Body Shade";
 export class BodyShade implements Action {
 readonly type = BODY_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const BROWSER_SHADE = "[Browser action] Browser Shade";
 export class BrowserShade implements Action {
 readonly type = BROWSER_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const RUN_SHADE = "[Run action] Run Shade";
 export class RunShade implements Action {
 readonly type = RUN_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const EDIT_SHADE = "[Edit action] Edit Shade";
 export class EditShade implements Action {
 readonly type = EDIT_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const PATCH_SHADE = "[Patch action] Patch Shade";
 export class PatchShade implements Action {
 readonly type = PATCH_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export const TEST_SHADE = "[Test action] Test Shade";
 export class TestShade implements Action {
 readonly type = TEST_SHADE;
 constructor(public bale: ShadeBit) {}
 }
 
export type Actions = | InitShade | UpdateShade 
| OpenShade
| BodyShade
| BrowserShade
| RunShade
| EditShade
| PatchShade
| TestShade
export { initShade  } from "./buz/shade.buzz";
export { updateShade  } from "./buz/shade.buzz";
export { openShade  } from "./buz/shade.buzz";
export { bodyShade  } from "./buz/shade.buzz";
export { browserShade  } from "./buz/shade.buzz";
export { runShade  } from "./buz/shade.buzz";
export { editShade  } from "./buz/shade.buzz";
export { patchShade  } from "./buz/shade.buzz";
export { testShade  } from "./buz/shade.buzz";
import Shade from "./fce/shade.interface";
import ShadeBit from "./fce/shade.interface";

export class ShadeModel implements Shade {
 idx:string = '110.shade';
 //shadeBitList: ShadeBit[] = [];
 //shadeBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./shade.action";
import { ShadeModel } from "./shade.model";
import * as Buzz from "./shade.buzzer";
import State from "../99.core/state";

export function reducer(model: ShadeModel = new ShadeModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SHADE:
 return Buzz.updateShade(clone(model), act.bale, state);

 case Act.INIT_SHADE:
 return Buzz.initShade(clone(model), act.bale, state);

case Act.OPEN_SHADE:
 return Buzz.openShade(clone(model), act.bale, state);
 
case Act.BODY_SHADE:
 return Buzz.bodyShade(clone(model), act.bale, state);
 
case Act.BROWSER_SHADE:
 return Buzz.browserShade(clone(model), act.bale, state);
 
case Act.RUN_SHADE:
 return Buzz.runShade(clone(model), act.bale, state);
 
case Act.EDIT_SHADE:
 return Buzz.editShade(clone(model), act.bale, state);
 
case Act.PATCH_SHADE:
 return Buzz.patchShade(clone(model), act.bale, state);
 
case Act.TEST_SHADE:
 return Buzz.testShade(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ShadeUnit {

    constructor(state: State) {
    }
}

window.SHADE = require("../dist/110.shade/hunt");

window.MQTT = require("async-mqtt");

window.SHADE.ActShd = require("../dist/110.shade/00.shade.unit/shade.action");
window.SHADE.ActVsg = require("../dist/110.shade/01.visage.unit/visage.action");
window.SHADE.ActCan = require("../dist/110.shade/03.container.unit/container.action");
window.SHADE.ActGph = require("../dist/110.shade/04.graphic.unit/graphic.action");
window.SHADE.ActTxt = require("../dist/110.shade/05.text.unit/text.action");
window.SHADE.ActSpr = require("../dist/110.shade/06.sprite.unit/sprite.action");
window.SHADE.ActHex = require("../dist/110.shade/07.hexagon.unit/hexagon.action");
window.SHADE.ActFcg = require("../dist/110.shade/08.focigon.unit/focigon.action");
window.SHADE.ActLop = require("../dist/110.shade/09.loop.unit/loop.action");
window.SHADE.ActTun = require("../dist/110.shade/10.toon.unit/toon.action");
window.SHADE.ActVid = require("../dist/110.shade/11.video.unit/video.action");
window.SHADE.ActFme = require("../dist/110.shade/12.frame.unit/frame.action");


import { SurfaceModel } from "../surface.model";
import SurfaceBit from "../fce/surface.bit";
import State from "../../99.core/state";
import StageBit from "../fce/stage.bit";

import { Application, Assets, Container, Sprite } from 'pixi.js';

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";

var bit, val, idx, dex, lst, dat;

var testing = false;

export const initSurface = (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    return cpy;
};

export const createSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    if (bal.dat == null) bal.dat = {}

    if (bal.dat.src == null) bal.dat.src = 'indexCanvas'

    var dat: StageBit = { idx: bal.idx, src: bal.dat.src, bit: null };
    dat.bit = new Application();

    bal.slv({ fceBit: { idx: "create-surface", dat } });
    return cpy;
};


export const updateSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    var idx = bal.idx;

    bit = await ste.hunt(ActFce.READ_SURFACE, { idx: bal.idx })
    dat = bit.fceBit.dat;

    var app = dat.bit;

    if (app == null) return bal.slv({ fceBit: { idx: "error-update-surface" } });

    //app.renderer.resize(dat.width, dat.height);

    return cpy;
};


export const readSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'fce00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActFce.CREATE_SURFACE })
    if (slv != null) slv({ fceBit: { idx: "read-surface", dat: bit.clcBit.dat } });
    return cpy;

};
export const writeSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActFce.CREATE_SURFACE })
    ste.hunt(ActFce.UPDATE_SURFACE, { idx: bal.idx })

    if (bal.slv != null) bal.slv({ fceBit: { idx: "write-surface", dat: bit.clcBit.dat } });

    return cpy;
};


export const removeSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-create-visage", dat: {} } });

    //gotcha-- making sure that the src is present on the collect bale once caused a tremendous issue
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFce.DELETE_SURFACE })

    if (bal.slv != null) bal.slv({ fceBit: { idx: "remove-surface", dat: bit.clcBit } });

    return cpy;
}


export const deleteSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    bit = await ste.hunt(ActFce.READ_SURFACE, { idx: bal.idx })
    dat = bit.fceBit.dat

    var app = dat.bit;
    app.destroy()

    if (bal.slv != null) return bal.slv({ fceBit: { idx: "delete-surface", dat } });

    return cpy;
};


export const dimensionSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    var idx = bal.idx;
    bit = await ste.hunt(ActFce.READ_SURFACE, { idx: bal.idx })

    if (bal.slv != null) return bal.slv({ fceBit: { idx: "dimension-surface", dat: bal.dat } });

    return cpy;
};


export const extractSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    var idx = bal.idx;
    bit = await ste.hunt(ActFce.READ_SURFACE, { idx })

    dat = bit.fceBit.dat

    var app = dat.bit;
    var canvas = app.renderer.plugins.extract.canvas();
    const context = canvas.getContext('2d');
    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

    if (bal.slv != null) return bal.slv({ fceBit: { idx: "extract-surface", dat: imgData } });

    return cpy;
};


export const listSurface = async (cpy: SurfaceModel, bal: SurfaceBit, ste: State) => {

    dat = null

    bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActFce.CREATE_SURFACE })


    if (bit.clcBit.dat == null) lst = []
    else dat = bit.clcBit.dat;

    dat


    if (dat != null) {

        lst = []

        dat.bitList.forEach((a) => {

            lst.push((a.idx))
        })
    }

    lst





    //process.chdir("../002.space")

    //src = cpy.hexmapLoc
    //bit = await ste.bus(ActDsk.LIST_DISK, { idx: null, src })

    //lst = bit.dskBit.lst

    //if (bal.idx != null) process.chdir(bal.idx)

    
    //var dex = lst.length()

    bal.slv({ fceBit: { idx: "list-surface", lst} });



    return cpy;
};





import * as PIXI from "pixi.js";

export default interface StageBit {
    idx: string;
    src?: string;
    clr?: string;
    width?: number;
    height?: number;
    dex?: number;
    bit?: PIXI.Application | null;
}


export default interface SurfaceBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
    bit?:any;
}


import  SurfaceBit  from "./surface.bit";

export default interface Surface {
 // idx:string;
 // surfaceBitList: SurfaceBit[];
 // surfaceBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SurfaceBit  from "./fce/surface.bit";

// Surface actions

export const INIT_SURFACE = "[Surface action] Init Surface";
export class InitSurface implements Action {
 readonly type = INIT_SURFACE;
 constructor(public bale: SurfaceBit) {}
}

export const UPDATE_SURFACE = "[Surface action] Update Surface";
export class UpdateSurface implements Action {
 readonly type = UPDATE_SURFACE;
 constructor(public bale: SurfaceBit) {}
}

export const READ_SURFACE = "[Read action] Read Surface";
 export class ReadSurface implements Action {
 readonly type = READ_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const WRITE_SURFACE = "[Write action] Write Surface";
 export class WriteSurface implements Action {
 readonly type = WRITE_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }

 export const REMOVE_SURFACE = "[Write action] Remove Surface";
 export class RemoveSurface implements Action {
 readonly type = REMOVE_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const CREATE_SURFACE = "[Create action] Create Surface";
 export class CreateSurface implements Action {
 readonly type = CREATE_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const DIMENSION_SURFACE = "[Dimension action] Dimension Surface";
 export class DimensionSurface implements Action {
 readonly type = DIMENSION_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const DELETE_SURFACE = "[Delete action] Delete Surface";
 export class DeleteSurface implements Action {
 readonly type = DELETE_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const EXTRACT_SURFACE = "[Extract action] Extract Surface";
 export class ExtractSurface implements Action {
 readonly type = EXTRACT_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export const LIST_SURFACE = "[List action] List Surface";
 export class ListSurface implements Action {
 readonly type = LIST_SURFACE;
 constructor(public bale: SurfaceBit) {}
 }
 
export type Actions = | InitSurface | UpdateSurface 
| ReadSurface
| WriteSurface
| CreateSurface
| DimensionSurface
| DeleteSurface
| RemoveSurface
| ExtractSurface
| ListSurface
export { initSurface  } from "./buz/surface.buzz";
export { updateSurface  } from "./buz/surface.buzz";
export { readSurface  } from "./buz/surface.buzz";
export { writeSurface  } from "./buz/surface.buzz";
export { createSurface  } from "./buz/surface.buzz";
export { dimensionSurface  } from "./buz/surface.buzz";
export { deleteSurface  } from "./buz/surface.buzz";
export { removeSurface  } from "./buz/surface.buzz";
export { extractSurface  } from "./buz/surface.buzz";
export { listSurface  } from "./buz/surface.buzz";
import Surface from "./fce/surface.interface";
import SurfaceBit from "./fce/surface.interface";

export class SurfaceModel implements Surface {
 //idx:string;
 //surfaceBitList: SurfaceBit[] = [];
 //surfaceBits: any = {};
 stageContainerIDX:string = 'stageContainer'
}

import * as clone from "clone-deep";
import * as Act from "./surface.action";
import { SurfaceModel } from "./surface.model";
import * as Buzz from "./surface.buzzer";
import State from "../99.core/state";

export function reducer(model: SurfaceModel = new SurfaceModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_SURFACE:
            return Buzz.updateSurface(clone(model), act.bale, state);

        case Act.INIT_SURFACE:
            return Buzz.initSurface(clone(model), act.bale, state);

        case Act.READ_SURFACE:
            return Buzz.readSurface(clone(model), act.bale, state);

        case Act.WRITE_SURFACE:
            return Buzz.writeSurface(clone(model), act.bale, state);

        case Act.CREATE_SURFACE:
            return Buzz.createSurface(clone(model), act.bale, state);

        case Act.DIMENSION_SURFACE:
            return Buzz.dimensionSurface(clone(model), act.bale, state);

        case Act.DELETE_SURFACE:
            return Buzz.deleteSurface(clone(model), act.bale, state);

        case Act.REMOVE_SURFACE:
            return Buzz.removeSurface(clone(model), act.bale, state);

case Act.EXTRACT_SURFACE:
 return Buzz.extractSurface(clone(model), act.bale, state);
 
case Act.LIST_SURFACE:
 return Buzz.listSurface(clone(model), act.bale, state);
 
        default:
            return model;
    }
}

import State from "../99.core/state";


export default class SurfaceUnit {

    constructor(state: State) {
    }
}


import { ContainerModel } from "../container.model";
import ContainerBit from "../fce/container.bit";
import State from "../../99.core/state";
import CanBit from "../fce/can.bit";
import * as SHADE from '../../val/shade'
import * as PIXI from "pixi.js";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const initContainer = (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    return cpy;
};

export const updateContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.idx })
    dat = bit.canBit.dat

    var can: PIXI.Container = dat.bit;

    can.x = dat.x;
    can.y = dat.y;

    if (bal.slv != null) return bal.slv({ canBit: { idx: "update-container", dat } });
    return cpy;
};

export const readContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {
    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActCan.CREATE_CONTAINER })
    if (slv != null) slv({ canBit: { idx: "read-container", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-write-container", dat: {} } });

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActCan.CREATE_CONTAINER })
    ste.hunt(ActCan.UPDATE_CONTAINER, { idx: bal.idx })

    if (bal.slv != null) bal.slv({ canBit: { idx: "write-container", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActCan.DELETE_CONTAINER })
    if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-container", dat: bit.clcBit } });

    return cpy;
};

export const createContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-create-container", dat: {} } });

    //you have a source visage
    //now you wish to update a bit of the source visage
    var dat: CanBit = { idx: bal.idx, src: bal.src, typ: SHADE.CONTAINER, x: 0, y: 0 };

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }

    try {
        dat.bit = new PIXI.Container();
    } catch (e) {
        dat.dat = {};
    }

    console.log("nesting " + JSON.stringify(dat.typ))

    // if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

    if (bal.slv != null) return bal.slv({ canBit: { idx: "create-container", dat } });

    return cpy;
};

export const deleteContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-delete-container", dat: {} } });

    bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.idx })
    var dat: CanBit = bit.canBit.dat

    var container = dat.bit;
    container.destroy()
    dat.bit = null

    if (bal.slv != null) return bal.slv({ vsgBit: { idx: "delete-container", dat } });
    return cpy;
};



export const surfaceContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    bit = await ste.hunt(ActFce.READ_SURFACE, { idx: bal.src })
    var app = bit.fceBit.dat.bit;
    var stage = app.stage;

    bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.idx })
    var can = bit.canBit.dat.bit;
    stage.addChild(can)

    //var graphic = new PIXI.Graphics();
    //graphic.lineStyle(3, dat.clr);
    //graphic.drawRect(0, 0, 25, 1080);
    //can.addChild( graphic)

    if (bal.slv != null) return bal.slv({ canBit: { idx: "surface-container", dat: bal } });

    return cpy;
};


export const addContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    var content = bal.dat.bit;
    if (bit == null) return bal.slv({ canBit: { idx: "add-container-error", dat: bal } });

    bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.idx })
    var can = bit.canBit.dat.bit;

    if (can == null) {
        return bal.slv({ canBit: { idx: "add-container-error", dat: {} } });
    }

    can.addChild(content)

    //var graphic = new PIXI.Graphics();
    //graphic.lineStyle(3, 0x00FF00);
    //graphic.drawRect(0, 720, 720, 1080);
    //content.addChild( graphic)

    if (bal.slv != null) return bal.slv({ canBit: { idx: "add-container", dat: bal } });
    return cpy;
};

export const listContainer = async (cpy: ContainerModel, bal: ContainerBit, ste: State) => {

    //if (typeof window != "object") return bal.slv({ canBit: { idx: "error-list-container", dat: {} } });

    debugger

    dat = null

    if (bal.src == 'bus') bit = await ste.bus(ActCol.FETCH_COLLECT, { val: 0, bit: ActCan.CREATE_CONTAINER })
    else bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActCan.CREATE_CONTAINER })

    if (bit.clcBit.dat == null) lst = []
    else dat = bit.clcBit.dat;

    if (dat != null) {

        dat.bitList.forEach((a) => {
            lst = []
            lst.push((a.idx))
        })

        lst
    }

    if (bal.slv != null) bal.slv({ canBit: { idx: 'list-container', lst } });


    return cpy;
};




import { Action } from "../99.core/interface/action.interface";
import  ContainerBit  from "./fce/container.bit";

// Container actions

export const INIT_CONTAINER = "[Container action] Init Container";
export class InitContainer implements Action {
 readonly type = INIT_CONTAINER;
 constructor(public bale: ContainerBit) {}
}

export const UPDATE_CONTAINER = "[Container action] Update Container";
export class UpdateContainer implements Action {
 readonly type = UPDATE_CONTAINER;
 constructor(public bale: ContainerBit) {}
}

export const READ_CONTAINER = "[Read action] Read Container";
 export class ReadContainer implements Action {
 readonly type = READ_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const WRITE_CONTAINER = "[Write action] Write Container";
 export class WriteContainer implements Action {
 readonly type = WRITE_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const CREATE_CONTAINER = "[Create action] Create Container";
 export class CreateContainer implements Action {
 readonly type = CREATE_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const SURFACE_CONTAINER = "[Surface action] Surface Container";
 export class SurfaceContainer implements Action {
 readonly type = SURFACE_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const ADD_CONTAINER = "[Add action] Add Container";
 export class AddContainer implements Action {
 readonly type = ADD_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const REMOVE_CONTAINER = "[Remove action] Remove Container";
 export class RemoveContainer implements Action {
 readonly type = REMOVE_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const DELETE_CONTAINER = "[Delete action] Delete Container";
 export class DeleteContainer implements Action {
 readonly type = DELETE_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export const LIST_CONTAINER = "[List action] List Container";
 export class ListContainer implements Action {
 readonly type = LIST_CONTAINER;
 constructor(public bale: ContainerBit) {}
 }
 
export type Actions = | InitContainer | UpdateContainer 
| ReadContainer
| WriteContainer
| CreateContainer
| SurfaceContainer
| AddContainer
| RemoveContainer
| DeleteContainer
| ListContainer
export { initContainer  } from "./buz/container.buzz";
export { updateContainer  } from "./buz/container.buzz";
export { readContainer  } from "./buz/container.buzz";
export { writeContainer  } from "./buz/container.buzz";
export { createContainer  } from "./buz/container.buzz";
export { surfaceContainer  } from "./buz/container.buzz";
export { addContainer  } from "./buz/container.buzz";
export { removeContainer  } from "./buz/container.buzz";
export { deleteContainer  } from "./buz/container.buzz";
export { listContainer  } from "./buz/container.buzz";
import Container from "./fce/container.interface";
import ContainerBit from "./fce/container.interface";

export class ContainerModel implements Container {
 //idx:string;
 //containerBitList: ContainerBit[] = [];
 //containerBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./container.action";
import { ContainerModel } from "./container.model";
import * as Buzz from "./container.buzzer";
import State from "../99.core/state";

export function reducer(model: ContainerModel = new ContainerModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CONTAINER:
 return Buzz.updateContainer(clone(model), act.bale, state);

 case Act.INIT_CONTAINER:
 return Buzz.initContainer(clone(model), act.bale, state);

case Act.READ_CONTAINER:
 return Buzz.readContainer(clone(model), act.bale, state);
 
case Act.WRITE_CONTAINER:
 return Buzz.writeContainer(clone(model), act.bale, state);
 
case Act.CREATE_CONTAINER:
 return Buzz.createContainer(clone(model), act.bale, state);
 
case Act.SURFACE_CONTAINER:
 return Buzz.surfaceContainer(clone(model), act.bale, state);
 
case Act.ADD_CONTAINER:
 return Buzz.addContainer(clone(model), act.bale, state);
 
case Act.REMOVE_CONTAINER:
 return Buzz.removeContainer(clone(model), act.bale, state);
 
case Act.DELETE_CONTAINER:
 return Buzz.deleteContainer(clone(model), act.bale, state);
 
case Act.LIST_CONTAINER:
 return Buzz.listContainer(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class ContainerUnit {

    constructor(state: State) {
    }
}

import * as PIXI from 'pixi.js';

export default interface CanBit {
    idx:string;
    src?:string;
    typ?:string;
    x:number;
    y:number
    
    val?:number;
    dat?:any;
    bit?:PIXI.Container;
}


export default interface ContainerBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  ContainerBit  from "./container.bit";

export default interface Container {
 // idx:string;
 // containerBitList: ContainerBit[];
 // containerBits:any;

}

import { SurfaceModel } from "../../02.surface.unit/surface.model"
import { GraphicModel } from "../graphic.model";
import GraphicBit from "../fce/graphic.bit";
import State from "../../99.core/state";
import DaubBit from "../fce/daub.bit";
import * as PIXI from "pixi.js";
import * as GRAPHIC from "../../val/graphic"
import * as SHADE from '../../val/shade'


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const initGraphic = (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  return cpy;
};

export const updateGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  bit = await ste.hunt(ActGph.READ_GRAPHIC, { idx: bal.idx })
  dat = bit.gphBit.dat

  var graphic: PIXI.Graphics = dat.bit;
  //graphic.clear();

  switch (dat.frm) {
    case GRAPHIC.CIRCLE:
      graphic.beginFill(dat.clr); // Red
      graphic.drawCircle(dat.x, dat.y, dat.w); //
      break;

    case GRAPHIC.RECTANGLE:
      graphic.beginFill(dat.clr);
      graphic.lineStyle(3, dat.clr);
      graphic.drawRect(dat.x, dat.y, dat.w, dat.h);
      break;

    case GRAPHIC.ROUNDED_RECTANGLE:
      graphic.beginFill(dat.clr);
      graphic.lineStyle(3, dat.clr);
      graphic.drawRoundedRect(dat.x, dat.y, dat.w, dat.h, dat.crv);
      break;
  }




  if (bal.slv != null) return bal.slv({ gphBit: { idx: "update-graphic", dat: dat } });

  return cpy;
};

export const readGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {
  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "gph00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActGph.CREATE_GRAPHIC });
  if (slv != null) slv({ gphBit: { idx: "read-graphic", dat: bit.clcBit.dat } });
  return cpy;
};
export const writeGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  if (bal.idx == null) bal.idx = "gph00";

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActGph.CREATE_GRAPHIC });
  ste.hunt(ActGph.UPDATE_GRAPHIC, { idx: bal.idx })

  if (bal.slv != null) bal.slv({ gphBit: { idx: "write-graphic", dat: bit.clcBit.dat } });
  return cpy;
};

export const removeGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActGph.DELETE_GRAPHIC })
  if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-graphic", dat: bit.clcBit } });

  return cpy;
};

export const createGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  var dat: DaubBit = { idx: bal.idx, src: bal.src, typ: SHADE.GRAPHIC };

  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  try {
    dat.bit = new PIXI.Graphics();;
  } catch (e) {
    dat.dat = {};
  }

  if (dat.frm == null) dat.frm = GRAPHIC.ROUNDED_RECTANGLE;

  if (dat.w == null) dat.w = 333;
  if (dat.h == null) dat.h = 333;
  if (dat.x == null) dat.x = 0;
  if (dat.y == null) dat.y = 0;
  if (dat.a == null) dat.a = 1;

  if (dat.clr == null) dat.clr = 0x00FF00;
  if (dat.crv == null) dat.crv = 13;

  //if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

  dat
  

  if (bal.slv != null) return bal.slv({ gphBit: { idx: "create-graphic", dat: dat } });
  return cpy;
};

export const deleteGraphic = async (cpy: GraphicModel, bal: GraphicBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-delete-graphic", dat: {} } });

  bit = await ste.hunt(ActGph.READ_GRAPHIC, { idx: bal.idx })
  var dat: DaubBit = bit.gphBit.dat

  var graphic = dat.bit;
  graphic.destroy()
  dat.bit = null

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "delete-graphic", dat } });

  return cpy;
};



import * as PIXI from 'pixi.js';

export default interface DaubBit {
    idx: string;
    src?: string;
    typ?: string;
    frm?: string;
    can?: string;
    dat?: any;
    bit?: PIXI.Graphics;
    clr?: number;
    crv?: number;
    w?: number;
    h?: number;
    x?: number;
    y?: number;
    a?: number;
}


export default interface GraphicBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  GraphicBit  from "./graphic.bit";

export default interface Graphic {
 // idx:string;
 // graphicBitList: GraphicBit[];
 // graphicBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  GraphicBit  from "./fce/graphic.bit";

// Graphic actions

export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export class InitGraphic implements Action {
 readonly type = INIT_GRAPHIC;
 constructor(public bale: GraphicBit) {}
}

export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export class UpdateGraphic implements Action {
 readonly type = UPDATE_GRAPHIC;
 constructor(public bale: GraphicBit) {}
}

export const READ_GRAPHIC = "[Read action] Read Graphic";
 export class ReadGraphic implements Action {
 readonly type = READ_GRAPHIC;
 constructor(public bale: GraphicBit) {}
 }
 
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
 export class WriteGraphic implements Action {
 readonly type = WRITE_GRAPHIC;
 constructor(public bale: GraphicBit) {}
 }
 
export const CREATE_GRAPHIC = "[Create action] Create Graphic";
 export class CreateGraphic implements Action {
 readonly type = CREATE_GRAPHIC;
 constructor(public bale: GraphicBit) {}
 }
 
export const REMOVE_GRAPHIC = "[Remove action] Remove Graphic";
 export class RemoveGraphic implements Action {
 readonly type = REMOVE_GRAPHIC;
 constructor(public bale: GraphicBit) {}
 }
 
export const DELETE_GRAPHIC = "[Delete action] Delete Graphic";
 export class DeleteGraphic implements Action {
 readonly type = DELETE_GRAPHIC;
 constructor(public bale: GraphicBit) {}
 }
 
export type Actions = | InitGraphic | UpdateGraphic 
| ReadGraphic
| WriteGraphic
| CreateGraphic
| RemoveGraphic
| DeleteGraphic
export { initGraphic  } from "./buz/graphic.buzz";
export { updateGraphic  } from "./buz/graphic.buzz";
export { readGraphic  } from "./buz/graphic.buzz";
export { writeGraphic  } from "./buz/graphic.buzz";
export { createGraphic  } from "./buz/graphic.buzz";
export { removeGraphic  } from "./buz/graphic.buzz";
export { deleteGraphic  } from "./buz/graphic.buzz";
import Graphic from "./fce/graphic.interface";
import GraphicBit from "./fce/graphic.interface";

export class GraphicModel implements Graphic {
 //idx:string;
 //graphicBitList: GraphicBit[] = [];
 //graphicBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./graphic.action";
import { GraphicModel } from "./graphic.model";
import * as Buzz from "./graphic.buzzer";
import State from "../99.core/state";

export function reducer(model: GraphicModel = new GraphicModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_GRAPHIC:
 return Buzz.updateGraphic(clone(model), act.bale, state);

 case Act.INIT_GRAPHIC:
 return Buzz.initGraphic(clone(model), act.bale, state);

case Act.READ_GRAPHIC:
 return Buzz.readGraphic(clone(model), act.bale, state);
 
case Act.WRITE_GRAPHIC:
 return Buzz.writeGraphic(clone(model), act.bale, state);
 
case Act.CREATE_GRAPHIC:
 return Buzz.createGraphic(clone(model), act.bale, state);
 
case Act.REMOVE_GRAPHIC:
 return Buzz.removeGraphic(clone(model), act.bale, state);
 
case Act.DELETE_GRAPHIC:
 return Buzz.deleteGraphic(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class GraphicUnit {

    constructor(state: State) {
    }
}


import { SurfaceModel } from "../../02.surface.unit/surface.model";
import { TextModel } from "../text.model";
import TextBit from "../fce/text.bit";
import State from "../../99.core/state";
import * as PIXI from "pixi.js";
import LineBit from "../fce/line.bit";

import * as SHADE from "../../val/shade"
import { TextStyleAlign } from "pixi.js";


import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActVsg from "../../21.visage.unit/visage.action";


var bit, val, idx, dex, lst, dat;

export const initText = (cpy: TextModel, bal: TextBit, ste: State) => {

  return cpy;
};

export const updateText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  bit = await ste.hunt(ActTxt.READ_TEXT, { idx: bal.idx })
  dat = bit.txtBit.dat
  var text: PIXI.Text = dat.bit;
  text.text = dat.txt;

  text.x = dat.x;
  text.y = dat.y;

  //bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.src })
  //var container: PIXI.Container = dat.bit
  //container.addChild( text)

  if (bal.slv != null) return bal.slv({ txtBit: { idx: "update-text", dat: dat } });

  return cpy;
};

export const readText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = 'txt00';
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActTxt.CREATE_TEXT })
  if (slv != null) slv({ txtBit: { idx: "read-text", dat: bit.clcBit.dat } });

  return cpy;
};

export const writeText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  if (bal.idx == null) bal.idx = "txt00";

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActTxt.CREATE_TEXT })
  ste.hunt(ActTxt.UPDATE_TEXT, { idx: bal.idx })

  var output = bit.clcBit.dat

  if (bal.slv != null) bal.slv({ txtBit: { idx: "write-text", dat: output } });
  return cpy;
};

export const removeText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActTxt.DELETE_TEXT })
  if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-text", dat: bit.clcBit } });

  return cpy;
};

export const createText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  var dat: LineBit = { idx: bal.idx, src: bal.src, typ: SHADE.TEXT };

  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  if (dat.txt == null) dat.txt = 'create text';
  if (dat.x == null) dat.x = 0;
  if (dat.y == null) dat.y = 0;
  if (dat.fnt == null) dat.fnt = "Arial";
  if (dat.wrp == null) dat.wrp = 640;
  if (dat.a == null) dat.a = 1;
  if (dat.clr == null) dat.clr = 0x000000;
  if (dat.aln == null) dat.aln = "left";
  if (dat.sze == null) dat.sze = 12;

  try {
    dat.bit = new PIXI.Text(dat.txt);
    dat.bit.style = new PIXI.TextStyle({
      fontFamily: dat.fnt,
      fontSize: dat.sze,
      wordWrap: true,
      wordWrapWidth: dat.wrp,
      fill: dat.clr,
      align: dat.aln as TextStyleAlign,
    });
  } catch (e) {
    dat.dat = {};
  }


  if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

  if (bal.slv != null) return bal.slv({ txtBit: { idx: "create-text", dat } });
  return cpy;
};

export const deleteText = async (cpy: TextModel, bal: TextBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-delete-text", dat: {} } });

  bit = await ste.hunt(ActTxt.READ_TEXT, { idx: bal.idx })
  var dat: LineBit = bit.txtBit.dat

  var text = dat.bit;


  //text.destroy()
  dat.bit = null

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "delete-text", dat } });

  return cpy;
};

export const listText = (cpy: TextModel, bal: TextBit, ste: State) => {
  debugger
  return cpy;
};



import * as PIXI from 'pixi.js';

export default interface LineBit {
    idx:string;
    src?:string;
    typ?:string;
    can?:string;
    dat?:any;
    bit?:PIXI.Text;
    txt?:string;
    clr?:number;
    fnt?:string;
    wrp?:number;
    sze?:number;
    aln?:any;
    
    w?:number;
    h?:number;
    x?:number;
    y?:number;
    a?:number;
}


export default interface TextBit {
    idx:string;
    src?:string;
    typ?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  TextBit  from "./text.bit";

export default interface Text {
 // idx:string;
 // textBitList: TextBit[];
 // textBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  TextBit  from "./fce/text.bit";

// Text actions

export const INIT_TEXT = "[Text action] Init Text";
export class InitText implements Action {
 readonly type = INIT_TEXT;
 constructor(public bale: TextBit) {}
}

export const UPDATE_TEXT = "[Text action] Update Text";
export class UpdateText implements Action {
 readonly type = UPDATE_TEXT;
 constructor(public bale: TextBit) {}
}

export const READ_TEXT = "[Read action] Read Text";
 export class ReadText implements Action {
 readonly type = READ_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export const WRITE_TEXT = "[Write action] Write Text";
 export class WriteText implements Action {
 readonly type = WRITE_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export const CREATE_TEXT = "[Create action] Create Text";
 export class CreateText implements Action {
 readonly type = CREATE_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export const REMOVE_TEXT = "[Remove action] Remove Text";
 export class RemoveText implements Action {
 readonly type = REMOVE_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export const DELETE_TEXT = "[Delete action] Delete Text";
 export class DeleteText implements Action {
 readonly type = DELETE_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export const LIST_TEXT = "[List action] List Text";
 export class ListText implements Action {
 readonly type = LIST_TEXT;
 constructor(public bale: TextBit) {}
 }
 
export type Actions = | InitText | UpdateText 
| ReadText
| WriteText
| CreateText
| RemoveText
| DeleteText
| ListText
export { initText  } from "./buz/text.buzz";
export { updateText  } from "./buz/text.buzz";
export { readText  } from "./buz/text.buzz";
export { writeText  } from "./buz/text.buzz";
export { createText  } from "./buz/text.buzz";
export { removeText  } from "./buz/text.buzz";
export { deleteText  } from "./buz/text.buzz";
export { listText  } from "./buz/text.buzz";
import Text from "./fce/text.interface";
import TextBit from "./fce/text.interface";

export class TextModel implements Text {
 //idx:string;
 //textBitList: TextBit[] = [];
 //textBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./text.action";
import { TextModel } from "./text.model";
import * as Buzz from "./text.buzzer";
import State from "../99.core/state";

export function reducer(model: TextModel = new TextModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_TEXT:
 return Buzz.updateText(clone(model), act.bale, state);

 case Act.INIT_TEXT:
 return Buzz.initText(clone(model), act.bale, state);

case Act.READ_TEXT:
 return Buzz.readText(clone(model), act.bale, state);
 
case Act.WRITE_TEXT:
 return Buzz.writeText(clone(model), act.bale, state);
 
case Act.CREATE_TEXT:
 return Buzz.createText(clone(model), act.bale, state);
 
case Act.REMOVE_TEXT:
 return Buzz.removeText(clone(model), act.bale, state);
 
case Act.DELETE_TEXT:
 return Buzz.deleteText(clone(model), act.bale, state);
 
case Act.LIST_TEXT:
 return Buzz.listText(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class TextUnit {

    constructor(state: State) {
    }
}


import { SurfaceModel } from "../../02.surface.unit/surface.model"
import { SpriteModel } from "../sprite.model";
import SpriteBit from "../fce/sprite.bit";
import State from "../../99.core/state";
import IconBit from "../fce/icon.bit";
import * as PIXI from "pixi.js";

import { Application, Assets, Container, Sprite } from 'pixi.js';

import * as SHADE from "../../val/shade"

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const initSprite = (cpy: SpriteModel, bal: SpriteBit, ste: State) => {

  return cpy;
};

export const updateSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {

  bit = await ste.hunt(ActSpr.READ_SPRITE, { idx: bal.idx })
  dat = bit.sprBit.dat;

  var sprite: PIXI.Sprite = dat.bit;
  sprite.x = dat.x
  sprite.y = dat.y

  if (bal.slv != null) return bal.slv({ sprBit: { idx: "update-sprite", dat: dat } });

  return cpy;
};

export const readSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {
  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "spr00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActSpr.CREATE_SPRITE });
  if (slv != null) slv({ sprBit: { idx: "read-sprite", dat: bit.clcBit.dat } });
  return cpy;
};

export const writeSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {
  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActSpr.CREATE_SPRITE });

  if ( bal.src == null ) ste.hunt(ActSpr.UPDATE_SPRITE, { idx: bal.idx })
  
  if (bal.slv != null) bal.slv({ sprBit: { idx: "write-sprite", dat: bit.clcBit.dat } });
  return cpy;
};

export const removeSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActSpr.DELETE_SPRITE })
  if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-text", dat: bit.clcBit } });

  return cpy;
};

var count = 0;

export const createSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {

  var dat: IconBit = { idx: bal.idx, src: bal.src, typ: SHADE.SPRITE };

  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  if (dat.x == null) dat.x = 0;
  if (dat.y == null) dat.y = 0;
  if (dat.r == null) dat.r = 0;
  if (dat.s == null) dat.s = 1;
  if (dat.a == null) dat.a = 1;
  if (dat.src == null) dat.src = './img/000.png'

  Assets
  debugger
 
  try {
    
    const texture = await Assets.load( dat.src );

    debugger

    dat.bit = new Sprite(texture);

    debugger

  } catch (e) {
    dat.dat = {};
  }

  if ( dat.x != null ) dat.bit.x = dat.x
  if ( dat.y != null ) dat.bit.y = dat.y
  if ( dat.r != null ) dat.bit.rotation = dat.r
  if ( dat.s != null ) dat.bit.scale = dat.s
  if ( dat.a != null ) dat.bit.alpha = dat.a
  
  //if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

  if (bal.slv != null) return bal.slv({ sprBit: { idx: "create-sprite", dat } });

  return cpy;
};

export const deleteSprite = async (cpy: SpriteModel, bal: SpriteBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-delete-graphic", dat: {} } });

  bit = await ste.hunt(ActSpr.READ_SPRITE, { idx: bal.idx })
  var dat: IconBit = bit.sprBit.dat

  var sprite = dat.bit;
  sprite.destroy()
  dat.bit = null

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "delete-sprite", dat } });

  return cpy;
};



import * as PIXI from 'pixi.js';

export default interface IconBit {
    idx:string;
    src?:string;
    typ?:string;
    can?:string;
    dat?:any;
    bit?:PIXI.Sprite;
    clr?:number;
    w?:number;
    h?:number;
    x?:number;
    y?:number;
    r?:number;
    s?:number;
    a?:number;
}


export default interface SpriteBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  SpriteBit  from "./sprite.bit";

export default interface Sprite {
 // idx:string;
 // spriteBitList: SpriteBit[];
 // spriteBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SpriteBit  from "./fce/sprite.bit";

// Sprite actions

export const INIT_SPRITE = "[Sprite action] Init Sprite";
export class InitSprite implements Action {
 readonly type = INIT_SPRITE;
 constructor(public bale: SpriteBit) {}
}

export const UPDATE_SPRITE = "[Sprite action] Update Sprite";
export class UpdateSprite implements Action {
 readonly type = UPDATE_SPRITE;
 constructor(public bale: SpriteBit) {}
}

export const READ_SPRITE = "[Read action] Read Sprite";
 export class ReadSprite implements Action {
 readonly type = READ_SPRITE;
 constructor(public bale: SpriteBit) {}
 }
 
export const WRITE_SPRITE = "[Write action] Write Sprite";
 export class WriteSprite implements Action {
 readonly type = WRITE_SPRITE;
 constructor(public bale: SpriteBit) {}
 }
 
export const CREATE_SPRITE = "[Creatt action] Creatt Sprite";
 export class CreateSprite implements Action {
 readonly type = CREATE_SPRITE;
 constructor(public bale: SpriteBit) {}
 }
 
export const REMOVE_SPRITE = "[Remove action] Remove Sprite";
 export class RemoveSprite implements Action {
 readonly type = REMOVE_SPRITE;
 constructor(public bale: SpriteBit) {}
 }
 
export const DELETE_SPRITE = "[Delete action] Delete Sprite";
 export class DeleteSprite implements Action {
 readonly type = DELETE_SPRITE;
 constructor(public bale: SpriteBit) {}
 }
 
export type Actions = | InitSprite | UpdateSprite 
| ReadSprite
| WriteSprite
| CreateSprite
| RemoveSprite
| DeleteSprite
export { initSprite  } from "./buz/sprite.buzz";
export { updateSprite  } from "./buz/sprite.buzz";
export { readSprite  } from "./buz/sprite.buzz";
export { writeSprite  } from "./buz/sprite.buzz";
export { createSprite  } from "./buz/sprite.buzz";
export { removeSprite  } from "./buz/sprite.buzz";
export { deleteSprite  } from "./buz/sprite.buzz";
import Sprite from "./fce/sprite.interface";
import SpriteBit from "./fce/sprite.interface";

export class SpriteModel implements Sprite {
 //idx:string;
 //spriteBitList: SpriteBit[] = [];
 //spriteBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./sprite.action";
import { SpriteModel } from "./sprite.model";
import * as Buzz from "./sprite.buzzer";
import State from "../99.core/state";

export function reducer(model: SpriteModel = new SpriteModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SPRITE:
 return Buzz.updateSprite(clone(model), act.bale, state);

 case Act.INIT_SPRITE:
 return Buzz.initSprite(clone(model), act.bale, state);

case Act.READ_SPRITE:
 return Buzz.readSprite(clone(model), act.bale, state);
 
case Act.WRITE_SPRITE:
 return Buzz.writeSprite(clone(model), act.bale, state);
 
case Act.CREATE_SPRITE:
 return Buzz.createSprite(clone(model), act.bale, state);
 
case Act.REMOVE_SPRITE:
 return Buzz.removeSprite(clone(model), act.bale, state);
 
case Act.DELETE_SPRITE:
 return Buzz.deleteSprite(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SpriteUnit {

    constructor(state: State) {
    }
}

import { HexagonModel } from "../hexagon.model";
import HexagonBit from "../fce/hexagon.bit";
import HexBit from "../fce/hex.bit";
import State from "../../99.core/state";
import * as Honeycomb from "honeycomb-grid";
import * as PIXI from "pixi.js";

import * as HEXAGON from "../../val/hexagon"
import * as DIRECTION from "../../val/direction"

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const createHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  var dat: HexBit = { idx: bal.idx, src: bal.src };

  for (var key in bal.dat) {
    if (key == 'dat') continue
    dat[key] = bal.dat[key]
  }

  if (bal.dat == null) bal.dat = {}

  var hexagon = bal.dat.dat;

  var map = hexagon.bit
  var graphic = hexagon.gph

  dat.gph = graphic
  dat.map = map

  if (hexagon == null) {
    return bal.slv({ usrBit: { idx: "create-hexagon", src: 'no-hexagon-present' } });
  }

  if (hexagon != null) {
    dat.frm = hexagon.typ;
    dat.gph = hexagon.gph;
  }

  if (dat.clr == null) dat.clr = 0x0000000;
  if (dat.lne == null) dat.lne = 2;
  if (dat.wpe == null) dat.wpe = true;
  if (dat.a == null) dat.a = 1;
  if (dat.pct == null) dat.pct = 1;
  if (dat.sze == null) dat.sze = 3;

  if (dat.frm == null) dat.frm = HEXAGON.HEXMAP;

  //if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

  bal.slv({ usrBit: { idx: "create-hexagon", dat: dat } });
  return cpy;

};
import { HexagonModel } from "../hexagon.model";
import HexagonBit from "../fce/hexagon.bit";
import HexBit from "../fce/hex.bit";
import State from "../../99.core/state";
import * as Honeycomb from "honeycomb-grid";
import * as PIXI from "pixi.js";

import * as HEXAGON from "../../val/hexagon"
import * as DIRECTION from "../../val/direction"

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const initHexagon = (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  return cpy;
};

export const writeHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  if (bal.idx == null) bal.idx = 'hex000'
  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActHex.CREATE_HEXAGON });
  ste.hunt(ActHex.UPDATE_HEXAGON, { idx: bal.idx, dat: bal.dat.dat });
  if (bal.slv != null) bal.slv({ hexBit: { idx: "write-hexagon", dat: bit.clcBit.dat } });

  return cpy;
};



export const focusHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {


  return cpy;
};


export const hexmapHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {



  bal.slv({ hexBit: { idx: "hexmap-hexagon" } });


  return cpy;
};


export const readHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "hex00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, src: bal.src, bit: ActHex.CREATE_HEXAGON });
  if (slv != null) slv({ hexBit: { idx: "read-hexagon", dat: bit.clcBit.dat } });

  return cpy;
};



export const removeHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActHex.DELETE_HEXAGON })
  if (bal.slv != null) bal.slv({ hexBit: { idx: "replace-hexagon", dat: bit.clcBit } });

  return cpy;
};




export const deleteHexagon = (cpy: HexagonModel, bal: HexagonBit, ste: State) => {
  debugger
  return cpy;
};


import { HexagonModel } from "../hexagon.model";
import HexagonBit from "../fce/hexagon.bit";
import HexBit from "../fce/hex.bit";
import State from "../../99.core/state";
import * as Honeycomb from "honeycomb-grid";
import * as PIXI from "pixi.js";

import * as HEXAGON from "../../val/hexagon"
import * as DIRECTION from "../../val/direction"

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const updateHexagon = async (cpy: HexagonModel, bal: HexagonBit, ste: State) => {

  bit = await ste.hunt(ActHex.READ_HEXAGON, { idx: bal.idx })
  var dat: HexBit = bit.hexBit.dat
  
  var map = dat.map



  if (map == null){ return bal.slv({ hexBit: { idx: "update-hexagon-error", src:'no map present' } });}
  dat.frm

  //var graphic = bal.dat.bit
  //var hexmap = bal.bit

  bit = await ste.hunt(ActGph.READ_GRAPHIC, { idx: bal.dat.src })
  var graphic: PIXI.Graphics = bit.gphBit.dat.bit


  if ( graphic == null ) { return bal.slv({ hexBit: { idx: "update-hexagon-error", src:'no graphic present' } });}

  //var hexmap = bal.dat.bit

  graphic.clear()

  //graphic.rect(0, 0, 200, 100)
  //graphic.fill(0xffffff);
  //if (bal.slv != null) 

  const Hex: Honeycomb.HexFactory = Honeycomb.extendHex({
    size: Number(33), // default: 1
    orientation: 'flat', // default: 'pointy'
  });

  const Grid: Honeycomb.GridFactory<any> = Honeycomb.defineGrid(Hex);
  const grid: Honeycomb.Grid = Grid(map);

  var pct = .25;
  var scl = 1

  graphic.lineStyle(3, 0xFF00FF, 10);
  grid

  grid.forEach((hex) => {
    const point = hex.toPoint();
    const corners = hex.corners().map((corner) => corner.add(point));
    const [firstCorner, ...otherCorners] = corners;

    graphic.moveTo(firstCorner.x * scl, firstCorner.y * scl * pct);
    otherCorners.forEach(({ x, y }) => graphic.lineTo(x * scl, y * scl * pct));
    graphic.lineTo(firstCorner.x * scl, firstCorner.y * scl * pct);

    

    graphic.stroke({ color: 0xff00ff, pixelLine: true });
  });

  bal.slv({ hexBit: { idx: "update-hexagon", dat: dat } });


  //switch (dat.frm) {

  //  case HEXAGON.FOCUS:
  //    ste.hunt(ActHex.FOCUS_HEXAGON, { dat, bit: bal.dat })
  //    break

  //   case HEXAGON.HEXMAP:
  //     ste.hunt(ActHex.HEXMAP_HEXAGON, { dat, bit: bal.dat })
  //     break
  // }

  
  return cpy;
};
import * as PIXI from 'pixi.js';

export default interface HexBit {
    idx:string;
    src?:string;
    typ?:string;
    frm?:string;
    gph?:string;
    ico?:string;
    can?:string;
    sze?:number;
    dat?:any;
    map?:any;
    bit?:PIXI.Sprite;
    clr?:number;
    wpe?:boolean; //whether or not to clear the canvas during an update
    pct?:number; // the vertical dimension modifier
    w?:number;
    h?:number;
    x?:number;
    y?:number;
    r?:number;
    s?:number;
    a?:number;
    lne?:number; // the size of the stroke
    crn0?:any;
    crn1?:any;
}

export default interface HexagonBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    bit?: any;
    slv?: Function;
}


import  HexagonBit  from "./hexagon.bit";

export default interface Hexagon {
 // idx:string;
 // hexagonBitList: HexagonBit[];
 // hexagonBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  HexagonBit  from "./fce/hexagon.bit";

// Hexagon actions

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export class InitHexagon implements Action {
 readonly type = INIT_HEXAGON;
 constructor(public bale: HexagonBit) {}
}

export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export class UpdateHexagon implements Action {
 readonly type = UPDATE_HEXAGON;
 constructor(public bale: HexagonBit) {}
}

export const READ_HEXAGON = "[Read action] Read Hexagon";
 export class ReadHexagon implements Action {
 readonly type = READ_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
 export class WriteHexagon implements Action {
 readonly type = WRITE_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
 export class CreateHexagon implements Action {
 readonly type = CREATE_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const REMOVE_HEXAGON = "[Replace action] Remove Hexagon";
 export class RemoveHexagon implements Action {
 readonly type = REMOVE_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const DELETE_HEXAGON = "[Delete action] Delete Hexagon";
 export class DeleteHexagon implements Action {
 readonly type = DELETE_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const FOCUS_HEXAGON = "[Focus action] Focus Hexagon";
 export class FocusHexagon implements Action {
 readonly type = FOCUS_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export const HEXMAP_HEXAGON = "[Hexmap action] Hexmap Hexagon";
 export class HexmapHexagon implements Action {
 readonly type = HEXMAP_HEXAGON;
 constructor(public bale: HexagonBit) {}
 }
 
export type Actions = | InitHexagon | UpdateHexagon 
| ReadHexagon
| WriteHexagon
| CreateHexagon
| RemoveHexagon
| DeleteHexagon
| FocusHexagon
| HexmapHexagon
export { initHexagon  } from "./buz/hexagon.buzz";
export { updateHexagon  } from "./buz/updateHexagon.buzz";
export { readHexagon  } from "./buz/hexagon.buzz";
export { writeHexagon  } from "./buz/hexagon.buzz";
export { createHexagon  } from "./buz/createHexagon.buzz";
export { removeHexagon  } from "./buz/hexagon.buzz";
export { deleteHexagon  } from "./buz/hexagon.buzz";
export { focusHexagon  } from "./buz/hexagon.buzz";
export { hexmapHexagon  } from "./buz/hexagon.buzz";
import Hexagon from "./fce/hexagon.interface";
import HexagonBit from "./fce/hexagon.interface";

export class HexagonModel implements Hexagon {
 //idx:string;
 //hexagonBitList: HexagonBit[] = [];
 //hexagonBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./hexagon.action";
import { HexagonModel } from "./hexagon.model";
import * as Buzz from "./hexagon.buzzer";
import State from "../99.core/state";

export function reducer(model: HexagonModel = new HexagonModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_HEXAGON:
 return Buzz.updateHexagon(clone(model), act.bale, state);

 case Act.INIT_HEXAGON:
 return Buzz.initHexagon(clone(model), act.bale, state);

case Act.READ_HEXAGON:
 return Buzz.readHexagon(clone(model), act.bale, state);
 
case Act.WRITE_HEXAGON:
 return Buzz.writeHexagon(clone(model), act.bale, state);
 
case Act.CREATE_HEXAGON:
 return Buzz.createHexagon(clone(model), act.bale, state);
 
case Act.REMOVE_HEXAGON:
 return Buzz.removeHexagon(clone(model), act.bale, state);
 
case Act.DELETE_HEXAGON:
 return Buzz.deleteHexagon(clone(model), act.bale, state);
 
case Act.FOCUS_HEXAGON:
 return Buzz.focusHexagon(clone(model), act.bale, state);
 
case Act.HEXMAP_HEXAGON:
 return Buzz.hexmapHexagon(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class HexagonUnit {

    constructor(state: State) {
    }
}

import { FocigonModel } from "../focigon.model";
import FocigonBit from "../fce/focigon.bit";
import State from "../../99.core/state";
import FocBit from "../fce/foc.bit";

import * as PIXI from "pixi.js";

import * as HEXAGON from "../../val/hexagon"
import * as DIRECTION from "../../val/direction"

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActVsg from "../../21.visage.unit/visage.action";
import * as ActFgn from "../../08.focigon.unit/focigon.action";

var bit, val, idx, dex, lst, dat;

export const initFocigon = (cpy: FocigonModel, bal: FocigonBit, ste: State) => {
  debugger
  return cpy;
};

export const updateFocigon = async (cpy: FocigonModel, bal: FocigonBit, ste: State) => {

  bit = await ste.hunt(ActFgn.READ_FOCIGON, { idx: bal.idx })
  var dat: FocBit = bit.fgnBit.dat

  dat.x = bal.dat.bit.x
  dat.y = bal.dat.bit.y

  dat.crns = bal.dat.bit.corners

  if (bal.dat.src != null) bal.src = bal.dat.src


  bit = await ste.hunt(ActGph.READ_GRAPHIC, { idx: bal.dat.gph })
  var graphic: PIXI.Graphics = bit.gphBit.dat.bit



  //graphic.rect(0, 0, 200, 100)
  //graphic.fill(0x00ffff);
  graphic.clear()

  if (graphic == null) return console.log("no graphic to draw map upon");

  //if (dat.wpe == true) graphic.clear();

  //graphic.lineStyle(dat.lne, dat.clr, 1);
  //graphic.beginFill(dat.clr);


  var pct = .25;
  var scl = 33

  dat.crns





  graphic.moveTo(dat.crns[0].x * scl, dat.crns[0].y * scl * pct);
  graphic.lineTo(dat.crns[0].x * scl, dat.crns[0].y * scl * pct);
  graphic.lineTo(dat.crns[1].x * scl, dat.crns[1].y * scl * pct);
  graphic.lineTo(dat.crns[2].x * scl, dat.crns[2].y * scl * pct);
  graphic.lineTo(dat.crns[3].x * scl, dat.crns[3].y * scl * pct);
  graphic.lineTo(dat.crns[4].x * scl, dat.crns[4].y * scl * pct);
  graphic.lineTo(dat.crns[5].x * scl, dat.crns[5].y * scl * pct);
  graphic.lineTo(dat.crns[0].x * scl, dat.crns[0].y * scl * pct);
  graphic.fill('red')
  graphic.stroke({  width: 2, color: 0x000000, pixelLine: true });
  

  //graphic.lineStyle(7, 0x00FFFF, 33);

  //graphic
  //graphic.stroke({ color: 0xff00ff, pixelLine: true });

  //const [firstCorner, ...otherCorners] = dat.crns;
  //graphic.moveTo(firstCorner.x * scl, firstCorner.y * scl * pct);
  //otherCorners.forEach(({ x, y }) => graphic.lineTo(x * scl, y * scl * pct));
  //graphic.lineTo(firstCorner.x * scl, firstCorner.y * scl * pct);

  //graphic.alpha = dat.a;

  dat.fce

  if (dat.fce == null) dat.fce = DIRECTION.EAST

  if (dat.fce != null) {
    var corners = dat.crns;

    dat.fce = DIRECTION.WEST

    switch (dat.fce) {
      case DIRECTION.NORTH_EAST:
        dat.crn0 = corners[5];
        dat.crn1 = corners[0];
        break;

      case DIRECTION.NORTH_WEST:
        dat.crn0 = corners[4];
        dat.crn1 = corners[5];
        break;

      case DIRECTION.EAST:
        dat.crn0 = corners[0];
        dat.crn1 = corners[1];
        break;

      case DIRECTION.SOUTH_EAST:
        dat.crn0 = corners[1];
        dat.crn1 = corners[2];
        break;

      case DIRECTION.SOUTH_WEST:
        dat.crn0 = corners[2];
        dat.crn1 = corners[3];
        break;

      case DIRECTION.WEST:
        dat.crn0 = corners[3];
        dat.crn1 = corners[4];
        break;

      case DIRECTION.SOUTH_EAST:
        dat.crn0 = corners[4];
        dat.crn1 = corners[5];
        break;
    }


  


    var faceClr = 0x0000ff;

    //if (bal.bonds[bal.face] == null) faceClr = 0xff0000;

    //graphic.lineStyle(3, faceClr, 1);

    var corner0x = (dat.crn0.x +  dat.crn1.x) * .5;
    var corner0y = (dat.crn0.y +  dat.crn1.y) * .5;
    
    graphic.circle( corner0x * scl, corner0y * scl * pct, 4).fill('blue');

    //graphic.moveTo(dat.crn0.x * scl, dat.crn0.y * scl * pct);
    //graphic.lineTo(dat.crn1.x * scl, dat.crn1.y * scl * pct);
    //graphic.stroke({ color: 0x000000, pixelLine: true });


  }

  //cpy.hexBale = bal;
  bal.slv({ fgnBit: { idx: "update-focigon", dat: focus } });


  return cpy;
};


export const readFocigon = async (cpy: FocigonModel, bal: FocigonBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "hex00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, src: bal.src, bit: ActFgn.CREATE_FOCIGON });

  slv({ fgnBit: { idx: "read-focigon", dat: bit.clcBit.dat } });

  return cpy;
};
export const writeFocigon = async (cpy: FocigonModel, bal: FocigonBit, ste: State) => {

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFgn.CREATE_FOCIGON });
  ste.hunt(ActFgn.UPDATE_FOCIGON, { idx: bal.idx, dat: bal.dat });

  bal.slv({ fgnBit: { idx: "write-focigon", dat: bit.clcBit.dat } });

  return cpy;
};
export const removeFocigon = async (cpy: FocigonModel, bal: FocigonBit, ste: State) => {


  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFgn.DELETE_FOCIGON })
  bal.slv({ fgnBit: { idx: "remove-focigon", dat: bit.clcBit } });

  return cpy;
};

export const createFocigon = async (cpy: FocigonModel, bal: FocigonBit, ste: State) => {

  var dat: FocBit = { idx: bal.idx, src: bal.src };

  bal.dat;

  for (var key in bal.dat) {
    if (key == 'bit') continue
    dat[key] = bal.dat[key]
  }

  var focus = bal.dat.bit;

  dat.fce = focus.face;
  dat.frm = focus.typ;
  dat.crns = focus.corners;

  dat.gph = bal.dat.gph;

  //var bitGph = await ste.hunt(ActGph.READ_GRAPHIC, { idx: bal.src })
  //dat.bit = bitGph.gphBit.dat.bit

  if (dat.clr == null) dat.clr = 0x0000000;
  if (dat.lne == null) dat.lne = 2;
  if (dat.wpe == null) dat.wpe = true;
  if (dat.a == null) dat.a = 1;
  if (dat.pct == null) dat.pct = 1;

  if (dat.frm == null) dat.frm = 'f';
  if (dat.fce == null) dat.fce = 'E';
  if (dat.sze == null) dat.sze = 111;

  //if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

  dat


  bal.slv({ fgnBit: { idx: "create-focigon", dat: dat } });
  return cpy;



};
export const deleteFocigon = (cpy: FocigonModel, bal: FocigonBit, ste: State) => {
  debugger
  return cpy;
};


import * as PIXI from 'pixi.js';

export default interface FocBit {
    idx:string;
    src?:string;
    typ?:string;
    frm?:string;
    fce?:string;
    gph?:string;
    ico?:string;
    can?:string;
    dat?:any;
    bit?:PIXI.Sprite;
    clr?:number;
    wpe?:boolean; //whether or not to clear the canvas during an update
    pct?:number; // the vertical dimension modifier
    w?:number;
    h?:number;
    x?:number;
    y?:number;
    r?:number;
    s?:number;
    a?:number;
    lne?:number; // the size of the stroke
    crns?:any;
    crn0?:any;
    crn1?:any;
    sze?:number
}

export default interface FocigonBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    bit?: any;
    slv?: Function;
}


import  FocigonBit  from "./focigon.bit";

export default interface Focigon {
 // idx:string;
 // focigonBitList: FocigonBit[];
 // focigonBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  FocigonBit  from "./fce/focigon.bit";

// Focigon actions

export const INIT_FOCIGON = "[Focigon action] Init Focigon";
export class InitFocigon implements Action {
 readonly type = INIT_FOCIGON;
 constructor(public bale: FocigonBit) {}
}

export const UPDATE_FOCIGON = "[Focigon action] Update Focigon";
export class UpdateFocigon implements Action {
 readonly type = UPDATE_FOCIGON;
 constructor(public bale: FocigonBit) {}
}

export const READ_FOCIGON = "[Read action] Read Focigon";
 export class ReadFocigon implements Action {
 readonly type = READ_FOCIGON;
 constructor(public bale: FocigonBit) {}
 }
 
export const WRITE_FOCIGON = "[Write action] Write Focigon";
 export class WriteFocigon implements Action {
 readonly type = WRITE_FOCIGON;
 constructor(public bale: FocigonBit) {}
 }
 
export const REMOVE_FOCIGON = "[Remove action] Remove Focigon";
 export class RemoveFocigon implements Action {
 readonly type = REMOVE_FOCIGON;
 constructor(public bale: FocigonBit) {}
 }
 
export const CREATE_FOCIGON = "[Create action] Create Focigon";
 export class CreateFocigon implements Action {
 readonly type = CREATE_FOCIGON;
 constructor(public bale: FocigonBit) {}
 }
 
export const DELETE_FOCIGON = "[Delete action] Delete Focigon";
 export class DeleteFocigon implements Action {
 readonly type = DELETE_FOCIGON;
 constructor(public bale: FocigonBit) {}
 }
 
export type Actions = | InitFocigon | UpdateFocigon 
| ReadFocigon
| WriteFocigon
| RemoveFocigon
| CreateFocigon
| DeleteFocigon
export { initFocigon  } from "./buz/focigon.buzz";
export { updateFocigon  } from "./buz/focigon.buzz";
export { readFocigon  } from "./buz/focigon.buzz";
export { writeFocigon  } from "./buz/focigon.buzz";
export { removeFocigon  } from "./buz/focigon.buzz";
export { createFocigon  } from "./buz/focigon.buzz";
export { deleteFocigon  } from "./buz/focigon.buzz";
import Focigon from "./fce/focigon.interface";
import FocigonBit from "./fce/focigon.interface";

export class FocigonModel implements Focigon {
 //idx:string;
 //focigonBitList: FocigonBit[] = [];
 //focigonBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./focigon.action";
import { FocigonModel } from "./focigon.model";
import * as Buzz from "./focigon.buzzer";
import State from "../99.core/state";

export function reducer(model: FocigonModel = new FocigonModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_FOCIGON:
 return Buzz.updateFocigon(clone(model), act.bale, state);

 case Act.INIT_FOCIGON:
 return Buzz.initFocigon(clone(model), act.bale, state);

case Act.READ_FOCIGON:
 return Buzz.readFocigon(clone(model), act.bale, state);
 
case Act.WRITE_FOCIGON:
 return Buzz.writeFocigon(clone(model), act.bale, state);
 
case Act.REMOVE_FOCIGON:
 return Buzz.removeFocigon(clone(model), act.bale, state);
 
case Act.CREATE_FOCIGON:
 return Buzz.createFocigon(clone(model), act.bale, state);
 
case Act.DELETE_FOCIGON:
 return Buzz.deleteFocigon(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class FocigonUnit {

    constructor(state: State) {
    }
}

export const initLoop = (cpy: LoopModel, bal:LoopBit, ste: State) => {
 
 return cpy;
};

export const updateLoop = (cpy: LoopModel, bal:LoopBit, ste: State) => {
 return cpy;
};


export const removeLoop = (cpy: LoopModel, bal:LoopBit, ste: State) => {
 debugger
 return cpy;
 };
export const deleteLoop = (cpy: LoopModel, bal:LoopBit, ste: State) => {
 debugger
 return cpy;
 };
import { LoopModel } from "../loop.model";
import LoopBit from "../fce/loop.bit";
import State from "../../99.core/state";
"use strict";
exports.__esModule = true;
//# sourceMappingURL=loop.bit.js.map

export default interface LoopBit {
 idx:string;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=loop.interface.js.map

import  LoopBit  from "./loop.bit";

export default interface Loop {
 // idx:string;
 // loopBitList: LoopBit[];
 // loopBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  LoopBit  from "./fce/loop.bit";

// Loop actions

export const INIT_LOOP = "[Loop action] Init Loop";
export class InitLoop implements Action {
 readonly type = INIT_LOOP;
 constructor(public bale: LoopBit) {}
}

export const UPDATE_LOOP = "[Loop action] Update Loop";
export class UpdateLoop implements Action {
 readonly type = UPDATE_LOOP;
 constructor(public bale: LoopBit) {}
}

export const REMOVE_LOOP = "[Replace action] Remove Loop";
 export class RemoveLoop implements Action {
 readonly type = REMOVE_LOOP;
 constructor(public bale: LoopBit) {}
 }
 
export const DELETE_LOOP = "[Delete action] Delete Loop";
 export class DeleteLoop implements Action {
 readonly type = DELETE_LOOP;
 constructor(public bale: LoopBit) {}
 }
 
export type Actions = | InitLoop | UpdateLoop 
| RemoveLoop
| DeleteLoop
export { initLoop  } from "./buz/loop.buzz";
export { updateLoop  } from "./buz/loop.buzz";
export { removeLoop  } from "./buz/loop.buzz";
export { deleteLoop  } from "./buz/loop.buzz";
import Loop from "./fce/loop.interface";
import LoopBit from "./fce/loop.interface";

export class LoopModel implements Loop {
 //idx:string;
 //loopBitList: LoopBit[] = [];
 //loopBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./loop.action";
import { LoopModel } from "./loop.model";
import * as Buzz from "./loop.buzzer";
import State from "../99.core/state";

export function reducer(model: LoopModel = new LoopModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_LOOP:
 return Buzz.updateLoop(clone(model), act.bale, state);

 case Act.INIT_LOOP:
 return Buzz.initLoop(clone(model), act.bale, state);

case Act.REMOVE_LOOP:
 return Buzz.removeLoop(clone(model), act.bale, state);
 
case Act.DELETE_LOOP:
 return Buzz.deleteLoop(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class LoopUnit {

    constructor(state: State) {
    }
}

export const initToon = (cpy: ToonModel, bal:ToonBit, ste: State) => {
 
 return cpy;
};

export const updateToon = (cpy: ToonModel, bal:ToonBit, ste: State) => {
 return cpy;
};


import { ToonModel } from "../toon.model";
import ToonBit from "../fce/toon.bit";
import State from "../../99.core/state";
"use strict";
exports.__esModule = true;
//# sourceMappingURL=toon.bit.js.map

export default interface ToonBit {
 idx:string;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=toon.interface.js.map

import  ToonBit  from "./toon.bit";

export default interface Toon {
 // idx:string;
 // toonBitList: ToonBit[];
 // toonBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  ToonBit  from "./fce/toon.bit";

// Toon actions

export const INIT_TOON = "[Toon action] Init Toon";
export class InitToon implements Action {
 readonly type = INIT_TOON;
 constructor(public bale: ToonBit) {}
}

export const UPDATE_TOON = "[Toon action] Update Toon";
export class UpdateToon implements Action {
 readonly type = UPDATE_TOON;
 constructor(public bale: ToonBit) {}
}

export type Actions = | InitToon | UpdateToon ;

export { initToon  } from "./buz/toon.buzz";
export { updateToon  } from "./buz/toon.buzz";

import Toon from "./fce/toon.interface";
import ToonBit from "./fce/toon.interface";

export class ToonModel implements Toon {
 //idx:string;
 //toonBitList: ToonBit[] = [];
 //toonBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./toon.action";
import { ToonModel } from "./toon.model";
import * as Buzz from "./toon.buzzer";
import State from "../99.core/state";

export function reducer(model: ToonModel = new ToonModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_TOON:
 return Buzz.updateToon(clone(model), act.bale, state);

 case Act.INIT_TOON:
 return Buzz.initToon(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ToonUnit {

    constructor(state: State) {
    }
}

export const initVideo = (cpy: VideoModel, bal:VideoBit, ste: State) => {
 
 return cpy;
};

export const updateVideo = (cpy: VideoModel, bal:VideoBit, ste: State) => {
 return cpy;
};


export const removeVideo = (cpy: VideoModel, bal:VideoBit, ste: State) => {
 debugger
 return cpy;
 };
export const deleteVideo = (cpy: VideoModel, bal:VideoBit, ste: State) => {
 debugger
 return cpy;
 };
import { VideoModel } from "../video.model";
import VideoBit from "../fce/video.bit";
import State from "../../99.core/state";

export default interface VideoBit {
 idx:string;
}


import  VideoBit  from "./video.bit";

export default interface Video {
 // idx:string;
 // videoBitList: VideoBit[];
 // videoBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  VideoBit  from "./fce/video.bit";

// Video actions

export const INIT_VIDEO = "[Video action] Init Video";
export class InitVideo implements Action {
 readonly type = INIT_VIDEO;
 constructor(public bale: VideoBit) {}
}

export const UPDATE_VIDEO = "[Video action] Update Video";
export class UpdateVideo implements Action {
 readonly type = UPDATE_VIDEO;
 constructor(public bale: VideoBit) {}
}

export const REMOVE_VIDEO = "[Replace action] Replace Video";
 export class RemoveVideo implements Action {
 readonly type = REMOVE_VIDEO;
 constructor(public bale: VideoBit) {}
 }
 
export const DELETE_VIDEO = "[Delete action] Delete Video";
 export class DeleteVideo implements Action {
 readonly type = DELETE_VIDEO;
 constructor(public bale: VideoBit) {}
 }
 
export type Actions = | InitVideo | UpdateVideo 
| RemoveVideo
| DeleteVideo

export { initVideo  } from "./buz/video.buzz";
export { updateVideo  } from "./buz/video.buzz";
export { removeVideo  } from "./buz/video.buzz";
export { deleteVideo  } from "./buz/video.buzz";
import Video from "./fce/video.interface";
import VideoBit from "./fce/video.interface";

export class VideoModel implements Video {
 //idx:string;
 //videoBitList: VideoBit[] = [];
 //videoBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./video.action";
import { VideoModel } from "./video.model";
import * as Buzz from "./video.buzzer";
import State from "../99.core/state";

export function reducer(model: VideoModel = new VideoModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_VIDEO:
 return Buzz.updateVideo(clone(model), act.bale, state);

 case Act.INIT_VIDEO:
 return Buzz.initVideo(clone(model), act.bale, state);

case Act.REMOVE_VIDEO:
 return Buzz.removeVideo(clone(model), act.bale, state);
 
case Act.DELETE_VIDEO:
 return Buzz.deleteVideo(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class VideoUnit {

    constructor(state: State) {
    }
}

import * as PIXI from "pixi.js";
import * as GRAPHIC from "../../val/graphic"
import * as SHADE from '../../val/shade'
import gsap from "gsap";
import * as ActFme from "../frame.action";
import { FrameModel } from "../frame.model";
import FrameBit from "../fce/frame.bit";
import State from "../../99.core/state";
import HoldBit from "../fce/hold.bit";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActVsg from "../../21.visage.unit/visage.action";

import * as ActCan from "../../03.container.unit/container.action";

import * as ActApp from "../../20.application.unit/application.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";

var bit, val, idx, dex, lst, dat;

export const initFrame = (cpy: FrameModel, bal: FrameBit, ste: State) => {
  debugger
  return cpy;
};

export const updateFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {

  bit = await ste.hunt(ActFme.READ_FRAME, { idx: bal.idx })
  var dat: HoldBit = bit.fmeBit.dat;

  var appBit = await ste.hunt(ActApp.READ_APPLICATION, { idx: bal.src })

  var app = appBit.appBit.dat.bit;
  var canvas = app.canvas;
  
  var canBit = await ste.hunt( ActCan.READ_CONTAINER, { idx: dat.can })
  var container = canBit.canBit.dat.bit  
  
  var x = canvas.width *.5 - container.width * .5;
  var y = canvas.height *.5 - container.height * .5;

  x -= dat.x;
  y -= dat.y

  //canvas.width / 2 - player.x)
  //var camBit = bit.camBit.dat;
  //read the surface
  //bit = await ste.hunt(ActCan.READ_CONTAINER, { idx: bal.src })
  //var canBit = bit.canBit.bit;

  //bit = await ste.hunt( ActFce.READ_SURFACE, { idx: bal.src })

  var auto = container.getGlobalPosition()

   dat.twn = gsap.to( container, { y, x, duration: 1, ease: "linear" });

  if (bal.slv != null) return bal.slv({ fmeBit: { idx: "update-frame", dat } });

  return cpy;
};

export const readFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = "frm00";
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActFme.CREATE_FRAME });
  if (slv != null) slv({ fmeBit: { idx: "read-frame", dat: bit.clcBit.dat } });
  return cpy;
};

export const writeFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {

  if (bal.idx == null) bal.idx = "frm00";

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFme.CREATE_FRAME });
  ste.hunt(ActFme.UPDATE_FRAME, { idx: bal.idx })

  if (bal.slv != null) bal.slv({ fmeBit: { idx: "write-frame", dat: bit.clcBit.dat } });

  return cpy;
};
export const removeFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActFme.DELETE_FRAME })
  if (bal.slv != null) bal.slv({ fmeBit: { idx: "remove-frame", dat: bit.clcBit } });

  return cpy;

};


export const createFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {

  

  var dat: HoldBit = { idx: bal.idx, src: bal.src, typ: 'core', x: 0, y: 0 };

  for (var key in bal.dat) {
    dat[key] = bal.dat[key]
  }

  dat
  

  bal.slv({ fmeBit: { idx: "create-frame", dat } });
  return cpy;
};

export const deleteFrame = async (cpy: FrameModel, bal: FrameBit, ste: State) => {


  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-delete-frame", dat: {} } });

  bit = await ste.hunt(ActFme.READ_FRAME, { idx: bal.idx })
  var dat: HoldBit = bit.fmeBit.dat

  var graphic = dat.bit;
  graphic.destroy()
  dat.bit = null

  if (bal.slv != null) return bal.slv({ fmeBit: { idx: "delete-frame", dat } });


  return cpy;
};


export default interface FrameBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
   }
   

import  FrameBit  from "./frame.bit";

export default interface Frame {
 // idx:string;
 // frameBitList: FrameBit[];
 // frameBits:any;

}

import * as PIXI from 'pixi.js';

export default interface HoldBit {
    idx: string;
    src?: string;
    typ?: string;
    frm?: string;
    can?: string;
    dat?: any;
    bit?: PIXI.Graphics;
    clr?: number;
    crv?: number;
    w?: number;
    h?: number;
    x?: number;
    y?: number;
    a?: number;
    twn?:any;
}

import { Action } from "../99.core/interface/action.interface";
import  FrameBit  from "./fce/frame.bit";

// Frame actions

export const INIT_FRAME = "[Frame action] Init Frame";
export class InitFrame implements Action {
 readonly type = INIT_FRAME;
 constructor(public bale: FrameBit) {}
}

export const UPDATE_FRAME = "[Frame action] Update Frame";
export class UpdateFrame implements Action {
 readonly type = UPDATE_FRAME;
 constructor(public bale: FrameBit) {}
}

export const READ_FRAME = "[Read action] Read Frame";
 export class ReadFrame implements Action {
 readonly type = READ_FRAME;
 constructor(public bale: FrameBit) {}
 }
 
export const WRITE_FRAME = "[Write action] Write Frame";
 export class WriteFrame implements Action {
 readonly type = WRITE_FRAME;
 constructor(public bale: FrameBit) {}
 }
 
export const REMOVE_FRAME = "[Remove action] Remove Frame";
 export class RemoveFrame implements Action {
 readonly type = REMOVE_FRAME;
 constructor(public bale: FrameBit) {}
 }
 
export const CREATE_FRAME = "[Create action] Create Frame";
 export class CreateFrame implements Action {
 readonly type = CREATE_FRAME;
 constructor(public bale: FrameBit) {}
 }
 
export const DELETE_FRAME = "[Delete action] Delete Frame";
 export class DeleteFrame implements Action {
 readonly type = DELETE_FRAME;
 constructor(public bale: FrameBit) {}
 }
 
export type Actions = | InitFrame | UpdateFrame 
| ReadFrame
| WriteFrame
| RemoveFrame
| CreateFrame
| DeleteFrame
export { initFrame  } from "./buz/frame.buzz";
export { updateFrame  } from "./buz/frame.buzz";
export { readFrame  } from "./buz/frame.buzz";
export { writeFrame  } from "./buz/frame.buzz";
export { removeFrame  } from "./buz/frame.buzz";
export { createFrame  } from "./buz/frame.buzz";
export { deleteFrame  } from "./buz/frame.buzz";
import Frame from "./fce/frame.interface";
import FrameBit from "./fce/frame.interface";

export class FrameModel implements Frame {
 //idx:string;
 //frameBitList: FrameBit[] = [];
 //frameBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./frame.action";
import { FrameModel } from "./frame.model";
import * as Buzz from "./frame.buzzer";
import State from "../99.core/state";

export function reducer(model: FrameModel = new FrameModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_FRAME:
 return Buzz.updateFrame(clone(model), act.bale, state);

 case Act.INIT_FRAME:
 return Buzz.initFrame(clone(model), act.bale, state);

case Act.READ_FRAME:
 return Buzz.readFrame(clone(model), act.bale, state);
 
case Act.WRITE_FRAME:
 return Buzz.writeFrame(clone(model), act.bale, state);
 
case Act.REMOVE_FRAME:
 return Buzz.removeFrame(clone(model), act.bale, state);
 
case Act.CREATE_FRAME:
 return Buzz.createFrame(clone(model), act.bale, state);
 
case Act.DELETE_FRAME:
 return Buzz.deleteFrame(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class FrameUnit {

    constructor(state: State) {
    }
}

import { Action } from "../99.core/interface/action.interface";
import  ApplicationBit  from "./fce/application.bit";

// Application actions

export const INIT_APPLICATION = "[Application action] Init Application";
export class InitApplication implements Action {
 readonly type = INIT_APPLICATION;
 constructor(public bale: ApplicationBit) {}
}

export const UPDATE_APPLICATION = "[Application action] Update Application";
export class UpdateApplication implements Action {
 readonly type = UPDATE_APPLICATION;
 constructor(public bale: ApplicationBit) {}
}

export const READ_APPLICATION = "[Read action] Read Application";
 export class ReadApplication implements Action {
 readonly type = READ_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export const WRITE_APPLICATION = "[Write action] Write Application";
 export class WriteApplication implements Action {
 readonly type = WRITE_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export const REMOVE_APPLICATION = "[Remove action] Remove Application";
 export class RemoveApplication implements Action {
 readonly type = REMOVE_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export const DELETE_APPLICATION = "[Delete action] Delete Application";
 export class DeleteApplication implements Action {
 readonly type = DELETE_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export const CREATE_APPLICATION = "[Create action] Create Application";
 export class CreateApplication implements Action {
 readonly type = CREATE_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export const TEST_APPLICATION = "[Test action] Test Application";
 export class TestApplication implements Action {
 readonly type = TEST_APPLICATION;
 constructor(public bale: ApplicationBit) {}
 }
 
export type Actions = | InitApplication | UpdateApplication 
| ReadApplication
| WriteApplication
| RemoveApplication
| DeleteApplication
| CreateApplication
| TestApplication
export { initApplication  } from "./buz/application.buzz";
export { updateApplication  } from "./buz/application.buzz";
export { readApplication  } from "./buz/application.buzz";
export { writeApplication  } from "./buz/application.buzz";
export { removeApplication  } from "./buz/application.buzz";
export { deleteApplication  } from "./buz/application.buzz";
export { createApplication  } from "./buz/createApplication.buzz";
export { testApplication  } from "./buz/application.buzz";
import Application from "./fce/application.interface";
import ApplicationBit from "./fce/application.interface";

export class ApplicationModel implements Application {
 //idx:string;
 //applicationBitList: ApplicationBit[] = [];
 //applicationBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./application.action";
import { ApplicationModel } from "./application.model";
import * as Buzz from "./application.buzzer";
import State from "../99.core/state";

export function reducer(model: ApplicationModel = new ApplicationModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_APPLICATION:
            return Buzz.updateApplication(clone(model), act.bale, state);

        case Act.INIT_APPLICATION:
            return Buzz.initApplication(clone(model), act.bale, state);

        case Act.READ_APPLICATION:
            return Buzz.readApplication(clone(model), act.bale, state);

        case Act.WRITE_APPLICATION:
            return Buzz.writeApplication(clone(model), act.bale, state);

        case Act.REMOVE_APPLICATION:
            return Buzz.removeApplication(clone(model), act.bale, state);

        case Act.DELETE_APPLICATION:
            return Buzz.deleteApplication(clone(model), act.bale, state);

        case Act.CREATE_APPLICATION:
            return Buzz.createApplication(clone(model), act.bale, state);

case Act.TEST_APPLICATION:
 return Buzz.testApplication(clone(model), act.bale, state);
 
        default:
            return model;
    }
}
import State from "../99.core/state";

export default class ApplicationUnit {

 constructor(state: State) {
 }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActApp from "../application.action";

import { Application, Assets, Container, Sprite } from 'pixi.js';

import { ApplicationModel } from "../application.model";
import ApplicationBit from "../fce/application.bit";
import AppBit from "../fce/app.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initApplication = (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-application" } });
    return cpy;
};

export const updateApplication = (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    bal.slv({ appBit: { idx: "update-application" } });
    return cpy;
};

export const readApplication = async (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'app00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActApp.CREATE_APPLICATION });
    if (bal.slv != null) bal.slv({ appBit: { idx: "read-application", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeApplication = async (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src:bal.src, dat: bal.dat, bit: ActApp.CREATE_APPLICATION });
    if (bal.slv != null) bal.slv({ appBit: { idx: "write-application", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeApplication = async (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActApp.DELETE_APPLICATION });
    if (bal.slv != null) bal.slv({ appBit: { idx: "remove-application", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteApplication = (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    if (bal.slv != null) bal.slv({ appBit: { idx: "delete-application" } });
    return cpy;
};


export const testApplication = (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {

    

    bal.slv({ appBit: { idx: "test-application", val: 1 } });

    return cpy;
};
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActApp from "../application.action";

import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";


import { Application, Assets, Container, Sprite } from 'pixi.js';

import { ApplicationModel } from "../application.model";
import ApplicationBit from "../fce/application.bit";
import AppBit from "../fce/app.bit";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const createApplication = async (cpy: ApplicationModel, bal: ApplicationBit, ste: State) => {
    var dat: AppBit = { idx: bal.idx, src: bal.src, bit:null };

    var el: HTMLElement | null = document.getElementById(dat.src as string)
    var app = new Application();

    dat.bit = app;

    await app.init({ background: '#00FFFF', resizeTo: el.parentElement });

    app.canvas.height = 112
    app.canvas.width = 960

    if (el != null) el.appendChild(app.canvas);

    
    // Center the bunny sprites in local container coordinates
    // container.pivot.x = container.width / 2;
    // container.pivot.y = container.height / 2;

    // const texture = await Assets.load('https://pixijs.com/assets/bunny.png');
    // const bunny = new Sprite(texture);
    // bunny.anchor.set(0.5);
    // bunny.x = app.screen.width / 2;
    // bunny.y = app.screen.height / 2;

    //app.stage.addChild(bunny);

    //await Assets.load([
    //    "./sprite/000/000.json"
    //]);

    //const animations = Assets.cache.get('./sprite/000/000.json').data.animations;

    //container.addChild( button)
    //app.stage.addChild( button)
    //button.onPress.connect(() => console.log('Button pressed!'));

    //bal.slv({ fceBit: { idx: "create-surface", dat:{bit:app} } });


    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }

    bal.slv({ appBit: { idx: "create-application", dat: dat } });
    return cpy;
};



export default interface AppBit {
 idx: string;
 src?: string;
 bit?: any;
}




export default interface ApplicationBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}




import  ApplicationBit  from "./application.bit";

export default interface Application {
 // idx:string;
 // applicationBitList: ApplicationBit[];
 // applicationBits:any;

}


import * as ActSde from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";
import * as ActGph from "../../04.graphic.unit/graphic.action";
import * as ActTxt from "../../05.text.unit/text.action";
import * as ActSpr from "../../06.sprite.unit/sprite.action";
import * as ActHex from "../../07.hexagon.unit/hexagon.action";
import * as ActVid from "../../11.video.unit/video.action";
import * as ActLop from "../../09.loop.unit/loop.action";

var bit, val, idx, dex, lst, dat;

export const initVisage = (cpy: VisageModel, bal: VisageBit, ste: State) => {

  return cpy;
};

export const updateVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  bit = await ste.hunt(ActVsg.READ_VISAGE, { idx: bal.idx })
  var dat: FrameBit = bit.vsgBit.dat

  var fceBit = await ste.hunt(ActFce.WRITE_SURFACE, { idx: dat.idx, dat: { src: dat.src, width: dat.width, height: dat.height } })

  if (bal.slv != null) bal.slv({ vsgBit: { idx: "update-visage", dat } });

  return cpy;
};

export const mountVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-size-visage", dat: {} } });

  if (bal.dat.h != null) bal.dat.height = bal.dat.h;
  if (bal.dat.w != null) bal.dat.width = bal.dat.h;

  if (bal.dat != null) bal.dat = { width: bal.dat.width, height: bal.dat.height }
  else bal.dat = { width: null, height: null }

  bal.dat.typ = VISAGE.MOUNT_FULL;

  bal.dat

  if (bal.dat.height != null) bal.dat.typ = VISAGE.MOUNT_HEIGHT
  if (bal.dat.width != null) bal.dat.typ = VISAGE.MOUNT_WIDTH
  if ((bal.dat.height != null) && (bal.dat.width != null)) bal.dat.typ = VISAGE.MOUNT_PART

  bal.dat.typ

  bit = await ste.hunt(ActVsg.WRITE_VISAGE, { idx: bal.idx, src: bal.src, dat: bal.dat })

  if (bal.slv != null) bal.slv({ vsgBit: { idx: "mount-visage", dat: bit.vsgBit.dat } });
  return cpy;
};


export const screenVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  bit = await ste.hunt(ActVsg.WRITE_VISAGE, { idx: bal.idx, dat: { typ: VISAGE.SCREEN } })


  if (bal.slv != null) bal.slv({ vsgBit: { idx: "sreen-visage", dat: bit.vsgBit.dat } });

  return cpy;
};


export const readVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = 'vsg00';
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, src: bal.src, bit: ActVsg.CREATE_VISAGE })
  if (slv != null) slv({ vsgBit: { idx: "read-visage", dat: bit.clcBit.dat } });
  return cpy;

};

export const writeVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  //gotcha-- making sure that the src is present on the collect bale once caused a tremendous issue



  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActVsg.CREATE_VISAGE })

  ste.hunt(ActVsg.UPDATE_VISAGE, { idx: bal.idx })

  if (bal.slv != null) bal.slv({ vsgBit: { idx: "write-visage", dat: bit.clcBit.dat } });

  return cpy;
};

export const removeVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-create-visage", dat: {} } });

  bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActVsg.DELETE_VISAGE })
  if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-visage", dat: bit.clcBit } });
  return cpy;
};



export const createVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {


  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-create-visage", dat: {} } });

  var dat: FrameBit = { idx: bal.idx, src: bal.src, typ: bal.dat.typ };

  var canvas: HTMLElement = document.getElementById(dat.src) as HTMLElement;

  if (canvas == null) {
    canvas = document.createElement("canvas");
    canvas.id = dat.src;
    var body = document.body;
    if (body != null) body.appendChild(canvas);
  }

  dat.bit = canvas as HTMLCanvasElement
  dat.parent = dat.bit.parentElement;
  dat.height = bal.dat.height;
  dat.width = bal.dat.width;

  dat.canLst = [];
  dat.gphLst = [];
  dat.txtLst = [];
  dat.sprLst = [];
  dat.hexLst = [];
  dat.vidLst = [];
  dat.lopLst = [];
  dat.tonLst = []

  bit = await ste.hunt(ActVsg.SIZE_VISAGE, { dat })
  dat

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "create-visage", dat } });
  return cpy;
};

export const deleteVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-size-visage", dat: {} } });

  bit = await ste.hunt(ActVsg.READ_VISAGE, { idx: bal.idx })
  var dat: FrameBit = bit.vsgBit.dat


  //remove each type inside a visage
  dat.canLst.forEach(async (a) => ste.hunt(ActCan.REMOVE_CONTAINER, { idx: a }))
  dat.gphLst.forEach(async (a) => ste.hunt(ActGph.REMOVE_GRAPHIC, { idx: a }))
  dat.txtLst.forEach(async (a) => ste.hunt(ActTxt.REMOVE_TEXT, { idx: a }))
  dat.sprLst.forEach(async (a) => ste.hunt(ActSpr.REMOVE_SPRITE, { idx: a }))
  dat.hexLst.forEach(async (a) => ste.hunt(ActHex.REMOVE_HEXAGON, { idx: a }))
  dat.vidLst.forEach(async (a) => ste.hunt(ActVid.REMOVE_VIDEO, { idx: a }))
  dat.lopLst.forEach(async (a) => ste.hunt(ActLop.REMOVE_LOOP, { idx: a }))

  var fceBit = await ste.hunt(ActFce.REMOVE_SURFACE, { idx: dat.idx, dat: { src: dat.src } })

  const canvas = dat.bit
  if (canvas == null) return bal.slv({ fceBit: { idx: "error-delete-visage", dat: {} } });
  const context = canvas.getContext('2d');
  if (context == null) return bal.slv({ fceBit: { idx: "error-delete-visage", dat: {} } });


  context.clearRect(0, 0, canvas.width, canvas.height);

  context.fillStyle = "white";
  context.fillRect(0, 0, canvas.width, canvas.height);

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "delete-visage", dat } });

  return cpy;
};


export const sizeVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  var dat: FrameBit = bal.dat;

  var w, h;

  dat.typ

  switch (dat.typ) {

    case VISAGE.MOUNT_FULL:

      var body = document.body,
        html = document.documentElement;

      var height = Math.max(body.scrollHeight, body.offsetHeight,
        html.clientHeight, html.scrollHeight, html.offsetHeight);

      var calcHeight = 0

      bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActVsg.CREATE_VISAGE })
      var clcLst = bit.clcBit.dat.bitList

      clcLst.forEach((a) => {
        if (a.typ != VISAGE.MOUNT_HEIGHT) return
        calcHeight += a.height
      })

      h = height - calcHeight - 5;
      w = dat.parent.clientWidth;
      break

    case VISAGE.MOUNT_PART:
      w = dat.width;
      h = dat.height
      break

    case VISAGE.MOUNT_HEIGHT:
      w = dat.parent.clientWidth;
      h = dat.height
      break

    case VISAGE.MOUNT_WIDTH:
      w = dat.width;
      h = dat.parent.clientHeight;
      break
  }

  const vw = Math.max(w || 0)
  const vh = Math.max(h || 0)

  dat.width = vw
  dat.height = vh

  console.log("width " + vw + ' :: height ' + vh)

  if (bal.slv != null) return bal.slv({ vsgBit: { idx: "size-visage", dat } });

};

export const renderVisage = (cpy: VisageModel, bal: VisageBit, ste: State) => {

  var canvas = document.getElementById(bal.idx)
  var pngUrl = canvas['toDataURL']("image/png")
  var dat = pngUrl

  var base64Data = dat.replace(/^data:image\/png;base64,/, "");

  //var FS = require('fs-extra');

  //FS.ensureDirSync('./frame/')

  //dex = FS.readdirSync('./frame').length;
  //idx = String(dex).padStart(6, '0');

  //var fin = './frame/' + idx + '.png'

  //FS.writeFile(fin, base64Data, 'base64', function (err) {
  //console.log('writing ' + fin);
  //if (bal.slv != null) bal.slv({ vsgBit: { idx: "render-visage", dat } });
  //});

  return cpy;
};

export const dimensionVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-size-visage", dat: {} } });

  bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActVsg.CREATE_VISAGE })
  var clcLst = bit.clcBit.dat.bitList

  clcLst.forEach((a) => {
    sizeVisage(cpy, { idx: a.idx, typ: a.typ, dat: a }, ste)
    var height = a.height;
    var width = a.width;
    ste.hunt(ActVsg.WRITE_VISAGE, { idx: a.idx, dat: { width, height } })
  })

  return cpy;
};

export const fullscreenVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {
  //if (bal.src == null) bal.src = VISAGE.FULL_SCREEN

  //you might need this
  //canvas {
  //    position: absolute;
  //   top: 0;
  //   left: 0;
  //   margin: 0;
  //   padding: 0;
  //   display: block;
  // }

  bit = await ste.hunt(ActVsg.WRITE_VISAGE, { idx: bal.idx, src: bal.src })
  if (bal.slv != null) bal.slv({ stgBit: { idx: bal.idx } });

  return cpy;
};



export const mainVisage = (cpy: VisageModel, bal: VisageBit, ste: State) => {


  if (typeof window != "object") return bal.slv({ fceBit: { idx: "error-size-visage", dat: {} } });


  //const { ipcRenderer } = require('electron');
  //ipcRenderer.on('update-resize', (_event, value) => {

  setTimeout(() => {

    if (bal.slv != null) bal.slv({ vsgBit: { idx: "size-visage" } });

  }, 33)

  //})

  // ipcRenderer.send('resize-me-please', bal.dat.w, bal.dat.h)
  //bit = await ste.hunt(ActVsg.FULLSCREEN_VISAGE, { src: VISAGE.FULL_SCREEN })
  return cpy;

};

export const clearVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  bit = await ste.hunt(ActVsg.READ_VISAGE, { idx: bal.idx })
  var dat: FrameBit = bit.vsgBit.dat

  return cpy;
};



//get a list of all the visages here
export const listVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {


  //if (typeof window != "object") return bal.slv({ vsgBit: { idx: "error-create-visage",  lst:['none', 'none']} });

  dat = null

  if (bal.src == 'bus') bit = await ste.bus(ActCol.FETCH_COLLECT, { val: 0, bit: ActVsg.CREATE_VISAGE })
  else bit = await ste.hunt(ActCol.FETCH_COLLECT, { val: 0, bit: ActVsg.CREATE_VISAGE })

  if (bit.clcBit.dat == null) lst = []
  else dat = bit.clcBit.dat;


  debugger


  if (dat != null) {

    dat.bitList.forEach((a) => {
      lst = []
      lst.push((a.idx))
    })

    lst
  }

  if (bal.slv != null) bal.slv({ vsgBit: { idx: 'list-visage', lst } });

  return cpy;
};


export const nestVisage = async (cpy: VisageModel, bal: VisageBit, ste: State) => {

  bit = await ste.hunt(ActVsg.READ_VISAGE, { idx: bal.src })
  var dat: FrameBit = bit.vsgBit.dat;

  switch (bal.dat.typ) {

    case SHADE.CONTAINER:
      dat.canLst.push(bal.dat.idx)
      break

    case SHADE.GRAPHIC:
      dat.gphLst.push(bal.dat.idx)
      break

    case SHADE.SPRITE:
      dat.sprLst.push(bal.dat.idx)
      break

    case SHADE.TEXT:
      dat.txtLst.push(bal.dat.idx)

    case SHADE.HEXAGON:
      dat.hexLst.push(bal.dat.idx)
      break

    case SHADE.VIDEO:
      dat.vidLst.push(bal.dat.idx)
      break

    case SHADE.LOOP:
      dat.lopLst.push(bal.dat.idx)
      break
  }


  bit = await ste.hunt(ActVsg.WRITE_VISAGE, { idx: bal.src, dat })

  if (bal.slv != null) bal.slv({ vsgBit: { idx: 'nest-visage' } });

  return cpy;
};


import { VisageModel } from "../visage.model";
import VisageBit from "../fce/visage.bit";
import State from "../../99.core/state";
import FrameBit from "../fce/frame.bit";

import * as VISAGE from "../../val/visage"
import * as SHADE from "../../val/shade"



export default interface FrameBit {
 idx:string;
 src?:string;
 typ?:string;
 width?:number;
 height?:number;
 dex?:number;
 parent?:any;
 bit?: HTMLCanvasElement
 canLst?: string[];
 gphLst?: string[];
 txtLst?: string[];
 sprLst?: string[];
 hexLst?: string[];
 vidLst?: string[];
 lopLst?: string[];
 tonLst?: string[];
}


export default interface VisageBit {
    idx: string;
    src?: string;
    typ:string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  VisageBit  from "./visage.bit";

export default interface Visage {
 // idx:string;
 // visageBitList: VisageBit[];
 // visageBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  VisageBit  from "./fce/visage.bit";

// Visage actions

export const INIT_VISAGE = "[Visage action] Init Visage";
export class InitVisage implements Action {
 readonly type = INIT_VISAGE;
 constructor(public bale: VisageBit) {}
}

export const UPDATE_VISAGE = "[Visage action] Update Visage";
export class UpdateVisage implements Action {
 readonly type = UPDATE_VISAGE;
 constructor(public bale: VisageBit) {}
}

export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage";
 export class FullscreenVisage implements Action {
 readonly type = FULLSCREEN_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const READ_VISAGE = "[Read action] Read Visage";
 export class ReadVisage implements Action {
 readonly type = READ_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const WRITE_VISAGE = "[Write action] Write Visage";
 export class WriteVisage implements Action {
 readonly type = WRITE_VISAGE;
 constructor(public bale: VisageBit) {}
 }

 export const REMOVE_VISAGE = "[Write action] Remove Visage";
 export class RemoveVisage implements Action {
 readonly type = REMOVE_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const CREATE_VISAGE = "[Create action] Create Visage";
 export class CreateVisage implements Action {
 readonly type = CREATE_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const SIZE_VISAGE = "[Size action] Size Visage";
 export class SizeVisage implements Action {
 readonly type = SIZE_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const RENDER_VISAGE = "[Render action] Render Visage";
 export class RenderVisage implements Action {
 readonly type = RENDER_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const DIMENSION_VISAGE = "[Dimension action] Dimension Visage";
 export class DimensionVisage implements Action {
 readonly type = DIMENSION_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const SCREEN_VISAGE = "[Screen action] Screen Visage";
 export class ScreenVisage implements Action {
 readonly type = SCREEN_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const MOUNT_VISAGE = "[Mount action] Mount Visage";
 export class MountVisage implements Action {
 readonly type = MOUNT_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const MAIN_VISAGE = "[Main action] Main Visage";
 export class MainVisage implements Action {
 readonly type = MAIN_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const CLEAR_VISAGE = "[Clear action] Clear Visage";
 export class ClearVisage implements Action {
 readonly type = CLEAR_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const DELETE_VISAGE = "[Delete action] Delete Visage";
 export class DeleteVisage implements Action {
 readonly type = DELETE_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const LIST_VISAGE = "[List action] List Visage";
 export class ListVisage implements Action {
 readonly type = LIST_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export const NEST_VISAGE = "[Nest action] Nest Visage";
 export class NestVisage implements Action {
 readonly type = NEST_VISAGE;
 constructor(public bale: VisageBit) {}
 }
 
export type Actions = | InitVisage | UpdateVisage 
| FullscreenVisage
| ReadVisage
| WriteVisage
| CreateVisage
| SizeVisage
| RenderVisage
| DimensionVisage
| ScreenVisage
| MountVisage
| MainVisage
| ClearVisage
| DeleteVisage
| ListVisage
| RemoveVisage
| NestVisage
export { initVisage  } from "./buz/visage.buzz";
export { updateVisage  } from "./buz/visage.buzz";
export { fullscreenVisage  } from "./buz/visage.buzz";
export { readVisage  } from "./buz/visage.buzz";
export { writeVisage  } from "./buz/visage.buzz";
export { removeVisage  } from "./buz/visage.buzz";
export { createVisage  } from "./buz/visage.buzz";
export { sizeVisage  } from "./buz/visage.buzz";
export { renderVisage  } from "./buz/visage.buzz";
export { dimensionVisage  } from "./buz/visage.buzz";
export { screenVisage  } from "./buz/visage.buzz";
export { mountVisage  } from "./buz/visage.buzz";
export { mainVisage  } from "./buz/visage.buzz";
export { clearVisage  } from "./buz/visage.buzz";
export { deleteVisage  } from "./buz/visage.buzz";
export { listVisage  } from "./buz/visage.buzz";
export { nestVisage  } from "./buz/visage.buzz";
import Visage from "./fce/visage.interface";
import VisageBit from "./fce/visage.interface";

export class VisageModel implements Visage {
 //idx:string;
 //visageBitList: VisageBit[] = [];
 //visageBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./visage.action";
import { VisageModel } from "./visage.model";
import * as Buzz from "./visage.buzzer";
import State from "../99.core/state";

export function reducer(model: VisageModel = new VisageModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_VISAGE:
            return Buzz.updateVisage(clone(model), act.bale, state);

        case Act.INIT_VISAGE:
            return Buzz.initVisage(clone(model), act.bale, state);

        case Act.FULLSCREEN_VISAGE:
            return Buzz.fullscreenVisage(clone(model), act.bale, state);

        case Act.READ_VISAGE:
            return Buzz.readVisage(clone(model), act.bale, state);

        case Act.WRITE_VISAGE:
            return Buzz.writeVisage(clone(model), act.bale, state);

        case Act.CREATE_VISAGE:
            return Buzz.createVisage(clone(model), act.bale, state);

        case Act.SIZE_VISAGE:
            return Buzz.sizeVisage(clone(model), act.bale, state);

        case Act.RENDER_VISAGE:
            return Buzz.renderVisage(clone(model), act.bale, state);

        case Act.DIMENSION_VISAGE:
            return Buzz.dimensionVisage(clone(model), act.bale, state);

        case Act.SCREEN_VISAGE:
            return Buzz.screenVisage(clone(model), act.bale, state);

        case Act.MOUNT_VISAGE:
            return Buzz.mountVisage(clone(model), act.bale, state);

        case Act.MAIN_VISAGE:
            return Buzz.mainVisage(clone(model), act.bale, state);

        case Act.CLEAR_VISAGE:
            return Buzz.clearVisage(clone(model), act.bale, state);

        case Act.DELETE_VISAGE:
            return Buzz.deleteVisage(clone(model), act.bale, state);

        case Act.LIST_VISAGE:
            return Buzz.listVisage(clone(model), act.bale, state);

        case Act.REMOVE_VISAGE:
            return Buzz.removeVisage(clone(model), act.bale, state);
case Act.NEST_VISAGE:
 return Buzz.nestVisage(clone(model), act.bale, state);
 
        default:
            return model;
    }
}

import State from "../99.core/state";


export default class VisageUnit {

    constructor(state: State) {
    }
}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActFce from "../../02.surface.unit/surface.action";
import * as ActCan from "../../03.container.unit/container.action";

import * as ActChr from "../../24.chrome.unit/chrome.action";

import * as ActVsg from "../../21.visage.unit/visage.action";

var bit, val, idx, dex, lst, dat;

export const initChrome = (cpy: ChromeModel, bal: ChromeBit, ste: State) => {
  debugger
  return cpy;
};

export const updateChrome = (cpy: ChromeModel, bal: ChromeBit, ste: State) => {
  return cpy;
};


export const readChrome = async (cpy: ChromeModel, bal: ChromeBit, ste: State) => {

  var slv = bal.slv;
  if (bal.idx == null) bal.idx = 'ert00';
  bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActChr.CREATE_CHROME })
  if (slv != null) slv({ ambBit: { idx: "read-ambit", dat: bit.clcBit.dat } });
  return cpy;

};
export const writeChrome = async (cpy: ChromeModel, bal: ChromeBit, ste: State) => {

  var dat;

  if (bal.src == null) {
    bit = await ste.hunt(ActChr.UPDATE_CHROME, bal)
  } else {
    dat = bal.dat
  }

  bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat, bit: ActChr.CREATE_CHROME })

  //var clkBit = bit.clcBit.dat.clkBit

  if (bal.slv != null) bal.slv({ ambBit: { idx: "write-ambit", dat: bit.clcBit.dat } });


  return cpy;


  return cpy;
};
export const removeChrome = (cpy: ChromeModel, bal: ChromeBit, ste: State) => {
  debugger
  return cpy;
};
export const deleteChrome = (cpy: ChromeModel, bal: ChromeBit, ste: State) => {
  debugger
  return cpy;
};
export const createChrome = async (cpy: ChromeModel, bal: ChromeBit, ste: State) => {

  if (bal.idx == null) bal.idx = 'chr00';
  idx = bal.idx

  var shi: ShineBit = bal.dat
  //if (sim == null) sim = { idx }
  if (shi.idx == null) shi.idx = bal.idx;
  if (shi.src == null) shi.src = "chrome-bit";
  //if (sim.lst == null) sim.lst = [];
  //if (sim.now == null) sim.now = 0;
  //if (sim.cde == null) sim.cde = 'time-code';

  shi.bit = bit

  //timecode should go here
  //sim.clkBit = clkBit;
  //sim.lvl = COSMOS.BLESSED.idx;
  //bit = await ste.hunt(ActClr.FETCH_COLOR, { idx: sim.lvl })
  //sim.pow = bit.clrBit.dat
  //bit = await ste.hunt(ActClr.FETCH_COLOR, { idx: sim.lvl })
  //sim.fte = bit.clrBit.dat

  if (bal.slv != null) bal.slv({ chrBit: { idx: "create-chrome", dat: shi } });
  return cpy;
};
import { ChromeModel } from "../chrome.model";
import ChromeBit from "../fce/chrome.bit";
import State from "../../99.core/state";
import ShineBit from "../fce/shine.bit";


import { Action } from "../99.core/interface/action.interface";
import  ChromeBit  from "./fce/chrome.bit";

// Chrome actions

export const INIT_CHROME = "[Chrome action] Init Chrome";
export class InitChrome implements Action {
 readonly type = INIT_CHROME;
 constructor(public bale: ChromeBit) {}
}

export const UPDATE_CHROME = "[Chrome action] Update Chrome";
export class UpdateChrome implements Action {
 readonly type = UPDATE_CHROME;
 constructor(public bale: ChromeBit) {}
}

export const READ_CHROME = "[Read action] Read Chrome";
 export class ReadChrome implements Action {
 readonly type = READ_CHROME;
 constructor(public bale: ChromeBit) {}
 }
 
export const WRITE_CHROME = "[Write action] Write Chrome";
 export class WriteChrome implements Action {
 readonly type = WRITE_CHROME;
 constructor(public bale: ChromeBit) {}
 }
 
export const REMOVE_CHROME = "[Remove action] Remove Chrome";
 export class RemoveChrome implements Action {
 readonly type = REMOVE_CHROME;
 constructor(public bale: ChromeBit) {}
 }
 
export const DELETE_CHROME = "[Delete action] Delete Chrome";
 export class DeleteChrome implements Action {
 readonly type = DELETE_CHROME;
 constructor(public bale: ChromeBit) {}
 }
 
export const CREATE_CHROME = "[Create action] Create Chrome";
 export class CreateChrome implements Action {
 readonly type = CREATE_CHROME;
 constructor(public bale: ChromeBit) {}
 }
 
export type Actions = | InitChrome | UpdateChrome 
| ReadChrome
| WriteChrome
| RemoveChrome
| DeleteChrome
| CreateChrome
export { initChrome  } from "./buz/chrome.buzz";
export { updateChrome  } from "./buz/chrome.buzz";
export { readChrome  } from "./buz/chrome.buzz";
export { writeChrome  } from "./buz/chrome.buzz";
export { removeChrome  } from "./buz/chrome.buzz";
export { deleteChrome  } from "./buz/chrome.buzz";
export { createChrome  } from "./buz/chrome.buzz";
import Chrome from "./fce/chrome.interface";
import ChromeBit from "./fce/chrome.interface";

export class ChromeModel implements Chrome {
 //idx:string;
 //chromeBitList: ChromeBit[] = [];
 //chromeBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./chrome.action";
import { ChromeModel } from "./chrome.model";
import * as Buzz from "./chrome.buzzer";
import State from "../99.core/state";

export function reducer(model: ChromeModel = new ChromeModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CHROME:
 return Buzz.updateChrome(clone(model), act.bale, state);

 case Act.INIT_CHROME:
 return Buzz.initChrome(clone(model), act.bale, state);

case Act.READ_CHROME:
 return Buzz.readChrome(clone(model), act.bale, state);
 
case Act.WRITE_CHROME:
 return Buzz.writeChrome(clone(model), act.bale, state);
 
case Act.REMOVE_CHROME:
 return Buzz.removeChrome(clone(model), act.bale, state);
 
case Act.DELETE_CHROME:
 return Buzz.deleteChrome(clone(model), act.bale, state);
 
case Act.CREATE_CHROME:
 return Buzz.createChrome(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class ChromeUnit {

    constructor(state: State) {
    }
}

import * as PIXI from 'pixi.js';

export default interface ChromeBit {
    idx:string;
    src?:string;
    typ?:string;
    x:number;
    y:number
    slv?:any;
    val?:number;
    dat?:any;
    bit?:PIXI.Graphics;
}


import  ChromeBit  from "./chrome.bit";

export default interface Chrome {
 // idx:string;
 // chromeBitList: ChromeBit[];
 // chromeBits:any;

}

import * as PIXI from 'pixi.js';;

export default interface ShineBit {
    idx:string;
    src?:string;
    typ?:string;
    x:number;
    y:number

    val?:number;
    dat?:any;
    bit?:PIXI.Graphics;
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import * as ActMnu from "../menu.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action"
import * as ActVrt from "../../act/vurt.action"

import * as ActTrm from "../../act/terminal.action";

var bit, lst, dex

export const initMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  if (bal == null) bal = { idx: null }

  bit = await ste.bus(ActTrm.INIT_TERMINAL, {})

  updateMenu(cpy, bal, ste);

  return cpy;
};

export const updateMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "SHADE PIVOT V1.1", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ActShd.UPDATE_SHADE, ActShd.OPEN_SHADE, ActShd.TEST_SHADE,
  ActShd.RUN_SHADE, ActShd.EDIT_SHADE, ActMnu.CONTAINER_MENU,
  ActMnu.TEXT_MENU, ActMnu.VISAGE_MENU]

  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {

    case ActMnu.TEXT_MENU:
      bit = await ste.hunt(ActMnu.TEXT_MENU, {})
      break;

    case ActShd.TEST_SHADE:
      ste.hunt(ActShd.TEST_SHADE, {})
      break;

    case ActMnu.CONTAINER_MENU:
      bit = await ste.hunt(ActMnu.CONTAINER_MENU, {})
      break;

    case ActMnu.VISAGE_MENU:

      bit = await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActMnu.SHADE_MENU:
      bit = await ste.hunt(ActMnu.SHADE_MENU, {})
      break;

    case ActShd.OPEN_SHADE:
      bit = await ste.hunt(ActShd.OPEN_SHADE, {})
      break;

    case ActShd.BROWSER_SHADE:
      bit = await ste.hunt(ActShd.BROWSER_SHADE, {})
      break;

    case ActShd.RUN_SHADE:
      bit = await ste.hunt(ActShd.RUN_SHADE, {})
      break;

    case ActShd.UPDATE_SHADE:
      bit = await ste.hunt(ActShd.UPDATE_SHADE, {})
      //bit = await ste.hunt(ActShd.OPEN_SHADE, {})
      break;


    case ActShd.EDIT_SHADE:

      bit = await ste.hunt(ActShd.EDIT_SHADE, {})
      bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "PATCHING...", bit: 'local' })
      bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

      lst = [ActShd.PATCH_SHADE]

      bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

      bit = await ste.hunt(ActShd.PATCH_SHADE, {})

      break;

    default:
      bit = await await ste.bus(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  updateMenu(cpy, bal, ste);

  return cpy;
};

export const testMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {
  return cpy;
};

export const closeMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  await ste.bus(ActTrm.CLOSE_TERMINAL, {})

  return cpy;
};

export const shadeMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "SHADE PIVOT V0", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ActMnu.VISAGE_MENU]
  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {

    case ActMnu.VISAGE_MENU:

      bit = await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    default:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;
  }

  shadeMenu(cpy, bal, ste)

  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


export const visageMenu = (cpy: MenuModel, bal: MenuBit, ste: State) => {
  debugger
  return cpy;
};
import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as ActMnu from "../menu.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action"
import * as ActCan from "../../03.container.unit/container.action"

import * as ActTrm from "../../act/terminal.action";

var bit, lst, dex, src;

export const containerMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Container Menu", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ActCan.WRITE_CONTAINER, ActCan.ADD_CONTAINER, ActCan.LIST_CONTAINER, ActMnu.UPDATE_MENU]
  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {

    case ActCan.WRITE_CONTAINER:


    debugger

      bit = await ste.bus(ActVsg.LIST_VISAGE, { src: 'bus' })


      debugger

      if (bit.vsgBit == null) bit.vsgBit = { lst: [] }

      lst = bit.vsgBit.lst;

      if (lst.length == 0) {
        bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Visage present : 0", bit: 'local' })
        bit = await await ste.hunt(ActMnu.CONTAINER_MENU, {})
        return
      }

      bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

      bit = bit.trmBit;
      src = lst[bit.val];

      bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Connecting to " + src, bit: 'local' })

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "identify..."] });
      idx = bit.trmBit.src
      src

      bit = await ste.bus(ActCan.WRITE_CONTAINER, { idx, src })

      bit = await await ste.hunt(ActMnu.CONTAINER_MENU, {})
      break;

    case ActCan.ADD_CONTAINER:

      bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx: "vsg00", src: "indexCanvas", dat: { height: 720 } }, 'remote')
      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActCan.LIST_CONTAINER:




      bit = await ste.bus(ActCan.LIST_CONTAINER, { src: 'bus' })


      debugger
      bit = await await ste.hunt(ActMnu.CONTAINER_MENU, {})
      break;

    default:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;

  }

  return cpy;
};



var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as ActMnu from "../menu.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action"
import * as ActCan from "../../03.container.unit/container.action"
import * as ActTxt from "../../05.text.unit/text.action"

import * as ActTrm from "../../act/terminal.action";

var bit, lst, dex,src;

export const surfaceMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Surface Menu", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ ActTxt.WRITE_TEXT, ActTxt.READ_TEXT, ActMnu.UPDATE_MENU ]
  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {

    case ActTxt.WRITE_TEXT:

      bit = bit.trmBit;
      src = lst[bit.val];

      bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Connecting to " + src, bit: 'local' })

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "identify..."] });
      idx = bit.trmBit.src

      bit = await ste.bus(ActTxt.WRITE_TEXT, { idx, src })

      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

      case ActTxt.READ_TEXT:

        bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx: "vsg00", src: "indexCanvas", dat: { height: 720 } }, 'remote')
        bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
        break;


    default:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;

  }

  return cpy;
};



var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as ActMnu from "../menu.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action"
import * as ActCan from "../../03.container.unit/container.action"
import * as ActTxt from "../../05.text.unit/text.action"

import * as ActTrm from "../../act/terminal.action";

var bit, lst, dex,src;

export const textMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Text Menu", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ ActTxt.WRITE_TEXT, ActTxt.READ_TEXT, ActMnu.UPDATE_MENU ]
  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {

    case ActTxt.WRITE_TEXT:

      bit = bit.trmBit;
      src = lst[bit.val];

      bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Connecting to " + src, bit: 'local' })

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "identify..."] });
      idx = bit.trmBit.src

      bit = await ste.bus(ActTxt.WRITE_TEXT, { idx, src })

      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

      case ActTxt.READ_TEXT:

        bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx: "vsg00", src: "indexCanvas", dat: { height: 720 } }, 'remote')
        bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
        break;


    default:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;

  }

  return cpy;
};



var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as ActMnu from "../menu.action";
import * as ActShd from "../../00.shade.unit/shade.action";
import * as ActVsg from "../../21.visage.unit/visage.action"

import * as ActTrm from "../../act/terminal.action";

var bit, lst, dex

var current = 'None'

export const visageMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Visage PIVOT V0", bit: 'local' })
  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Current " + current, bit: 'local' })

  bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "-----------", bit: "local" })

  var lst = [ActVsg.LIST_VISAGE, ActVsg.MOUNT_VISAGE, ActVsg.REMOVE_VISAGE, ActMnu.UPDATE_MENU]
  bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

  bit = bit.trmBit;
  var idx = lst[bit.val];

  switch (idx) {


    case ActVsg.LIST_VISAGE:

      console.log("list visage")

      debugger

      bit = await ste.bus(ActVsg.LIST_VISAGE, { src: 'bus' });

      debugger

      lst = bit.vsgBit.lst;

      bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

      bit = bit.trmBit;
      idx = lst[bit.val];
      current = idx

      //bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx: "vsg00", src: "indexCanvas", dat: { height: 720 } }, 'remote')
      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;


    case ActVsg.MOUNT_VISAGE:

      console.log("mount visage")

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "Visage IDX"] });
      idx = bit.trmBit.src

      var bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx, src: "indexCanvas", dat: {} });

      current = idx

      //bit = await ste.bus(ActVsg.MOUNT_VISAGE, { idx: "vsg00", src: "indexCanvas", dat: { height: 720 } }, 'remote')
      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActVsg.REMOVE_VISAGE:

      bit = await ste.bus(ActVsg.LIST_VISAGE, { src: 'bus' }, 'remote')
      if (bit.vsgBit == null) bit.vsgBit = { lst: [] }

      lst = bit.vsgBit.lst;

      if (lst.length == 0) {
        bit = await ste.bus(ActTrm.WRITE_TERMINAL, { src: "Visage present : 0", bit: 'local' })
        bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
        return
      }

      bit = await ste.bus(ActTrm.UPDATE_TERMINAL, { lst })

      bit = bit.trmBit;
      idx = lst[bit.val];

      bit = await ste.bus(ActVsg.REMOVE_VISAGE, { idx }, 'remote')

      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActVsg.FULLSCREEN_VISAGE:
      bit = await ste.bus(ActVsg.FULLSCREEN_VISAGE, {}, 'remote')
      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActVsg.SIZE_VISAGE:

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "W VALUE"] });
      var w = Number(bit.trmBit.src);

      bit = await ste.bus(ActTrm.INPUT_TERMINAL, { lst: ["", "H VALUE"] });
      var h = Number(bit.trmBit.src);

      bit = await ste.bus(ActVsg.SIZE_VISAGE, { dat: { w, h } }, 'remote')
      bit = await await ste.hunt(ActMnu.VISAGE_MENU, {})
      break;

    case ActMnu.UPDATE_MENU:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;

    default:
      bit = await await ste.hunt(ActMnu.UPDATE_MENU, {})
      break;

  }

  return cpy;
};



var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";


export default interface MenuBit {
    idx: string;
    src?: string;
    lst?: any;
}



import  MenuBit  from "./menu.bit";

export default interface Menu {
 // idx:string;
 // menuBitList: MenuBit[];
 // menuBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import MenuBit from "./fce/menu.bit";

export const INIT_MENU = "[Menu action] Init Menu";
export class InitMenu implements Action {
  readonly type = INIT_MENU;
  constructor(public bale: MenuBit) { }
}

export const UPDATE_MENU = "[Menu action] Update Menu";
export class UpdateMenu implements Action {
  readonly type = UPDATE_MENU;
  constructor(public bale: MenuBit) { }
}


export const TEST_MENU = "[Menu action] Test Menu";
export class TestMenu implements Action {
  readonly type = TEST_MENU;
  constructor(public bale: MenuBit) { }
}

export const CLOSE_MENU = "[Menu action] Close Menu";
export class CloseMenu implements Action {
  readonly type = CLOSE_MENU;
  constructor(public bale: MenuBit) { }
}

export const SHADE_MENU = "[Shade action] Shade Menu";
 export class ShadeMenu implements Action {
 readonly type = SHADE_MENU;
 constructor(public bale: MenuBit) {}
 }

export const VISAGE_MENU = "[Visage action] Visage Menu";
 export class VisageMenu implements Action {
 readonly type = VISAGE_MENU;
 constructor(public bale: MenuBit) {}
 }

 export const CONTAINER_MENU = "[Visage action] Container Menu";
 export class ContainerMenu implements Action {
 readonly type = CONTAINER_MENU;
 constructor(public bale: MenuBit) {}
 }

 export const TEXT_MENU = "[Visage action] Text Menu";
 export class TextMenu implements Action {
 readonly type = TEXT_MENU;
 constructor(public bale: MenuBit) {}
 }




export type Actions = InitMenu | UpdateMenu | TestMenu | CloseMenu
| ShadeMenu
| VisageMenu
| ContainerMenu
| TextMenu

export { initMenu } from "./buz/00.menu.buzz";
export { updateMenu } from "./buz/00.menu.buzz";
export { testMenu } from "./buz/00.menu.buzz";
export { closeMenu } from "./buz/00.menu.buzz";
export { shadeMenu  } from "./buz/00.menu.buzz";
export { visageMenu  } from "./buz/visage-menu.buzz";
export { containerMenu  } from "./buz/container-menu.buzz";
export { textMenu  } from "./buz/text-menu.buzz";

import Menu from "./fce/menu.interface";
import MenuBit from "./fce/menu.interface";

export class MenuModel implements Menu {
    lst: string[] = []
    //idx:string;
    //menuBitList: MenuBit[] = [];
    //menuBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./menu.action";
import { MenuModel } from "./menu.model";
import * as Buzz from "./menu.buzzer";
import State from "../99.core/state";

export function reducer(model: MenuModel = new MenuModel(), act: Act.Actions, state?: State) {
  switch (act.type) {
    case Act.UPDATE_MENU:
      return Buzz.updateMenu(clone(model), act.bale, state);

    case Act.INIT_MENU:
      return Buzz.initMenu(clone(model), act.bale, state);

    case Act.TEST_MENU:
      return Buzz.testMenu(clone(model), act.bale, state);

    case Act.CLOSE_MENU:
      return Buzz.closeMenu(clone(model), act.bale, state);

    case Act.SHADE_MENU:
      return Buzz.shadeMenu(clone(model), act.bale, state);

    case Act.VISAGE_MENU:
      return Buzz.visageMenu(clone(model), act.bale, state);

    case Act.CONTAINER_MENU:
      return Buzz.containerMenu(clone(model), act.bale, state);

      case Act.TEXT_MENU:
        return Buzz.textMenu(clone(model), act.bale, state);

    default:
      return model;
  }
}

import State from "../99.core/state";


export default class MenuUnit {

    constructor(state: State) {
    }
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BusUnit {

    constructor(state: State) {
    }
}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=action.interface.js.map
export interface Action<T = any> {
  type: string;
  bale?: T;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=model.interface.js.map
export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
 export const CREATE_CONSOLE = "[Create action] Create Console";

export const INIT_DISK = "[Disk action] Init Disk";
export const UPDATE_DISK = "[Disk action] Update Disk";
export const READ_DISK = "[Disk action] Read Disk";
export const WRITE_DISK = "[Disk action] Write Disk";
export const LIST_DISK = "[List action] List Disk";
export const LOAD_LIST_DISK = "[Load_list action] Load_list Disk";
export const COPY_DISK = "[Copy action] Copy Disk";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const READY_SPACE = "[Ready action] Ready Space";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const OPEN_TERMINAL = "[Terminal action] Open Terminal";
export const FOCUS_TERMINAL = "[Terminal action] Focus Terminal";
export const WRITE_TERMINAL = "[Terminal action] Write Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const CLEAR_TERMINAL = "[Terminal action] Clear Terminal";
export const INPUT_TERMINAL = "[Terminal action] Input Terminal";
export const TABLE_TERMINAL = "[Terminal action] Table Terminal";
export const CLOSE_TERMINAL = "[Terminal action] Close Terminal";
export const ROOT_TERMINAL = "[Terminal action] Root Terminal";
export const CONTENT_TERMINAL = "[Terminal action] Content Terminal";
export const ADD_PORT = "[Terminal action] Add Port";

export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import ShadeUnit from "./00.shade.unit/shade.unit";
import SurfaceUnit from "./02.surface.unit/surface.unit";
import ContainerUnit from "./03.container.unit/container.unit";
import GraphicUnit from "./04.graphic.unit/graphic.unit";
import TextUnit from "./05.text.unit/text.unit";
import SpriteUnit from "./06.sprite.unit/sprite.unit";
import HexagonUnit from "./07.hexagon.unit/hexagon.unit";
import FocigonUnit from "./08.focigon.unit/focigon.unit";
import LoopUnit from "./09.loop.unit/loop.unit";
import ToonUnit from "./10.toon.unit/toon.unit";
import VideoUnit from "./11.video.unit/video.unit";
import FrameUnit from "./12.frame.unit/frame.unit";
import ApplicationUnit from "./20.application.unit/application.unit";
import VisageUnit from "./21.visage.unit/visage.unit";
import ChromeUnit from "./24.chrome.unit/chrome.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import MenuUnit from "./98.menu.unit/menu.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Shade from "./00.shade.unit/fce/shade.interface";
import { ShadeModel } from "./00.shade.unit/shade.model";
import Surface from "./02.surface.unit/fce/surface.interface";
import { SurfaceModel } from "./02.surface.unit/surface.model";
import Container from "./03.container.unit/fce/container.interface";
import { ContainerModel } from "./03.container.unit/container.model";
import Graphic from "./04.graphic.unit/fce/graphic.interface";
import { GraphicModel } from "./04.graphic.unit/graphic.model";
import Text from "./05.text.unit/fce/text.interface";
import { TextModel } from "./05.text.unit/text.model";
import Sprite from "./06.sprite.unit/fce/sprite.interface";
import { SpriteModel } from "./06.sprite.unit/sprite.model";
import Hexagon from "./07.hexagon.unit/fce/hexagon.interface";
import { HexagonModel } from "./07.hexagon.unit/hexagon.model";
import Focigon from "./08.focigon.unit/fce/focigon.interface";
import { FocigonModel } from "./08.focigon.unit/focigon.model";
import Loop from "./09.loop.unit/fce/loop.interface";
import { LoopModel } from "./09.loop.unit/loop.model";
import Toon from "./10.toon.unit/fce/toon.interface";
import { ToonModel } from "./10.toon.unit/toon.model";
import Video from "./11.video.unit/fce/video.interface";
import { VideoModel } from "./11.video.unit/video.model";
import Frame from "./12.frame.unit/fce/frame.interface";
import { FrameModel } from "./12.frame.unit/frame.model";
import Application from "./20.application.unit/fce/application.interface";
import { ApplicationModel } from "./20.application.unit/application.model";
import Visage from "./21.visage.unit/fce/visage.interface";
import { VisageModel } from "./21.visage.unit/visage.model";
import Chrome from "./24.chrome.unit/fce/chrome.interface";
import { ChromeModel } from "./24.chrome.unit/chrome.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Menu from "./98.menu.unit/fce/menu.interface";
import { MenuModel } from "./98.menu.unit/menu.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [ShadeUnit,SurfaceUnit,ContainerUnit,GraphicUnit,TextUnit,SpriteUnit,HexagonUnit,FocigonUnit,LoopUnit,ToonUnit,VideoUnit,FrameUnit,ApplicationUnit,VisageUnit,ChromeUnit,CollectUnit,MenuUnit,BusUnit];

import * as reduceFromShade from "./00.shade.unit/shade.reduce";
import * as reduceFromSurface from "./02.surface.unit/surface.reduce";
import * as reduceFromContainer from "./03.container.unit/container.reduce";
import * as reduceFromGraphic from "./04.graphic.unit/graphic.reduce";
import * as reduceFromText from "./05.text.unit/text.reduce";
import * as reduceFromSprite from "./06.sprite.unit/sprite.reduce";
import * as reduceFromHexagon from "./07.hexagon.unit/hexagon.reduce";
import * as reduceFromFocigon from "./08.focigon.unit/focigon.reduce";
import * as reduceFromLoop from "./09.loop.unit/loop.reduce";
import * as reduceFromToon from "./10.toon.unit/toon.reduce";
import * as reduceFromVideo from "./11.video.unit/video.reduce";
import * as reduceFromFrame from "./12.frame.unit/frame.reduce";
import * as reduceFromApplication from "./20.application.unit/application.reduce";
import * as reduceFromVisage from "./21.visage.unit/visage.reduce";
import * as reduceFromChrome from "./24.chrome.unit/chrome.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromMenu from "./98.menu.unit/menu.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 shade : reduceFromShade.reducer, 
surface : reduceFromSurface.reducer, 
container : reduceFromContainer.reducer, 
graphic : reduceFromGraphic.reducer, 
text : reduceFromText.reducer, 
sprite : reduceFromSprite.reducer, 
hexagon : reduceFromHexagon.reducer, 
focigon : reduceFromFocigon.reducer, 
loop : reduceFromLoop.reducer, 
toon : reduceFromToon.reducer, 
video : reduceFromVideo.reducer, 
frame : reduceFromFrame.reducer, 
application : reduceFromApplication.reducer, 
visage : reduceFromVisage.reducer, 
chrome : reduceFromChrome.reducer, 
collect : reduceFromCollect.reducer, 
menu : reduceFromMenu.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 shade : Shade = new ShadeModel();
surface : Surface = new SurfaceModel();
container : Container = new ContainerModel();
graphic : Graphic = new GraphicModel();
text : Text = new TextModel();
sprite : Sprite = new SpriteModel();
hexagon : Hexagon = new HexagonModel();
focigon : Focigon = new FocigonModel();
loop : Loop = new LoopModel();
toon : Toon = new ToonModel();
video : Video = new VideoModel();
frame : Frame = new FrameModel();
application : Application = new ApplicationModel();
visage : Visage = new VisageModel();
chrome : Chrome = new ChromeModel();
collect : Collect = new CollectModel();
menu : Menu = new MenuModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  

  
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
"use strict";
exports.__esModule = true;
exports.CYAN = exports.MAGENTA = exports.YELLOW = exports.GREEN = exports.RED = void 0;
exports.RED = "\x1b[31m%s\x1b[0m";
exports.GREEN = "\x1b[32m%s\x1b[0m";
exports.YELLOW = "\x1b[33m%s\x1b[0m";
exports.MAGENTA = "\x1b[34m%s\x1b[0m";
exports.CYAN = "\x1b[36m%s\x1b[0m";
//# sourceMappingURL=console.js.map
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

"use strict";
exports.__esModule = true;
exports.WISE_NORTH_EAST = exports.WISE_NORTH = exports.WISE_NORTH_WEST = exports.WISE_WEST = exports.WISE_SOUTH_WEST = exports.WISE_SOUTH = exports.WISE_SOUTH_EAST = exports.WISE_EAST = exports.NORTH_EAST = exports.NORTH = exports.NORTH_WEST = exports.WEST = exports.SOUTH_WEST = exports.SOUTH = exports.SOUTH_EAST = exports.EAST = void 0;
exports.EAST = "E";
exports.SOUTH_EAST = "SE";
exports.SOUTH = "S";
exports.SOUTH_WEST = "SW";
exports.WEST = "W";
exports.NORTH_WEST = "NW";
exports.NORTH = "N";
exports.NORTH_EAST = "NE";
exports.WISE_EAST = "Wise E";
exports.WISE_SOUTH_EAST = "Wise SE";
exports.WISE_SOUTH = "Wise S";
exports.WISE_SOUTH_WEST = "Wise SW";
exports.WISE_WEST = "Wise W";
exports.WISE_NORTH_WEST = "Wise NW";
exports.WISE_NORTH = "Wise N";
exports.WISE_NORTH_EAST = "Wise NE";
//# sourceMappingURL=direction.js.map
export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

"use strict";
exports.__esModule = true;
exports.CIRCLE = exports.ROUNDED_RECTANGLE = exports.RECTANGLE = void 0;
exports.RECTANGLE = "rectangle";
exports.ROUNDED_RECTANGLE = "rounded-rectangle";
exports.CIRCLE = "circle";
//# sourceMappingURL=graphic.js.map
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

"use strict";
exports.__esModule = true;
exports.HEXMAP = exports.FOCUS = void 0;
exports.FOCUS = "focus";
exports.HEXMAP = "hexmap";
//# sourceMappingURL=hexagon.js.map
export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
"use strict";
exports.__esModule = true;
exports.PASTURE = exports.FANG_SWAMP = exports.GEORGIA = exports.GALLBLADDER = void 0;
exports.GALLBLADDER = "00000.gallbladder";
exports.GEORGIA = "00001.georgia";
exports.FANG_SWAMP = "00002.fang-swamp";
exports.PASTURE = "00003.pasture";
//# sourceMappingURL=hexmap.js.map
export const GALLBLADDER: string = "00000.gallbladder";
export const GEORGIA: string = "00001.georgia";
export const FANG_SWAMP: string = "00002.fang-swamp";
export const PASTURE: string = "00003.pasture";
"use strict";
exports.__esModule = true;
exports.MAGENTA = exports.YELLOW = exports.BLUE = exports.GREEN = exports.RED = exports.CYAN = exports.CLEAN = exports.MENU_SINGLE = exports.TIMELINE = exports.SPACE = void 0;
exports.SPACE = "space";
exports.TIMELINE = "timeline";
exports.MENU_SINGLE = "menu_single";
exports.CLEAN = "clean";
exports.CYAN = "cyan";
exports.RED = "red";
exports.GREEN = "green";
exports.BLUE = "blue";
exports.YELLOW = "yellow";
exports.MAGENTA = "magenta";
//# sourceMappingURL=markup.js.map
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

"use strict";
exports.__esModule = true;
exports.LOOP = exports.VIDEO = exports.HEXAGON = exports.SPRITE = exports.TEXT = exports.GRAPHIC = exports.CONTAINER = exports.SURFACE = exports.VISAGE = void 0;
exports.VISAGE = "visage";
exports.SURFACE = "surface";
exports.CONTAINER = "container";
exports.GRAPHIC = "graphic";
exports.TEXT = "text";
exports.SPRITE = "sprite";
exports.HEXAGON = "hexagon";
exports.VIDEO = "video";
exports.LOOP = "loop";
//# sourceMappingURL=shade.js.map
export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
"use strict";
exports.__esModule = true;
exports.MOUNT_WIDTH = exports.MOUNT_HEIGHT = exports.MOUNT_PART = exports.MOUNT_FULL = exports.SCREEN = void 0;
exports.SCREEN = "screen-visage";
exports.MOUNT_FULL = "mount-visage-full";
exports.MOUNT_PART = "mount-visage-part";
exports.MOUNT_HEIGHT = "mount-visage-height";
exports.MOUNT_WIDTH = "mount-visage-width";
//# sourceMappingURL=visage.js.map
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";

export const initSolid = (cpy: SolidModel, bal: SolidBit, ste: State) => {





    if (bal.slv != null) bal.slv({ intBit: { idx: "init-solid" } });


    return cpy;
};

export const updateSolid = (cpy: SolidModel, bal: SolidBit, ste: State) => {
    return cpy;
};


export const shadeSolid = (cpy: SolidModel, bal:SolidBit, ste: State) => {
 debugger
 return cpy;
 };


 
import { SolidModel } from "../solid.model";
import SolidBit from "../fce/solid.bit";
import State from "../../99.core/state";

export default interface SolidBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  SolidBit  from "./solid.bit";

export default interface Solid {
 // idx:string;
 // solidBitList: SolidBit[];
 // solidBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SolidBit  from "./fce/solid.bit";

// Solid actions

export const INIT_SOLID = "[Solid action] Init Solid";
export class InitSolid implements Action {
 readonly type = INIT_SOLID;
 constructor(public bale: SolidBit) {}
}

export const UPDATE_SOLID = "[Solid action] Update Solid";
export class UpdateSolid implements Action {
 readonly type = UPDATE_SOLID;
 constructor(public bale: SolidBit) {}
}

export const SHADE_SOLID = "[Shade action] Shade Solid";
 export class ShadeSolid implements Action {
 readonly type = SHADE_SOLID;
 constructor(public bale: SolidBit) {}
 }
 
export type Actions = | InitSolid | UpdateSolid 
| ShadeSolid
export { initSolid  } from "./buz/solid.buzz";
export { updateSolid  } from "./buz/solid.buzz";
export { shadeSolid  } from "./buz/solid.buzz";
import Solid from "./fce/solid.interface";
import SolidBit from "./fce/solid.interface";

export class SolidModel implements Solid {
 //idx:string;
 //solidBitList: SolidBit[] = [];
 //solidBits: any = {};
 shade:any;
}

import * as Act from "./solid.action";
import { SolidModel } from "./solid.model";
import * as Buzz from "./solid.buzzer";
import State from "../99.core/state";


export function reducer(model: SolidModel = new SolidModel(), act: Act.Actions,  state?: State ) {
 
    var clone = require('clone-deep');

switch (act.type) {
 
 case Act.UPDATE_SOLID:
 return Buzz.updateSolid(clone(model), act.bale, state);

 case Act.INIT_SOLID:
 return Buzz.initSolid(clone(model), act.bale, state);

case Act.SHADE_SOLID:
 return Buzz.shadeSolid(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class SolidUnit {

 constructor(state: State) {
 }
}

window.SOLID = require("../dist/111.solid/hunt");

window.MQTT = require("async-mqtt");

window.SOLID.ActSSld = require("../dist/111.solid/00.solid.unit/solid.action");

'use server'

import * as Import from "./BEE";
import State from "./99.core/state";

var dex = 0;

let instance = null;

var sim = {
  hunt: (a, b) => { },
  state: null
};

sim.hunt = (typ, obj) => { return host(obj, typ) }

var host = (obj, typ) => {

  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);

  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {

  if (!instance) {

    if (sim.state != null) return;
    sim.state = new State();
    sim.state.pivot = sim;
    sim.state.hunt = sim.hunt
    for (var k in Import.list) new Import.list[k](sim.state);
    instance = sim
  }


  return instance

};


export const earth = async (typ, obj) => {
  return sim.hunt(typ, obj)
}
import { Action } from "../99.core/interface/action.interface";
import  BabylonBit  from "./fce/babylon.bit";

// Babylon actions

export const INIT_BABYLON = "[Babylon action] Init Babylon";
export class InitBabylon implements Action {
 readonly type = INIT_BABYLON;
 constructor(public bale: BabylonBit) {}
}

export const UPDATE_BABYLON = "[Babylon action] Update Babylon";
export class UpdateBabylon implements Action {
 readonly type = UPDATE_BABYLON;
 constructor(public bale: BabylonBit) {}
}

export const OPEN_BABYLON = "[Babylon action] Open Babylon";
export class OpenBabylon implements Action {
 readonly type = OPEN_BABYLON;
 constructor(public bale: BabylonBit) {}
}

export const RECORD_BABYLON = "[Babylon action] Record Babylon";
export class RecordBabylon implements Action {
 readonly type = RECORD_BABYLON;
 constructor(public bale: BabylonBit) {}
}


export const ACTION_BABYLON = "[Babylon action] Action Babylon";
export class ActionBabylon implements Action {
 readonly type = ACTION_BABYLON;
 constructor(public bale: BabylonBit) {}
}


export const CUT_BABYLON = "[Babylon action] Cut Babylon";
export class CutBabylon implements Action {
 readonly type = CUT_BABYLON;
 constructor(public bale: BabylonBit) {}
}

export const CAMERA_BABYLON = "[Babylon action] Cut Babylon";
export class CameraBabylon implements Action {
 readonly type = CAMERA_BABYLON;
 constructor(public bale: BabylonBit) {}
}

export type Actions = | InitBabylon | UpdateBabylon | OpenBabylon | RecordBabylon 
| ActionBabylon
| CutBabylon
| CameraBabylon
;

export { initBabylon  } from "./buz/babylon.buzz";
export { updateBabylon  } from "./buz/babylon.buzz";
export { openBabylon  } from "./buz/openBabylon.buzz";
export { recordBabylon  } from "./buz/babylon.buzz";
export { actionBabylon  } from "./buz/babylon.buzz";
export { cutBabylon  } from "./buz/babylon.buzz";
export { cameraBabylon  } from "./buz/babylon.buzz";

import Babylon from "./fce/babylon.interface";
import BabylonBit from "./fce/babylon.interface";

export class BabylonModel implements Babylon {
 //idx:string;
 //babylonBitList: BabylonBit[] = [];
 //babylonBits: any = {};
 recorder:any;
 engine:any;
 scene:any;
 mmdRuntime:any;
 motion:any;
}

import * as Act from "./babylon.action";
import { BabylonModel } from "./babylon.model";
import * as Buzz from "./babylon.buzzer";
import State from "../99.core/state";

export function reducer(model: BabylonModel = new BabylonModel(), act: Act.Actions, state?: State) {
        
    var clone = require('clone-deep');

    switch (act.type) {

        case Act.UPDATE_BABYLON:
            return Buzz.updateBabylon(clone(model), act.bale, state);

        case Act.INIT_BABYLON:
            return Buzz.initBabylon(clone(model), act.bale, state);

        case Act.OPEN_BABYLON:
            return Buzz.openBabylon(clone(model), act.bale, state);


        case Act.RECORD_BABYLON:
            return Buzz.recordBabylon(clone(model), act.bale, state);


        case Act.ACTION_BABYLON:
            return Buzz.actionBabylon(clone(model), act.bale, state);



        case Act.CUT_BABYLON:
            return Buzz.cutBabylon(structuredClone(model), act.bale, state);

        default:
            return model;
    }
}

import State from "../99.core/state";

export default class BabylonUnit {

 constructor(state: State) {
 }
}

import * as BABYLON from 'babylonjs'
import HavokPhysics from "@babylonjs/havok";
//import "babylon-mmd/esm/Loader/pmxLoader";


import * as ActMku from "../../10.miku.unit/miku.action"
import * as ActScr from "../../08.screen.unit/screen.action"



declare const BABYLONMMD: any;

import * as ActBby from "../../01.babylon.unit/babylon.action";
//import * as ActFce from "../../02.surface.unit/surface.action";

var bit


export const initBabylon = async (cpy: BabylonModel, bal: BabylonBit, ste: State) => {

    debugger

    bal.slv({ intBit: { idx: "init-babylon" } });

    return cpy;
};

var opened = false
var recorder;


export const updateBabylon = (cpy: BabylonModel, bal: BabylonBit, ste: State) => {


    return cpy;
};


export const recordBabylon = (cpy: BabylonModel, bal: BabylonBit, ste: State) => {

    recorder.startRecording("000.webm", 22);


    bal.slv({ bbyBit: { idx: "record-babylon" } });

    return cpy;
};

export const actionBabylon = async (cpy: BabylonModel, bal: BabylonBit, ste: State) => {


    recorder.startRecording("000.webm", 60).then(async (videoBlob) => {

        const formData = new FormData();
        formData.append('video', videoBlob, "000.webm"); // 'video' must match the server-side field name

        try {
            const response = await fetch('/api/upload-video', {
                method: 'POST',
                body: formData,
            });

            if (response.ok) {
                const data = await response.json();
                console.log('Upload successful:', data);
                // Handle success (e.g., display a message)
            } else {
                console.error('Upload failed:', response.status, response.statusText);
                // Handle error (e.g., display an error message)
            }
        } catch (error) {
            console.error('Error during upload:', error);
            // Handle network errors, etc.
        }


        //now send to primal mom

        // Do Something with the videoBlob.
    });



    //var recorder = new BABYLON.VideoRecorder(cpy.engine);
    //recorder.startRecording("000.webm", 22);





    bal.slv({ bbyBit: { idx: "action-babylon" } });
    return cpy;
};


export const cutBabylon = (cpy: BabylonModel, bal: BabylonBit, ste: State) => {


    recorder.stopRecording()



    bal.slv({ bbyBit: { idx: "cut-babylon" } });
    return cpy;
};


export const cameraBabylon = (cpy: BabylonModel, bal: BabylonBit, ste: State) => {

    bal.slv({ bbyBit: { idx: "camera-babylon" } });
    return cpy;
};


import { BabylonModel } from "../babylon.model";
import BabylonBit from "../fce/babylon.bit";
import State from "../../99.core/state";
import * as BABYLON from 'babylonjs'
import HavokPhysics from "@babylonjs/havok";
//import "babylon-mmd/esm/Loader/pmxLoader";

import * as ActMku from "../../10.miku.unit/miku.action"
import * as ActScr from "../../08.screen.unit/screen.action"

import { BabylonModel } from "../babylon.model";
import BabylonBit from "../fce/babylon.bit";
import State from "../../99.core/state";

declare const BABYLONMMD: any;

import * as ActBby from "../../01.babylon.unit/babylon.action";
//import * as ActFce from "../../02.surface.unit/surface.action";

var bit

var opened = false
var recorder;

export const openBabylon = async (cpy: BabylonModel, bal: BabylonBit, ste: State) => {

    if (opened == true) {
        return
    }

    opened = true;

    async function getInitializedHavok() {
        return await HavokPhysics();
    }

    const canvas = document.getElementById(bal.src);

    canvas['height'] = 1080
    canvas['width'] = 1920

    const engine = new BABYLON.Engine(canvas as any, true);
    const scene = new BABYLON.Scene(engine);

    cpy.scene = scene;


    cpy.scene.clearColor = new BABYLON.Color3(0, 0, 0); 

    var light = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);

    engine.runRenderLoop(function () {
        scene.render();
    });

    cpy.engine = engine

    const camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 0, -10), scene);

    const v0 = new BABYLON.Vector3(0, 0, 0)

    camera.setTarget(v0);
    camera.attachControl(canvas, true);

    //var camera = new BABYLON.FreeCamera('camera1', new BABYLON.Vector3(0, 0, -10), scene);
    // Target the camera to scene origin
    //camera.setTarget(BABYLON.Vector3.Zero());
    // Attach the camera to the canvas
    //camera.attachControl(canvas, false);
    //camera.position.y = 10
    //camera.position.x = 0
    //camera.position.z = -30

    //FOLLOW
    //const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0, 10, -10), scene);
    //camera.radius = 30;
    //camera.heightOffset = 10;
    //camera.rotationOffset = 0;
    //camera.cameraAcceleration = 0.005;
    //camera.maxCameraSpeed = 10;
    //camera.attachControl(canvas, true);
    recorder = new BABYLON.VideoRecorder(cpy.engine);

    globalThis.HK = await getInitializedHavok()

    await new Promise((resolve) => {
        const babylonMmdScript = document.createElement("script");
        babylonMmdScript.src = "./babylon.mmd.min.js";
        document.head.appendChild(babylonMmdScript);
        babylonMmdScript.onload = resolve;
    });

    BABYLONMMD.SdefInjector.OverrideEngineCreateEffect(engine);

    const havokPlugin = new BABYLON.HavokPlugin();

    scene.enablePhysics(new BABYLON.Vector3(0, -98, 0), havokPlugin);

    // bit = await ste.hunt(ActScr.WRITE_SCREEN, { idx: 'src00' })


    const mmdRuntime = new BABYLONMMD.MmdRuntime(scene, new BABYLONMMD.MmdPhysics(scene));
    mmdRuntime.register(scene);

    cpy.mmdRuntime = mmdRuntime

    const mmdCamera = new BABYLONMMD.MmdCamera("MmdCamera", new BABYLON.Vector3(0, 10, 0), scene);
    mmdCamera.maxZ = 5000;

    const vmdLoader = new BABYLONMMD.VmdLoader(scene);
    const motion = await vmdLoader.loadAsync("motion", "./toon/000/MIKU.vmd")

    cpy.motion = motion;

    mmdRuntime.setCamera(mmdCamera);
    //mmdCamera.addAnimation( motion );
    //mmdCamera.setAnimation("motion");

    var planeOpts = {
        height: 108.4762,
        width: 200.3967,
        sideOrientation: BABYLON.Mesh.DOUBLESIDE
    };
    var ANote0Video = BABYLON.MeshBuilder.CreatePlane("plane", planeOpts, scene);
    var vidPos = (new BABYLON.Vector3(-14, 23, 133))
    ANote0Video.position = vidPos;
    var ANote0VideoMat = new BABYLON.StandardMaterial("m", scene);
    var ANote0VideoVidTex = new BABYLON.VideoTexture("vidtex", "video/000.mp4", scene);
    ANote0VideoMat.diffuseTexture = ANote0VideoVidTex;
    ANote0VideoMat.roughness = 1;
    //ANote0VideoMat.emissiveColor = new BABYLON.Color3.White();
    ANote0Video.material = ANote0VideoMat;

    //bit = await ste.hunt(ActMku.WRITE_MIKU, { idx: 'mku00a', src: 'greasi/00.pmx', dat: { position: { z: -7 } } })
    //bit = await ste.hunt(ActMku.WRITE_MIKU, { idx: 'mku00a', dat: { position: { z: 40, x: -15 } } })

    function resizeCanvasToFixedHeight() {
        const targetAspectRatio = 16 / 9;

        // 1. Set the canvas height to always match the window's inner height.
        const newHeight = window.innerHeight + window.innerHeight * .3;

        // 2. Calculate the required width to maintain the 16:9 aspect ratio.
        const newWidth = newHeight * targetAspectRatio;

        // 3. Apply the new dimensions to the canvas element.
        canvas['width'] = newWidth;
        canvas['height'] = newHeight;

        // 4. Tell the Babylon.js engine to resize its rendering buffers.
        engine.resize();
    }

    window.addEventListener('resize', resizeCanvasToFixedHeight);

    resizeCanvasToFixedHeight();

    bal.slv({ intBit: { idx: "open-babylon" } });
    return cpy;

    //const mmdMesh = await BABYLON.SceneLoader.ImportMeshAsync(undefined, "./greasi/00.pmx", undefined, scene).then((result) => result.meshes[0]);
    //mmdMesh.position = new BABYLON.Vector3( 1, 2, 3);
    //const modelMesh = mmdMesh as BABYLON.Mesh
    //modelMesh.receiveShadows = true;;
    //for(const mesh of modelMesh.metadata.meshes) shadowGenerator.addShadowCaster(mesh);
    //const mmdModel = mmdRuntime.createMmdModel(modelMesh);
    //mmdModel.addAnimation(motion);
    //mmdModel.setAnimation("motion");
    //mmdRuntime.playAnimation();


    // NOTE:: SET CAMERA TARGET AFTER THE TARGET'S CREATION AND NOTE CHANGE FROM BABYLONJS V 2.5
    // targetMesh created here.
    //camera.target = modelMesh; // version 2.4 and earlier
    //camera.lockedTarget = modelMesh; //ver

    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku01b', src:'mickey/00.pmx', dat: { position:{z:-7}} })
    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku01b', dat: { position:{x:-10,z:40}} })

    //for ( var i = 0; i < 100; i++){

    //  bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku' + i, src:'mickey/00.pmx', dat: { position:{z:-7}} })
    //  bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku' + i, dat: { position:{x: i * -1  ,z:40}} })

    //}



    // bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku01', src:'orbie/00.pmx', dat: { position:{z:-7}} })
    // bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku01', dat: { position:{x:-10, z:100}} })

    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku02', src:'orbie/00.pmx', dat: { position:{z:-7}} })
    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku02', dat: { position:{x:-20, z:100}} })


    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku03', src:'orbie/01.pmx', dat: { position:{z:-7}} })
    //bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku03', dat: { position:{x:-30, z:100}} })


    //setInterval( async ()=>{

    //    value -= 1
    //    bit = await ste.hunt( ActMku.WRITE_MIKU, { idx:'mku00', dat: { position:{z:value}} })


    // }, 111 )

    //const plane = BABYLON.MeshBuilder.CreatePlane("plane", { width: 1080, height: 720 }, scene);

    // Create a material and texture
    //const material = new BABYLON.StandardMaterial("planeMaterial", scene);
    //const texture = new BABYLON.Texture("img/000.png", scene);
    //material.diffuseTexture = texture;

    // Apply the material to the plane
    //plane.material = material;
    //plane.scaling.x = .05;
    //plane.scaling.y = .05;
    //plane.scaling.z = .05;

    //plane.position.y += 10;
    //plane.position.x -= 1;

    ///PIXI
    //PIXI
    //PIXI

    //const app = new PIXI.Application();
    //await app.init({ background: '#00ff00', resizeTo: window });
    //const stageSize = new BABYLON.Vector2(1280, 720)
    //const out = BABYLON.MeshBuilder.CreateGround('out', { width: 1, height: 1 }, scene)
    //const baseOutScale = stageSize.clone().scale(0.05)
    //out.scaling.set(baseOutScale.x, 1, baseOutScale.y)
    //out.rotation.x = -Math.PI * 0.5
    //const outMat = new BABYLON.StandardMaterial('outMat', scene)
    //out.material = outMat
    //out.isVisible = true
    //out.position.z = 130;
    //out.position.y = 10;
    //out.position.x = -10;
    //const pixiDt = new BABYLON.DynamicTexture('pixi-extract', { width: stageSize.x, height: stageSize.y }, scene, false)
    //const pCtx = pixiDt.getContext()
    //outMat.emissiveTexture = pixiDt
    //outMat.diffuseTexture = pixiDt
    //outMat.opacityTexture = pixiDt
    //pixiDt.hasAlpha = true
    //outMat.disableLighting = true
    //scene.onBeforeRenderObservable.add(() => {
    //    pCtx.clearRect(0, 0, app.canvas.width, app.canvas.height)
    //    pCtx.drawImage(app.canvas, 0, 0)
    //    pixiDt.update()
    //})
    //scene.onAfterRenderObservable.add(() => {
    //    app.renderer.clear()
    //})


    // Render Loop
    //engine.runRenderLoop(function () {

    //  scene.autoClear = false;
    //sphere.rotation.y += 0.01;
    // scene.render();
    //engine.wipeCaches(true);

    //pixiRenderer.reset();
    //pixiRenderer.render(stage1);


    //});


};





export default interface BabylonBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  BabylonBit  from "./babylon.bit";

export default interface Babylon {
 // idx:string;
 // babylonBitList: BabylonBit[];
 // babylonBits:any;

}

import { CameraModel } from "../camera.model";
import CameraBit from "../fce/camera.bit";
import State from "../../99.core/state";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActCam from "../camera.action";

import CamBit from "../fce/camera.bit"
import { BabylonModel } from "../../01.babylon.unit/babylon.model";


var bit, dat;

export const initCamera = (cpy: CameraModel, bal: CameraBit, ste: State) => {
    debugger
    return cpy;
};

export const updateCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {

    //bit = await ste.hunt(ActMku.READ_MIKU, { idx: bal.idx })
    //dat = bit.mkuBit.dat

    //dat.bit.position = new BABYLON.Vector3( dat.position.x, dat.position.y,  dat.position.z);

    //var can: PIXI.Container = dat.bit;

    //can.x = dat.x;
    //can.y = dat.y;

    bal.slv({ mkuBit: { idx: "update-camera" } });
    return cpy;
};


export const readCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {
    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActCam.CREATE_CAMERA })
    //if (slv != null) slv({ canBit: { idx: "read-container", dat: bit.clcBit.dat } });
    //return cpy;

    bal.slv({ mkuBit: { idx: "read-camera", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-write-camera", dat: {} } });

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActCam.CREATE_CAMERA })

    if (bit.clcBit.val != 0) ste.hunt(ActCam.UPDATE_CAMERA, { idx: bal.idx })

    //if (bal.slv != null) bal.slv({ canBit: { idx: "write-container", dat: bit.clcBit.dat } });

    bal.slv({ mkuBit: { idx: "write-camera", dat: bit.clcBit.dat } });
};

export const removeCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActCam.CREATE_CAMERA })
    if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-container", dat: bit.clcBit } });

    bal.slv({ mkuBit: { idx: "remove-miku" } });
    return cpy;
};

export const deleteCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {
    bal.slv({ mkuBit: { idx: "delete-miku" } });
};

export const createCamera = async (cpy: CameraModel, bal: CameraBit, ste: State) => {
    if (ste.value.babylon == null) {
        return alert("babylon error")
    }

    var modBab: BabylonModel = ste.value.babylon

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-create-container", dat: {} } });

    //you have a source visage
    //now you wish to update a bit of the source visage
    var dat: CamBit = {
        idx: bal.idx, src: bal.src,
    }

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }


    bal.slv({ mkuBit: { idx: "create-camera", dat } });
    return cpy;
};

import { Action } from "../99.core/interface/action.interface";
import  CameraBit  from "./fce/camera.bit";

// Camera actions

export const INIT_CAMERA = "[Camera action] Init Camera";
export class InitCamera implements Action {
 readonly type = INIT_CAMERA;
 constructor(public bale: CameraBit) {}
}

export const UPDATE_CAMERA = "[Camera action] Update Camera";
export class UpdateCamera implements Action {
 readonly type = UPDATE_CAMERA;
 constructor(public bale: CameraBit) {}
}

export const READ_CAMERA = "[Read action] Read Camera";
 export class ReadCamera implements Action {
 readonly type = READ_CAMERA;
 constructor(public bale: CameraBit) {}
 }
 
export const WRITE_CAMERA = "[Write action] Write Camera";
 export class WriteCamera implements Action {
 readonly type = WRITE_CAMERA;
 constructor(public bale: CameraBit) {}
 }
 
export const REMOVE_CAMERA = "[Remove action] Remove Camera";
 export class RemoveCamera implements Action {
 readonly type = REMOVE_CAMERA;
 constructor(public bale: CameraBit) {}
 }
 
export const DELETE_CAMERA = "[Delete action] Delete Camera";
 export class DeleteCamera implements Action {
 readonly type = DELETE_CAMERA;
 constructor(public bale: CameraBit) {}
 }
 
export const CREATE_CAMERA = "[Create action] Create Camera";
 export class CreateCamera implements Action {
 readonly type = CREATE_CAMERA;
 constructor(public bale: CameraBit) {}
 }
 
export type Actions = | InitCamera | UpdateCamera 
| ReadCamera
| WriteCamera
| RemoveCamera
| DeleteCamera
| CreateCamera
export { initCamera  } from "./buz/camera.buzz";
export { updateCamera  } from "./buz/camera.buzz";
export { readCamera  } from "./buz/camera.buzz";
export { writeCamera  } from "./buz/camera.buzz";
export { removeCamera  } from "./buz/camera.buzz";
export { deleteCamera  } from "./buz/camera.buzz";
export { createCamera  } from "./buz/camera.buzz";
import Camera from "./fce/camera.interface";
import CameraBit from "./fce/camera.interface";

export class CameraModel implements Camera {
 //idx:string;
 //cameraBitList: CameraBit[] = [];
 //cameraBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./camera.action";
import { CameraModel } from "./camera.model";
import * as Buzz from "./camera.buzzer";
import State from "../99.core/state";

export function reducer(model: CameraModel = new CameraModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CAMERA:
 return Buzz.updateCamera(clone(model), act.bale, state);

 case Act.INIT_CAMERA:
 return Buzz.initCamera(clone(model), act.bale, state);

case Act.READ_CAMERA:
 return Buzz.readCamera(clone(model), act.bale, state);
 
case Act.WRITE_CAMERA:
 return Buzz.writeCamera(clone(model), act.bale, state);
 
case Act.REMOVE_CAMERA:
 return Buzz.removeCamera(clone(model), act.bale, state);
 
case Act.DELETE_CAMERA:
 return Buzz.deleteCamera(clone(model), act.bale, state);
 
case Act.CREATE_CAMERA:
 return Buzz.createCamera(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class CameraUnit {

 constructor(state: State) {
 }
}


export default interface CameraBit {
 idx:string;
}


export default interface CameraBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  CameraBit  from "./camera.bit";

export default interface Camera {
 // idx:string;
 // cameraBitList: CameraBit[];
 // cameraBits:any;

}

import { LightModel } from "../light.model";
import LightBit from "../fce/light.bit";
import State from "../../99.core/state";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActLgt from "../light.action";

import LgtBit from "../fce/light.bit"
import { BabylonModel } from "../../01.babylon.unit/babylon.model";
import LitBit from "../fce/lit.bit";

var bit, dat;

export const initLight = (cpy: LightModel, bal: LightBit, ste: State) => {
    debugger
    return cpy;
};

export const updateLight = async (cpy: LightModel, bal: LightBit, ste: State) => {
    bit = await ste.hunt(ActLgt.READ_LIGHT, { idx: bal.idx })
    dat = bit.lgtBit.dat

    //dat.bit.position = new BABYLON.Vector3( dat.position.x, dat.position.y,  dat.position.z);

    bal.slv({ lgtBit: { idx: "update-light" } });
};


export const readLight = async (cpy: LightModel, bal: LightBit, ste: State) => {
    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'lgt00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActLgt.CREATE_LIGHT })
    //if (slv != null) slv({ canBit: { idx: "read-container", dat: bit.clcBit.dat } });
    //return cpy;

    bal.slv({ mkuBit: { idx: "read-light", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeLight = async (cpy: LightModel, bal: LightBit, ste: State) => {
    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-write-light", dat: {} } });

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActLgt.CREATE_LIGHT })

    if (bit.clcBit.val != 0) ste.hunt(ActLgt.UPDATE_LIGHT, { idx: bal.idx })

    //if (bal.slv != null) bal.slv({ canBit: { idx: "write-container", dat: bit.clcBit.dat } });

    bal.slv({ mkuBit: { idx: "write-light", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeLight = async (cpy: LightModel, bal: LightBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActLgt.DELETE_LIGHT })
    if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-light", dat: bit.clcBit } });

    bal.slv({ mkuBit: { idx: "remove-light" } });

};

export const deleteLight = (cpy: LightModel, bal: LightBit, ste: State) => {
    debugger
    return cpy;
};

export const createLight = async (cpy: LightModel, bal: LightBit, ste: State) => {
    if (ste.value.babylon == null) {
        return alert("babylon error")
    }

    var modBab: BabylonModel = ste.value.babylon

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-create-light", dat: {} } });

    //you have a source visage
    //now you wish to update a bit of the source visage
    var dat: LitBit = { idx: bal.idx }

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }


    bal.slv({ mkuBit: { idx: "create-light", dat } });
    return cpy;
};

export default interface LightBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  LightBit  from "./light.bit";

export default interface Light {
 // idx:string;
 // lightBitList: LightBit[];
 // lightBits:any;

}


export default interface LitBit {
 idx:string;
}

import { Action } from "../99.core/interface/action.interface";
import  LightBit  from "./fce/light.bit";

// Light actions

export const INIT_LIGHT = "[Light action] Init Light";
export class InitLight implements Action {
 readonly type = INIT_LIGHT;
 constructor(public bale: LightBit) {}
}

export const UPDATE_LIGHT = "[Light action] Update Light";
export class UpdateLight implements Action {
 readonly type = UPDATE_LIGHT;
 constructor(public bale: LightBit) {}
}

export const READ_LIGHT = "[Read action] Read Light";
 export class ReadLight implements Action {
 readonly type = READ_LIGHT;
 constructor(public bale: LightBit) {}
 }
 
export const WRITE_LIGHT = "[Write action] Write Light";
 export class WriteLight implements Action {
 readonly type = WRITE_LIGHT;
 constructor(public bale: LightBit) {}
 }
 
export const REMOVE_LIGHT = "[Remove action] Remove Light";
 export class RemoveLight implements Action {
 readonly type = REMOVE_LIGHT;
 constructor(public bale: LightBit) {}
 }
 
export const DELETE_LIGHT = "[Delete action] Delete Light";
 export class DeleteLight implements Action {
 readonly type = DELETE_LIGHT;
 constructor(public bale: LightBit) {}
 }
 
export const CREATE_LIGHT = "[Create action] Create Light";
 export class CreateLight implements Action {
 readonly type = CREATE_LIGHT;
 constructor(public bale: LightBit) {}
 }
 
export type Actions = | InitLight | UpdateLight 
| ReadLight
| WriteLight
| RemoveLight
| DeleteLight
| CreateLight
export { initLight  } from "./buz/light.buzz";
export { updateLight  } from "./buz/light.buzz";
export { readLight  } from "./buz/light.buzz";
export { writeLight  } from "./buz/light.buzz";
export { removeLight  } from "./buz/light.buzz";
export { deleteLight  } from "./buz/light.buzz";
export { createLight  } from "./buz/light.buzz";
import Light from "./fce/light.interface";
import LightBit from "./fce/light.interface";

export class LightModel implements Light {
 //idx:string;
 //lightBitList: LightBit[] = [];
 //lightBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./light.action";
import { LightModel } from "./light.model";
import * as Buzz from "./light.buzzer";
import State from "../99.core/state";

export function reducer(model: LightModel = new LightModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_LIGHT:
 return Buzz.updateLight(clone(model), act.bale, state);

 case Act.INIT_LIGHT:
 return Buzz.initLight(clone(model), act.bale, state);

case Act.READ_LIGHT:
 return Buzz.readLight(clone(model), act.bale, state);
 
case Act.WRITE_LIGHT:
 return Buzz.writeLight(clone(model), act.bale, state);
 
case Act.REMOVE_LIGHT:
 return Buzz.removeLight(clone(model), act.bale, state);
 
case Act.DELETE_LIGHT:
 return Buzz.deleteLight(clone(model), act.bale, state);
 
case Act.CREATE_LIGHT:
 return Buzz.createLight(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class LightUnit {

 constructor(state: State) {
 }
}

import { ScreenModel } from "../screen.model";
import ScreenBit from "../fce/screen.bit";
import State from "../../99.core/state";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActScr from "../screen.action";

import SeeBit from "../fce/see.bit";

import * as ActFce from '../../act/surface.action'
import * as ActSpr from '../../act/sprite.action'
import * as ActTxt from '../../act/text.action'

import { BabylonModel } from "../../01.babylon.unit/babylon.model";


var bit, dat

export const initScreen = (cpy: ScreenModel, bal: ScreenBit, ste: State) => {
    debugger
    return cpy;
};

export const updateScreen = async (cpy: ScreenModel, bal: ScreenBit, ste: State) => {

    bit = await ste.hunt( ActScr.READ_SCREEN, { idx: bal.idx })
    dat = bit.scrBit.dat

    dat.bit.position = new BABYLON.Vector3(dat.position.x, dat.position.y, dat.position.z);
    dat.bit.rotation = new BABYLON.Vector3(dat.rotation.x, dat.rotation.y, dat.rotation.z);


    bal.slv({ scrBit: { idx: "update-screen" } });

    return cpy;
};

export const readScreen = async (cpy: ScreenModel, bal: ScreenBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActScr.CREATE_SCREEN })
    bal.slv({ scrBit: { idx: "read-screen", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeScreen = async (cpy: ScreenModel, bal: ScreenBit, ste: State) => {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActScr.CREATE_SCREEN })
    if (bit.clcBit.val != 0) ste.hunt(ActScr.UPDATE_SCREEN, { idx: bal.idx })
    bal.slv({ srcBit: { idx: "write-screen", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeScreen = async (cpy: ScreenModel, bal: ScreenBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActScr.REMOVE_SCREEN })
    if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-screen", dat: bit.clcBit } });
    bal.slv({ mkuBit: { idx: "remove-screen" } });
    return cpy;
};

export const deleteScreen = (cpy: ScreenModel, bal: ScreenBit, ste: State) => {
    debugger
    return cpy;
};

export const createScreen = async (cpy: ScreenModel, bal: ScreenBit, ste: State) => {

    
    
    var dat: SeeBit = {
        idx: bal.idx, src: bal.src,
        bit:null
    }

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }

    //OUT TO SHADE
    //RETURN WITH APPLICATION
    if (ste.value.babylon == null) {
        return alert("babylon error")
    }

    var modBab: BabylonModel = ste.value.babylon

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-create-container", dat: {} } });

    var scene = modBab.scene;

    if ( scene == null ){

        bal.slv({ scrBit: { idx: "create-screen-err", dat:{bit:null} } });
        return 

    }


    bit = await window['SHADE'](ActFce.LIST_SURFACE, {})
    var dex = bit.fceBit.lst.length
    var idx = 'fce' + dex;
    console.log("fce: " + idx)
    bit = await window['SHADE'](ActFce.WRITE_SURFACE, { idx })

    const app = bit.fceBit.dat.bit
    //const app = new PIXI.Application();
    await app.init({ background: '#ff00ff', resizeTo: window });

    var container = app.stage

    //bit = await window['SHADE']( ActSpr.WRITE_SPRITE, { idx:'spr00' })

    bit = await window['SHADE']( ActTxt.WRITE_TEXT, { idx:'txt00', dat:{txt:'alligator'}  })

    var text = bit.txtBit.dat.bit
    text.x = 300;
    text.y = 300;
    container.addChild(text)

    const stageSize = new BABYLON.Vector2(960, 540)
    const out = BABYLON.MeshBuilder.CreateGround('out', { width: 1, height: 1 }, scene)
    const baseOutScale = stageSize.clone().scale(0.05)
    out.scaling.set(baseOutScale.x, 1, baseOutScale.y)
    
    const outMat = new BABYLON.StandardMaterial('outMat', scene)
    out.material = outMat
    out.isVisible = true
    out.position.z = 100;
    out.position.y = 30;
    out.position.x = -40;

    out.rotation.z = 0
    out.rotation.x = 0
    out.rotation.y = 0
    out.rotation.x = -Math.PI * 0.5

    const pixiDt = new BABYLON.DynamicTexture('pixi-extract', { width: stageSize.x, height: stageSize.y }, scene, false)
    const pCtx = pixiDt.getContext()
    outMat.emissiveTexture = pixiDt
    outMat.diffuseTexture = pixiDt
    outMat.opacityTexture = pixiDt
    pixiDt.hasAlpha = true
    outMat.disableLighting = true
    scene.onBeforeRenderObservable.add(() => {
        pCtx.clearRect(0, 0, app.canvas.width, app.canvas.height)
        pCtx.drawImage(app.canvas, 0, 0)
        pixiDt.update()
    }
    )

    scene.onAfterRenderObservable.add(() => {
        app.renderer.clear()
    }
    )


    dat.bit = out 

    
    bal.slv({ scrBit: { idx: "create-screen", dat } });
    return cpy;
};



export default interface ScreenBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  ScreenBit  from "./screen.bit";

export default interface Screen {
 // idx:string;
 // screenBitList: ScreenBit[];
 // screenBits:any;

}


export default interface SeeBit {
    idx:string;
    src?:string;
    bit?:any;
}

import { Action } from "../99.core/interface/action.interface";
import  ScreenBit  from "./fce/screen.bit";

// Screen actions

export const INIT_SCREEN = "[Screen action] Init Screen";
export class InitScreen implements Action {
 readonly type = INIT_SCREEN;
 constructor(public bale: ScreenBit) {}
}

export const UPDATE_SCREEN = "[Screen action] Update Screen";
export class UpdateScreen implements Action {
 readonly type = UPDATE_SCREEN;
 constructor(public bale: ScreenBit) {}
}

export const READ_SCREEN = "[Read action] Read Screen";
 export class ReadScreen implements Action {
 readonly type = READ_SCREEN;
 constructor(public bale: ScreenBit) {}
 }
 
export const WRITE_SCREEN = "[Write action] Write Screen";
 export class WriteScreen implements Action {
 readonly type = WRITE_SCREEN;
 constructor(public bale: ScreenBit) {}
 }
 
export const REMOVE_SCREEN = "[Remove action] Remove Screen";
 export class RemoveScreen implements Action {
 readonly type = REMOVE_SCREEN;
 constructor(public bale: ScreenBit) {}
 }
 
export const DELETE_SCREEN = "[Delete action] Delete Screen";
 export class DeleteScreen implements Action {
 readonly type = DELETE_SCREEN;
 constructor(public bale: ScreenBit) {}
 }
 
export const CREATE_SCREEN = "[Create action] Create Screen";
 export class CreateScreen implements Action {
 readonly type = CREATE_SCREEN;
 constructor(public bale: ScreenBit) {}
 }
 
export type Actions = | InitScreen | UpdateScreen 
| ReadScreen
| WriteScreen
| RemoveScreen
| DeleteScreen
| CreateScreen
export { initScreen  } from "./buz/screen.buzz";
export { updateScreen  } from "./buz/screen.buzz";
export { readScreen  } from "./buz/screen.buzz";
export { writeScreen  } from "./buz/screen.buzz";
export { removeScreen  } from "./buz/screen.buzz";
export { deleteScreen  } from "./buz/screen.buzz";
export { createScreen  } from "./buz/screen.buzz";
import Screen from "./fce/screen.interface";
import ScreenBit from "./fce/screen.interface";

export class ScreenModel implements Screen {
 //idx:string;
 //screenBitList: ScreenBit[] = [];
 //screenBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./screen.action";
import { ScreenModel } from "./screen.model";
import * as Buzz from "./screen.buzzer";
import State from "../99.core/state";

export function reducer(model: ScreenModel = new ScreenModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SCREEN:
 return Buzz.updateScreen(clone(model), act.bale, state);

 case Act.INIT_SCREEN:
 return Buzz.initScreen(clone(model), act.bale, state);

case Act.READ_SCREEN:
 return Buzz.readScreen(clone(model), act.bale, state);
 
case Act.WRITE_SCREEN:
 return Buzz.writeScreen(clone(model), act.bale, state);
 
case Act.REMOVE_SCREEN:
 return Buzz.removeScreen(clone(model), act.bale, state);
 
case Act.DELETE_SCREEN:
 return Buzz.deleteScreen(clone(model), act.bale, state);
 
case Act.CREATE_SCREEN:
 return Buzz.createScreen(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class ScreenUnit {

 constructor(state: State) {
 }
}

import { GlopModel } from "../glop.model";
import GlopBit from "../fce/glop.bit";
import State from "../../99.core/state";

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActGlp from "../glop.action";
import GlpBit from "../fce/glp.bit";

import { BabylonModel } from "../../01.babylon.unit/babylon.model";


var bit, dat;

export const initGlop = (cpy: GlopModel, bal: GlopBit, ste: State) => {
    debugger
    return cpy;
};

export const updateGlop = async (cpy: GlopModel, bal: GlopBit, ste: State) => {
    bit = await ste.hunt(ActGlp.READ_GLOP, { idx: bal.idx })
    dat = bit.mkuBit.dat

    //dat.bit.position = new BABYLON.Vector3(dat.position.x, dat.position.y, dat.position.z);

    bal.slv({ mkuBit: { idx: "update-miku" } });
};


export const readGlop = async (cpy: GlopModel, bal: GlopBit, ste: State) => {
    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActGlp.CREATE_GLOP })
    //if (slv != null) slv({ canBit: { idx: "read-container", dat: bit.clcBit.dat } });
    //return cpy;

    bal.slv({ glpBit: { idx: "read-glop", dat: bit.clcBit.dat } });
    return cpy;
};
export const writeGlop = async (cpy: GlopModel, bal: GlopBit, ste: State) => {
    
    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-write-miku", dat: {} } });

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActGlp.CREATE_GLOP })

    if (bit.clcBit.val != 0) ste.hunt( ActGlp.UPDATE_GLOP, { idx: bal.idx })

    //if (bal.slv != null) bal.slv({ canBit: { idx: "write-container", dat: bit.clcBit.dat } });

    bal.slv({ glpBit: { idx: "write-glop", dat: bit.clcBit.dat } });
};
export const deleteGlop = async (cpy: GlopModel, bal: GlopBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActGlp.CREATE_GLOP })
    
    bal.slv({ glpBit: { idx: "remove-miku" } });
};
export const createGlop = async (cpy: GlopModel, bal: GlopBit, ste: State) => {
    
    //you have a source visage
    //now you wish to update a bit of the source visage
    var dat: GlpBit = {idx: bal.idx, src: ''}

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }

    
    var modBab: BabylonModel = ste.value.babylon

    //real genius
    const mesh = await BABYLON.SceneLoader.ImportMeshAsync(undefined, './hexTile.glb', undefined, modBab.scene).then((result) => result.meshes[0]);
    debugger
    //const modelMesh = mmdMesh as BABYLON.Mesh
    //modelMesh.receiveShadows = true;;

    modBab.scene.stopAllAnimations();

    //for(const mesh of modelMesh.metadata.meshes) shadowGenerator.addShadowCaster(mesh);

    //const mmdModel = modBab.mmdRuntime.createMmdModel(modelMesh);

    //mmdModel.addAnimation(modBab.motion);
    //mmdModel.setAnimation("motion");
    //modBab.mmdRuntime.playAnimation();

    //dat.bit = modelMesh

    // if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

    bal.slv({ mkuBit: { idx: "create-miku", dat } });
    return cpy;
};


export const removeGlop = (cpy: GlopModel, bal: GlopBit, ste: State) => {
    debugger
    return cpy;
};

export default interface GlopBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  GlopBit  from "./glop.bit";

export default interface Glop {
 // idx:string;
 // glopBitList: GlopBit[];
 // glopBits:any;

}


export default interface GlpBit {
 idx:string;
 src:string;
}

import { Action } from "../99.core/interface/action.interface";
import  GlopBit  from "./fce/glop.bit";

// Glop actions

export const INIT_GLOP = "[Glop action] Init Glop";
export class InitGlop implements Action {
 readonly type = INIT_GLOP;
 constructor(public bale: GlopBit) {}
}

export const UPDATE_GLOP = "[Glop action] Update Glop";
export class UpdateGlop implements Action {
 readonly type = UPDATE_GLOP;
 constructor(public bale: GlopBit) {}
}

export const READ_GLOP = "[Read action] Read Glop";
 export class ReadGlop implements Action {
 readonly type = READ_GLOP;
 constructor(public bale: GlopBit) {}
 }
 
export const WRITE_GLOP = "[Write action] Write Glop";
 export class WriteGlop implements Action {
 readonly type = WRITE_GLOP;
 constructor(public bale: GlopBit) {}
 }
 
export const DELETE_GLOP = "[Delete action] Delete Glop";
 export class DeleteGlop implements Action {
 readonly type = DELETE_GLOP;
 constructor(public bale: GlopBit) {}
 }
 
export const CREATE_GLOP = "[Create action] Create Glop";
 export class CreateGlop implements Action {
 readonly type = CREATE_GLOP;
 constructor(public bale: GlopBit) {}
 }
 
export const REMOVE_GLOP = "[Remove action] Remove Glop";
 export class RemoveGlop implements Action {
 readonly type = REMOVE_GLOP;
 constructor(public bale: GlopBit) {}
 }
 
export type Actions = | InitGlop | UpdateGlop 
| ReadGlop
| WriteGlop
| DeleteGlop
| CreateGlop
| RemoveGlop
export { initGlop  } from "./buz/glop.buzz";
export { updateGlop  } from "./buz/glop.buzz";
export { readGlop  } from "./buz/glop.buzz";
export { writeGlop  } from "./buz/glop.buzz";
export { deleteGlop  } from "./buz/glop.buzz";
export { createGlop  } from "./buz/glop.buzz";
export { removeGlop  } from "./buz/glop.buzz";
import Glop from "./fce/glop.interface";
import GlopBit from "./fce/glop.interface";

export class GlopModel implements Glop {
 //idx:string;
 //glopBitList: GlopBit[] = [];
 //glopBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./glop.action";
import { GlopModel } from "./glop.model";
import * as Buzz from "./glop.buzzer";
import State from "../99.core/state";

export function reducer(model: GlopModel = new GlopModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_GLOP:
 return Buzz.updateGlop(clone(model), act.bale, state);

 case Act.INIT_GLOP:
 return Buzz.initGlop(clone(model), act.bale, state);

case Act.READ_GLOP:
 return Buzz.readGlop(clone(model), act.bale, state);
 
case Act.WRITE_GLOP:
 return Buzz.writeGlop(clone(model), act.bale, state);
 
case Act.DELETE_GLOP:
 return Buzz.deleteGlop(clone(model), act.bale, state);
 
case Act.CREATE_GLOP:
 return Buzz.createGlop(clone(model), act.bale, state);
 
case Act.REMOVE_GLOP:
 return Buzz.removeGlop(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class GlopUnit {

    constructor(state: State) {
    }
}

import { MikuModel } from "../miku.model";
import MikuBit from "../fce/miku.bit";
import State from "../../99.core/state";
import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActMku from "../miku.action";

import MmdBit from "../fce/mmd.bit"
import { BabylonModel } from "../../01.babylon.unit/babylon.model";

var bit, dat;

export const initMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {
    debugger
    return cpy;
};



export const updateMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {

    bit = await ste.hunt(ActMku.READ_MIKU, { idx: bal.idx })
    dat = bit.mkuBit.dat

    dat.bit.position = new BABYLON.Vector3(dat.position.x, dat.position.y, dat.position.z);

    bal.slv({ mkuBit: { idx: "update-miku" } });
    return cpy;
};

export const readMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {

    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActMku.CREATE_MIKU })
    //if (slv != null) slv({ canBit: { idx: "read-container", dat: bit.clcBit.dat } });
    //return cpy;

    bal.slv({ mkuBit: { idx: "read-miku", dat: bit.clcBit.dat } });
    return cpy;
};


export const writeMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {


    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-write-miku", dat: {} } });

    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActMku.CREATE_MIKU })

    if (bit.clcBit.val != 0) ste.hunt(ActMku.UPDATE_MIKU, { idx: bal.idx })

    //if (bal.slv != null) bal.slv({ canBit: { idx: "write-container", dat: bit.clcBit.dat } });

    bal.slv({ mkuBit: { idx: "write-miku", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {

    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActMku.DELETE_MIKU })
    if (bal.slv != null) bal.slv({ vsgBit: { idx: "remove-container", dat: bit.clcBit } });

    bal.slv({ mkuBit: { idx: "remove-miku" } });
    return cpy;
};


export const deleteMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {

    bal.slv({ mkuBit: { idx: "delete-miku" } });
    return cpy;
};

export const createMiku = async (cpy: MikuModel, bal: MikuBit, ste: State) => {

    if (ste.value.babylon == null) {
        return alert("babylon error")
    }

    var modBab: BabylonModel = ste.value.babylon

    if (typeof window != "object") return bal.slv({ canBit: { idx: "error-create-container", dat: {} } });

    //you have a source visage
    //now you wish to update a bit of the source visage
    var dat: any = {
        idx: bal.idx, src: bal.src,
        postition: { x: 0, y: 0, z: 0 },
        scale: { x: 0, y: 0, z: 0 },
        rotation: { x: 0, y: 0, z: 0 }
    }

    for (var key in bal.dat) {
        dat[key] = bal.dat[key]
    }

    //real genius
    const mmdMesh = await BABYLON.SceneLoader.ImportMeshAsync(undefined, bal.src, undefined, modBab.scene).then((result) => result.meshes[0]);
    const modelMesh = mmdMesh as BABYLON.Mesh
    //modelMesh.receiveShadows = true;;

    //for(const mesh of modelMesh.metadata.meshes) shadowGenerator.addShadowCaster(mesh);

    const mmdModel = modBab.mmdRuntime.createMmdModel(modelMesh);

    mmdModel.addAnimation(modBab.motion);
    mmdModel.setAnimation("motion");
    modBab.mmdRuntime.playAnimation();

    dat.bit = modelMesh

    // if (bal.src != null) bit = await ste.hunt(ActVsg.NEST_VISAGE, { src: bal.src, dat })

    bal.slv({ mkuBit: { idx: "create-miku", dat } });
    return cpy;
};


export default interface MikuBit {
    idx:string;
    src?:string;
    val?:number;
    dat?:any;
    slv?:Function;
}


import  MikuBit  from "./miku.bit";

export default interface Miku {
 // idx:string;
 // mikuBitList: MikuBit[];
 // mikuBits:any;

}

import VBit from "./v.bit";

export default interface MmdBit {
 idx:string;
 src:string;
 postition:VBit;
 scale:VBit;
 rotation:VBit;
 bit:any;
}

export default interface VBit {
    x: number;
    y: number;
    z: number;
}
import { Action } from "../99.core/interface/action.interface";
import  MikuBit  from "./fce/miku.bit";

// Miku actions

export const INIT_MIKU = "[Miku action] Init Miku";
export class InitMiku implements Action {
 readonly type = INIT_MIKU;
 constructor(public bale: MikuBit) {}
}

export const UPDATE_MIKU = "[Miku action] Update Miku";
export class UpdateMiku implements Action {
 readonly type = UPDATE_MIKU;
 constructor(public bale: MikuBit) {}
}

export const READ_MIKU = "[Miku action] Read Miku";
export class ReadMiku implements Action {
 readonly type = READ_MIKU;
 constructor(public bale: MikuBit) {}
}

export const WRITE_MIKU = "[Miku action] Write Miku";
export class WriteMiku implements Action {
 readonly type = WRITE_MIKU;
 constructor(public bale: MikuBit) {}
}

export const DELETE_MIKU = "[Miku action] Delete Miku";
export class DeleteMiku implements Action {
 readonly type = DELETE_MIKU;
 constructor(public bale: MikuBit) {}
}

export const REMOVE_MIKU = "[Miku action] Remove Miku";
export class RemoveMiku implements Action {
 readonly type = REMOVE_MIKU;
 constructor(public bale: MikuBit) {}
}

export const CREATE_MIKU = "[Miku action] Create Miku";
export class CreateMiku implements Action {
 readonly type = CREATE_MIKU;
 constructor(public bale: MikuBit) {}
}


export type Actions = | InitMiku | UpdateMiku | ReadMiku | WriteMiku | DeleteMiku | RemoveMiku | CreateMiku;

export { initMiku  } from "./buz/miku.buzz";
export { updateMiku  } from "./buz/miku.buzz";
export { readMiku  } from "./buz/miku.buzz";
export { writeMiku  } from "./buz/miku.buzz";
export { removeMiku  } from "./buz/miku.buzz";
export { deleteMiku  } from "./buz/miku.buzz";
export { createMiku  } from "./buz/miku.buzz";

import Miku from "./fce/miku.interface";
import MikuBit from "./fce/miku.interface";

export class MikuModel implements Miku {
 //idx:string;
 //mikuBitList: MikuBit[] = [];
 //mikuBits: any = {};
}

import * as Act from "./miku.action";
import { MikuModel } from "./miku.model";
import * as Buzz from "./miku.buzzer";
import State from "../99.core/state";

export function reducer(model: MikuModel = new MikuModel(), act: Act.Actions, state?: State) {
 
    
    var clone = require('clone-deep');
 
    switch (act.type) {

        case Act.UPDATE_MIKU:
            return Buzz.updateMiku(clone(model), act.bale, state);

        case Act.INIT_MIKU:
            return Buzz.initMiku(clone(model), act.bale, state);


        case Act.READ_MIKU:
            return Buzz.readMiku(clone(model), act.bale, state);

        case Act.WRITE_MIKU:
            return Buzz.writeMiku(clone(model), act.bale, state);

        case Act.REMOVE_MIKU:
            return Buzz.removeMiku(clone(model), act.bale, state);

        case Act.DELETE_MIKU:
            return Buzz.deleteMiku(clone(model), act.bale, state);

        case Act.CREATE_MIKU:
            return Buzz.createMiku(clone(model), act.bale, state);

        default:
            return model;
    }
}

import State from "../99.core/state";


export default class MikuUnit {

 constructor(state: State) {
 }
}

export const initMotion = (cpy: MotionModel, bal:MotionBit, ste: State) => {
 debugger
 return cpy;
};

export const updateMotion = (cpy: MotionModel, bal:MotionBit, ste: State) => {
 return cpy;
};


import { MotionModel } from "../motion.model";
import MotionBit from "../fce/motion.bit";
import State from "../../99.core/state";

export default interface MotionBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  MotionBit  from "./motion.bit";

export default interface Motion {
 // idx:string;
 // motionBitList: MotionBit[];
 // motionBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  MotionBit  from "./fce/motion.bit";

// Motion actions

export const INIT_MOTION = "[Motion action] Init Motion";
export class InitMotion implements Action {
 readonly type = INIT_MOTION;
 constructor(public bale: MotionBit) {}
}

export const UPDATE_MOTION = "[Motion action] Update Motion";
export class UpdateMotion implements Action {
 readonly type = UPDATE_MOTION;
 constructor(public bale: MotionBit) {}
}

export type Actions = | InitMotion | UpdateMotion ;

export { initMotion  } from "./buz/motion.buzz";
export { updateMotion  } from "./buz/motion.buzz";

import Motion from "./fce/motion.interface";
import MotionBit from "./fce/motion.interface";

export class MotionModel implements Motion {
 //idx:string;
 //motionBitList: MotionBit[] = [];
 //motionBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./motion.action";
import { MotionModel } from "./motion.model";
import * as Buzz from "./motion.buzzer";
import State from "../99.core/state";

export function reducer(model: MotionModel = new MotionModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_MOTION:
 return Buzz.updateMotion(clone(model), act.bale, state);

 case Act.INIT_MOTION:
 return Buzz.initMotion(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class MotionUnit {

 constructor(state: State) {
 }
}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";



export function reducer(model: BusModel = new BusModel(), act: Act.Actions, state?: State) {

    var clone = require('clone-deep');

    switch (act.type) {

        case Act.UPDATE_BUS:
            return Buzz.updateBus(clone(model), act.bale, state);

        case Act.OPEN_BUS:
            return Buzz.openBus(clone(model), act.bale, state);

        case Act.CONNECT_BUS:
            return Buzz.connectBus(clone(model), act.bale, state);

        case Act.CREATE_BUS:
            return Buzz.createBus(clone(model), act.bale, state);

        case Act.MESSAGE_BUS:
            return Buzz.connectBus(clone(model), act.bale, state);

        case Act.INIT_BUS:
            return Buzz.initBus(clone(model), act.bale, state);

        default:
            return model;
    }
}

import State from "../99.core/state";


export default class BusUnit {

    constructor(state: State) {
    }
}

//import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";

export const INIT_DISK = "[Disk action] Init Disk";
export const UPDATE_DISK = "[Disk action] Update Disk";
export const READ_DISK = "[Disk action] Read Disk";
export const WRITE_DISK = "[Disk action] Write Disk";
export const LIST_DISK = "[List action] List Disk";
export const LOAD_LIST_DISK = "[Load_list action] Load_list Disk";
export const COPY_DISK = "[Copy action] Copy Disk";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const READY_SPACE = "[Ready action] Ready Space";
export const INIT_SPRITE = "[Sprite action] Init Sprite";
export const UPDATE_SPRITE = "[Sprite action] Update Sprite";
export const READ_SPRITE = "[Read action] Read Sprite";
export const WRITE_SPRITE = "[Write action] Write Sprite";
export const CREATE_SPRITE = "[Create action] Create Sprite"; 
export const REMOVE_SPRITE = "[Remove action] Remove Sprite";
export const DELETE_SPRITE = "[Delete action] Delete Sprite";

export const INIT_SURFACE = "[Surface action] Init Surface";
export const UPDATE_SURFACE = "[Surface action] Update Surface";
export const READ_SURFACE = "[Read action] Read Surface";
export const WRITE_SURFACE = "[Write action] Write Surface";
export const REMOVE_SURFACE = "[Write action] Remove Surface";
export const CREATE_SURFACE = "[Create action] Create Surface";
export const DIMENSION_SURFACE = "[Dimension action] Dimension Surface";
export const DELETE_SURFACE = "[Delete action] Delete Surface";
export const EXTRACT_SURFACE = "[Extract action] Extract Surface";
export const LIST_SURFACE = "[List action] List Surface";

// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const OPEN_TERMINAL = "[Terminal action] Open Terminal";
export const FOCUS_TERMINAL = "[Terminal action] Focus Terminal";
export const WRITE_TERMINAL = "[Terminal action] Write Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const CLEAR_TERMINAL = "[Terminal action] Clear Terminal";
export const INPUT_TERMINAL = "[Terminal action] Input Terminal";
export const TABLE_TERMINAL = "[Terminal action] Table Terminal";
export const CLOSE_TERMINAL = "[Terminal action] Close Terminal";
export const ROOT_TERMINAL = "[Terminal action] Root Terminal";
export const CONTENT_TERMINAL = "[Terminal action] Content Terminal";
export const ADD_PORT = "[Terminal action] Add Port";

export const INIT_TEXT = "[Text action] Init Text";
export const UPDATE_TEXT = "[Text action] Update Text";
export const READ_TEXT = "[Read action] Read Text";
export const WRITE_TEXT = "[Write action] Write Text";
export const CREATE_TEXT = "[Create action] Create Text";
export const REMOVE_TEXT = "[Remove action] Remove Text";
export const DELETE_TEXT = "[Delete action] Delete Text";
export const LIST_TEXT = "[List action] List Text";
 
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import SolidUnit from "./00.solid.unit/solid.unit";
import BabylonUnit from "./01.babylon.unit/babylon.unit";
import CameraUnit from "./02.camera.unit/camera.unit";
import LightUnit from "./03.light.unit/light.unit";
import ScreenUnit from "./08.screen.unit/screen.unit";
import GlopUnit from "./09.glop.unit/glop.unit";
import MikuUnit from "./10.miku.unit/miku.unit";
import MotionUnit from "./11.motion.unit/motion.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Solid from "./00.solid.unit/fce/solid.interface";
import { SolidModel } from "./00.solid.unit/solid.model";
import Babylon from "./01.babylon.unit/fce/babylon.interface";
import { BabylonModel } from "./01.babylon.unit/babylon.model";
import Camera from "./02.camera.unit/fce/camera.interface";
import { CameraModel } from "./02.camera.unit/camera.model";
import Light from "./03.light.unit/fce/light.interface";
import { LightModel } from "./03.light.unit/light.model";
import Screen from "./08.screen.unit/fce/screen.interface";
import { ScreenModel } from "./08.screen.unit/screen.model";
import Glop from "./09.glop.unit/fce/glop.interface";
import { GlopModel } from "./09.glop.unit/glop.model";
import Miku from "./10.miku.unit/fce/miku.interface";
import { MikuModel } from "./10.miku.unit/miku.model";
import Motion from "./11.motion.unit/fce/motion.interface";
import { MotionModel } from "./11.motion.unit/motion.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [SolidUnit,BabylonUnit,CameraUnit,LightUnit,ScreenUnit,GlopUnit,MikuUnit,MotionUnit,CollectUnit,BusUnit];

import * as reduceFromSolid from "./00.solid.unit/solid.reduce";
import * as reduceFromBabylon from "./01.babylon.unit/babylon.reduce";
import * as reduceFromCamera from "./02.camera.unit/camera.reduce";
import * as reduceFromLight from "./03.light.unit/light.reduce";
import * as reduceFromScreen from "./08.screen.unit/screen.reduce";
import * as reduceFromGlop from "./09.glop.unit/glop.reduce";
import * as reduceFromMiku from "./10.miku.unit/miku.reduce";
import * as reduceFromMotion from "./11.motion.unit/motion.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 solid : reduceFromSolid.reducer, 
babylon : reduceFromBabylon.reducer, 
camera : reduceFromCamera.reducer, 
light : reduceFromLight.reducer, 
screen : reduceFromScreen.reducer, 
glop : reduceFromGlop.reducer, 
miku : reduceFromMiku.reducer, 
motion : reduceFromMotion.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 solid : Solid = new SolidModel();
babylon : Babylon = new BabylonModel();
camera : Camera = new CameraModel();
light : Light = new LightModel();
screen : Screen = new ScreenModel();
glop : Glop = new GlopModel();
miku : Miku = new MikuModel();
motion : Motion = new MotionModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  

  
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
"use strict";
exports.__esModule = true;
exports.CYAN = exports.MAGENTA = exports.YELLOW = exports.GREEN = exports.RED = void 0;
exports.RED = "\x1b[31m%s\x1b[0m";
exports.GREEN = "\x1b[32m%s\x1b[0m";
exports.YELLOW = "\x1b[33m%s\x1b[0m";
exports.MAGENTA = "\x1b[34m%s\x1b[0m";
exports.CYAN = "\x1b[36m%s\x1b[0m";
//# sourceMappingURL=console.js.map
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

"use strict";
exports.__esModule = true;
exports.WISE_NORTH_EAST = exports.WISE_NORTH = exports.WISE_NORTH_WEST = exports.WISE_WEST = exports.WISE_SOUTH_WEST = exports.WISE_SOUTH = exports.WISE_SOUTH_EAST = exports.WISE_EAST = exports.NORTH_EAST = exports.NORTH = exports.NORTH_WEST = exports.WEST = exports.SOUTH_WEST = exports.SOUTH = exports.SOUTH_EAST = exports.EAST = void 0;
exports.EAST = "E";
exports.SOUTH_EAST = "SE";
exports.SOUTH = "S";
exports.SOUTH_WEST = "SW";
exports.WEST = "W";
exports.NORTH_WEST = "NW";
exports.NORTH = "N";
exports.NORTH_EAST = "NE";
exports.WISE_EAST = "Wise E";
exports.WISE_SOUTH_EAST = "Wise SE";
exports.WISE_SOUTH = "Wise S";
exports.WISE_SOUTH_WEST = "Wise SW";
exports.WISE_WEST = "Wise W";
exports.WISE_NORTH_WEST = "Wise NW";
exports.WISE_NORTH = "Wise N";
exports.WISE_NORTH_EAST = "Wise NE";
//# sourceMappingURL=direction.js.map
export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

"use strict";
exports.__esModule = true;
exports.CIRCLE = exports.ROUNDED_RECTANGLE = exports.RECTANGLE = void 0;
exports.RECTANGLE = "rectangle";
exports.ROUNDED_RECTANGLE = "rounded-rectangle";
exports.CIRCLE = "circle";
//# sourceMappingURL=graphic.js.map
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

"use strict";
exports.__esModule = true;
exports.HEXMAP = exports.FOCUS = void 0;
exports.FOCUS = "focus";
exports.HEXMAP = "hexmap";
//# sourceMappingURL=hexagon.js.map
export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
"use strict";
exports.__esModule = true;
exports.PASTURE = exports.FANG_SWAMP = exports.GEORGIA = exports.GALLBLADDER = void 0;
exports.GALLBLADDER = "00000.gallbladder";
exports.GEORGIA = "00001.georgia";
exports.FANG_SWAMP = "00002.fang-swamp";
exports.PASTURE = "00003.pasture";
//# sourceMappingURL=hexmap.js.map
export const GALLBLADDER: string = "00000.gallbladder";
export const GEORGIA: string = "00001.georgia";
export const FANG_SWAMP: string = "00002.fang-swamp";
export const PASTURE: string = "00003.pasture";
"use strict";
exports.__esModule = true;
exports.MAGENTA = exports.YELLOW = exports.BLUE = exports.GREEN = exports.RED = exports.CYAN = exports.CLEAN = exports.MENU_SINGLE = exports.TIMELINE = exports.SPACE = void 0;
exports.SPACE = "space";
exports.TIMELINE = "timeline";
exports.MENU_SINGLE = "menu_single";
exports.CLEAN = "clean";
exports.CYAN = "cyan";
exports.RED = "red";
exports.GREEN = "green";
exports.BLUE = "blue";
exports.YELLOW = "yellow";
exports.MAGENTA = "magenta";
//# sourceMappingURL=markup.js.map
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

"use strict";
exports.__esModule = true;
exports.LOOP = exports.VIDEO = exports.HEXAGON = exports.SPRITE = exports.TEXT = exports.GRAPHIC = exports.CONTAINER = exports.SURFACE = exports.VISAGE = void 0;
exports.VISAGE = "visage";
exports.SURFACE = "surface";
exports.CONTAINER = "container";
exports.GRAPHIC = "graphic";
exports.TEXT = "text";
exports.SPRITE = "sprite";
exports.HEXAGON = "hexagon";
exports.VIDEO = "video";
exports.LOOP = "loop";
//# sourceMappingURL=shade.js.map
export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
"use strict";
exports.__esModule = true;
exports.MOUNT_WIDTH = exports.MOUNT_HEIGHT = exports.MOUNT_PART = exports.MOUNT_FULL = exports.SCREEN = void 0;
exports.SCREEN = "screen-visage";
exports.MOUNT_FULL = "mount-visage-full";
exports.MOUNT_PART = "mount-visage-part";
exports.MOUNT_HEIGHT = "mount-visage-height";
exports.MOUNT_WIDTH = "mount-visage-width";
//# sourceMappingURL=visage.js.map
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";


import * as ActMrk from "../market.action"
import * as ActDsk from "../../act/disk.action";
import * as ActStg from "../../act/stage.action";
import * as ActGph from "../../act/graphic.action";
import * as ActClk from "../../act/clock.action";
import * as ActTme from "../../act/time.action";

import * as ActBus from "../../99.bus.unit/bus.action";

var bit, idx, val, src, dat

export const initMarket = async (cpy: MarketModel, bal: MarketBit, ste: State) => {

    bal.slv({ intBit: { idx: "init-market" } });
    return cpy;
};

export const updateMarket = (cpy: MarketModel, bal: MarketBit, ste: State) => {

    bal.slv({ mrkBit: { idx: "update-market" } });

    return cpy;
};


import { MarketModel } from "../market.model";
import MarketBit from "../fce/market.bit";
import State from "../../99.core/state";

export default interface MarketBit {
 idx:string;
 val:number;
 slv:Function
 dat:any;
 src?:string;
}


import  MarketBit  from "./market.bit";

export default interface Market {
 // idx:string;
 // marketBitList: MarketBit[];
 // marketBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  MarketBit  from "./fce/market.bit";

// Market actions

export const INIT_MARKET = "[Market action] Init Market";
export class InitMarket implements Action {
 readonly type = INIT_MARKET;
 constructor(public bale: MarketBit) {}
}

export const UPDATE_MARKET = "[Market action] Update Market";
export class UpdateMarket implements Action {
 readonly type = UPDATE_MARKET;
 constructor(public bale: MarketBit) {}
}

export type Actions = | InitMarket | UpdateMarket ;

export { initMarket  } from "./buz/market.buzz";
export { updateMarket  } from "./buz/market.buzz";

import Market from "./fce/market.interface";
import MarketBit from "./fce/market.interface";

export class MarketModel implements Market {
 //idx:string;
 //marketBitList: MarketBit[] = [];
 //marketBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./market.action";
import { MarketModel } from "./market.model";
import * as Buzz from "./market.buzzer";
import State from "../99.core/state";

export function reducer(model: MarketModel = new MarketModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_MARKET:
 return Buzz.updateMarket(clone(model), act.bale, state);

 case Act.INIT_MARKET:
 return Buzz.initMarket(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class MarketUnit {

 constructor(state: State) {
 }
}

'use server'

import * as Import from "./BEE";
import State from "./99.core/state";

var dex = 0;

let instance = null;

var sim = {
  hunt: (a, b) => { },
  state: null
};

sim.hunt = (typ, obj) => { return host(obj, typ) }

var host = (obj, typ) => {

  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);

  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {

  if (!instance) {

    if (sim.state != null) return;
    sim.state = new State();
    sim.state.pivot = sim;
    sim.state.hunt = sim.hunt
    for (var k in Import.list) new Import.list[k](sim.state);
    instance = sim
  }


  return instance

};


export const market = async (typ, obj) => {
  return sim.hunt(typ, obj)
}
window.MARKET = require("../dist/168.market/hunt");

window.MQTT = require("async-mqtt");



import { CardanoModel } from "../cardano.model";
import CardanoBit from "../fce/cardano.bit";
import State from "../../99.core/state";

export const initCardano = (cpy: CardanoModel, bal: CardanoBit, ste: State) => {
    debugger
    return cpy;
};

export const updateCardano = (cpy: CardanoModel, bal: CardanoBit, ste: State) => {
    
    

    
    return cpy;
};


export const testCardano = (cpy: CardanoModel, bal: CardanoBit, ste: State) => {

    bal.slv({ mrkBit: { idx: "test-cardano" } });

    return cpy;
};


import { Action } from "../99.core/interface/action.interface";
import  CardanoBit  from "./fce/cardano.bit";

// Cardano actions

export const INIT_CARDANO = "[Cardano action] Init Cardano";
export class InitCardano implements Action {
 readonly type = INIT_CARDANO;
 constructor(public bale: CardanoBit) {}
}

export const UPDATE_CARDANO = "[Cardano action] Update Cardano";
export class UpdateCardano implements Action {
 readonly type = UPDATE_CARDANO;
 constructor(public bale: CardanoBit) {}
}

export const TEST_CARDANO = "[Test action] Test Cardano";
 export class TestCardano implements Action {
 readonly type = TEST_CARDANO;
 constructor(public bale: CardanoBit) {}
 }
 
export type Actions = | InitCardano | UpdateCardano 
| TestCardano
export { initCardano  } from "./buz/cardano.buzz";
export { updateCardano  } from "./buz/cardano.buzz";
export { testCardano  } from "./buz/cardano.buzz";
import Cardano from "./fce/cardano.interface";
import CardanoBit from "./fce/cardano.interface";

export class CardanoModel implements Cardano {
 //idx:string;
 //cardanoBitList: CardanoBit[] = [];
 //cardanoBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./cardano.action";
import { CardanoModel } from "./cardano.model";
import * as Buzz from "./cardano.buzzer";
import State from "../99.core/state";

export function reducer(model: CardanoModel = new CardanoModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CARDANO:
 return Buzz.updateCardano(clone(model), act.bale, state);

 case Act.INIT_CARDANO:
 return Buzz.initCardano(clone(model), act.bale, state);

case Act.TEST_CARDANO:
 return Buzz.testCardano(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class CardanoUnit {

 constructor(state: State) {
 }
}


export default interface CardanoBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  CardanoBit  from "./cardano.bit";

export default interface Cardano {
 // idx:string;
 // cardanoBitList: CardanoBit[];
 // cardanoBits:any;

}

import * as ActCol from "../../97.collect.unit/collect.action";
import * as ActWlt from "../wallet.action";

import { WalletModel } from "../wallet.model";
import WalletBit from "../fce/wallet.bit";
import PurseBit from "../fce/purse";
import State from "../../99.core/state";

var bit, val, idx, dex, lst, dat, src;

export const initWallet = (cpy: WalletModel, bal: WalletBit, ste: State) => {
    bal.slv({ intBit: { idx: "init-wallet" } });
    return cpy;
};

export const updateWallet = (cpy: WalletModel, bal: WalletBit, ste: State) => {
    bal.slv({ wltBit: { idx: "update-wallet" } });
    return cpy;
};

export const readWallet = async (cpy: WalletModel, bal: WalletBit, ste: State) => {
    if (bal.idx == null) bal.idx = 'wlt00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActWlt.CREATE_WALLET });
    if (bal.slv != null) bal.slv({ wltBit: { idx: "read-wallet", dat: bit.clcBit.dat } });
    return cpy;
};

export const writeWallet = async (cpy: WalletModel, bal: WalletBit, ste: State) => {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, dat: bal.dat, bit: ActWlt.CREATE_WALLET });
    if (bal.slv != null) bal.slv({ wltBit: { idx: "write-wallet", dat: bit.clcBit.dat } });
    return cpy;
};

export const removeWallet = async (cpy: WalletModel, bal: WalletBit, ste: State) => {
    bit = await ste.hunt(ActCol.REMOVE_COLLECT, { idx: bal.idx, bit: ActWlt.DELETE_WALLET });
    if (bal.slv != null) bal.slv({ wltBit: { idx: "remove-wallet", dat: bit.clcBit.dat } });
    return cpy;
};

export const deleteWallet = (cpy: WalletModel, bal: WalletBit, ste: State) => {
    if (bal.slv != null) bal.slv({ wltBit: { idx: "delete-wallet" } });
    return cpy;
};

export const createWallet = (cpy: WalletModel, bal: WalletBit, ste: State) => {
    var dat: PurseBit = { idx: bal.idx, src: "default-wallet", balance: 0, transactions: [] };
    
    if (bal.dat != null) {
        for (var key in bal.dat) {
            dat[key] = bal.dat[key];
        }
    }
    
    bal.slv({ wltBit: { idx: "create-wallet", dat: dat } });
    return cpy;
};

export default interface PurseBit {
 idx: string;
 src?: string;
 balance?:any;
 transactions?:any
}




export default interface WalletBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  WalletBit  from "./wallet.bit";

export default interface Wallet {
 // idx:string;
 // walletBitList: WalletBit[];
 // walletBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  WalletBit  from "./fce/wallet.bit";

// Wallet actions

export const INIT_WALLET = "[Wallet action] Init Wallet";
export class InitWallet implements Action {
 readonly type = INIT_WALLET;
 constructor(public bale: WalletBit) {}
}

export const UPDATE_WALLET = "[Wallet action] Update Wallet";
export class UpdateWallet implements Action {
 readonly type = UPDATE_WALLET;
 constructor(public bale: WalletBit) {}
}

export const READ_WALLET = "[Read action] Read Wallet";
 export class ReadWallet implements Action {
 readonly type = READ_WALLET;
 constructor(public bale: WalletBit) {}
 }
 
export const WRITE_WALLET = "[Write action] Write Wallet";
 export class WriteWallet implements Action {
 readonly type = WRITE_WALLET;
 constructor(public bale: WalletBit) {}
 }
 
export const REMOVE_WALLET = "[Remove action] Remove Wallet";
 export class RemoveWallet implements Action {
 readonly type = REMOVE_WALLET;
 constructor(public bale: WalletBit) {}
 }
 
export const DELETE_WALLET = "[Delete action] Delete Wallet";
 export class DeleteWallet implements Action {
 readonly type = DELETE_WALLET;
 constructor(public bale: WalletBit) {}
 }
 
export const CREATE_WALLET = "[Create action] Create Wallet";
 export class CreateWallet implements Action {
 readonly type = CREATE_WALLET;
 constructor(public bale: WalletBit) {}
 }
 
export type Actions = | InitWallet | UpdateWallet 
| ReadWallet
| WriteWallet
| RemoveWallet
| DeleteWallet
| CreateWallet
export { initWallet  } from "./buz/wallet.buzz";
export { updateWallet  } from "./buz/wallet.buzz";
export { readWallet  } from "./buz/wallet.buzz";
export { writeWallet  } from "./buz/wallet.buzz";
export { removeWallet  } from "./buz/wallet.buzz";
export { deleteWallet  } from "./buz/wallet.buzz";
export { createWallet  } from "./buz/wallet.buzz";
import Wallet from "./fce/wallet.interface";
import WalletBit from "./fce/wallet.interface";

export class WalletModel implements Wallet {
 //idx:string;
 //walletBitList: WalletBit[] = [];
 //walletBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./wallet.action";
import { WalletModel } from "./wallet.model";
import * as Buzz from "./wallet.buzzer";
import State from "../99.core/state";

export function reducer(model: WalletModel = new WalletModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_WALLET:
 return Buzz.updateWallet(clone(model), act.bale, state);

 case Act.INIT_WALLET:
 return Buzz.initWallet(clone(model), act.bale, state);

case Act.READ_WALLET:
 return Buzz.readWallet(clone(model), act.bale, state);
 
case Act.WRITE_WALLET:
 return Buzz.writeWallet(clone(model), act.bale, state);
 
case Act.REMOVE_WALLET:
 return Buzz.removeWallet(clone(model), act.bale, state);
 
case Act.DELETE_WALLET:
 return Buzz.deleteWallet(clone(model), act.bale, state);
 
case Act.CREATE_WALLET:
 return Buzz.createWallet(clone(model), act.bale, state);
 
 default:
 return model;
 }
}
import State from "../99.core/state";

export default class WalletUnit {

 constructor(state: State) {
 }
}

export const initClickup = (cpy: ClickupModel, bal:ClickupBit, ste: State) => {
 debugger
 return cpy;
};

export const updateClickup = (cpy: ClickupModel, bal:ClickupBit, ste: State) => {
 return cpy;
};


import { ClickupModel } from "../clickup.model";
import ClickupBit from "../fce/clickup.bit";
import State from "../../99.core/state";
import { Action } from "../99.core/interface/action.interface";
import  ClickupBit  from "./fce/clickup.bit";

// Clickup actions

export const INIT_CLICKUP = "[Clickup action] Init Clickup";
export class InitClickup implements Action {
 readonly type = INIT_CLICKUP;
 constructor(public bale: ClickupBit) {}
}

export const UPDATE_CLICKUP = "[Clickup action] Update Clickup";
export class UpdateClickup implements Action {
 readonly type = UPDATE_CLICKUP;
 constructor(public bale: ClickupBit) {}
}

export type Actions = | InitClickup | UpdateClickup ;

export { initClickup  } from "./buz/clickup.buzz";
export { updateClickup  } from "./buz/clickup.buzz";

import Clickup from "./fce/clickup.interface";
import ClickupBit from "./fce/clickup.interface";

export class ClickupModel implements Clickup {
 //idx:string;
 //clickupBitList: ClickupBit[] = [];
 //clickupBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./clickup.action";
import { ClickupModel } from "./clickup.model";
import * as Buzz from "./clickup.buzzer";
import State from "../99.core/state";

export function reducer(model: ClickupModel = new ClickupModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CLICKUP:
 return Buzz.updateClickup(clone(model), act.bale, state);

 case Act.INIT_CLICKUP:
 return Buzz.initClickup(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ClickupUnit {

 constructor(state: State) {
 }
}


export default interface ClickupBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  ClickupBit  from "./clickup.bit";

export default interface Clickup {
 // idx:string;
 // clickupBitList: ClickupBit[];
 // clickupBits:any;

}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {
      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

export interface Action<T = any> {
    type: string;
    bale?: T;
}

export interface Action<T = any> {
  type: string;
  bale?: T;
}

export default interface Model {}

import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_CLOCK = "[Clock action] Init Clock";
export const UPDATE_CLOCK = "[Clock action] Update Clock";
export const OPEN_CLOCK = "[Clock action] Open Clock";
export const WRITE_CLOCK = "[Clock action] Write Clock";
export const READ_CLOCK = "[Clock action] Read Clock";
export const REDUCE_CLOCK = "[Clock action] Reduce Clock";
export const COMPARE_CLOCK = "[Clock action] Compare Clock";

export const INIT_COLOR = "[Color action] Init Color";
export const UPDATE_COLOR = "[Color action] Update Color";
export const OPEN_COLOR = "[Open action] Open Color";
export const READ_COLOR = "[Read action] Read Color";
export const WRITE_COLOR = "[Write action] Write Color";
export const REMOVE_COLOR = "[Remove action] Remove Color";
export const DELETE_COLOR = "[Delete action] Delete Color";
export const CREATE_COLOR = "[Create action] Create Color";
export const LIST_COLOR = "[List action] List Color";
export const RANDOM_COLOR = "[Random action] Random Color";
export const BASKET_COLOR = "[Basket action] Basket Color";
export const ACCESS_COLOR = "[Access action] Access Color";
export const INIT_DISK = "[Disk action] Init Disk";
export const UPDATE_DISK = "[Disk action] Update Disk";
export const READ_DISK = "[Disk action] Read Disk";
export const WRITE_DISK = "[Disk action] Write Disk";
export const LIST_DISK = "[List action] List Disk";
export const LOAD_LIST_DISK = "[Load_list action] Load_list Disk";
export const COPY_DISK = "[Copy action] Copy Disk";
export const FRAME_DISK = "[Frame action] Frame Disk";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const CREATE_GRAPHIC = "[Graphic action] Create Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const INIT_LOOP = "[Loop action] Init Loop";
export const UPDATE_LOOP = "[Loop action] Update Loop";
export const CREATE_LOOP = "[Loop action] Create Loop";

export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SPECTRUM = "[Spectrum action] Init Spectrum";
export const UPDATE_SPECTRUM = "[Spectrum action] Update Spectrum";
export const MIN_SPECTRUM = "[Min action] Min Spectrum";
export const INIT_STAGE = "[Stage action] Init Stage";
export const SOLO_STAGE = "[Stage action] Solo Stage";
export const UPDATE_STAGE = "[Stage action] Update Stage";
export const RESIZE_STAGE = "[Stage action] Resize Stage";
export const RENDER_STAGE = "[Stage action] Render Stage";
export const INIT_STREAM = "[Stream action] Init Stream";
export const OPEN_STREAM = "[Stream action] Open Stream";
export const UPDATE_STREAM = "[Stream action] Update Stream";

// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const OPEN_TERMINAL = "[Terminal action] Open Terminal";
export const FOCUS_TERMINAL = "[Terminal action] Focus Terminal";
export const WRITE_TERMINAL = "[Terminal action] Write Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const CLEAR_TERMINAL = "[Terminal action] Clear Terminal";
export const INPUT_TERMINAL = "[Terminal action] Input Terminal";
export const TABLE_TERMINAL = "[Terminal action] Table Terminal";
export const CLOSE_TERMINAL = "[Terminal action] Close Terminal";
export const ROOT_TERMINAL = "[Terminal action] Root Terminal";
export const CONTENT_TERMINAL = "[Terminal action] Content Terminal";
export const ADD_PORT = "[Terminal action] Add Port";

export const INIT_TIME = "[Time action] Init Time";
export const UPDATE_TIME = "[Time action] Update Time";
export const NOW_TIME = "[Time action] Now Time";
export const FORMAT_TIME = "[Time action] Format Time";
import Model from "./99.core/interface/model.interface";

import MarketUnit from "./00.market.unit/market.unit";
import CardanoUnit from "./01.cardano.unit/cardano.unit";
import WalletUnit from "./02.wallet.unit/wallet.unit";
import ClickupUnit from "./10.clickup.unit/clickup.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Market from "./00.market.unit/fce/market.interface";
import { MarketModel } from "./00.market.unit/market.model";
import Cardano from "./01.cardano.unit/fce/cardano.interface";
import { CardanoModel } from "./01.cardano.unit/cardano.model";
import Wallet from "./02.wallet.unit/fce/wallet.interface";
import { WalletModel } from "./02.wallet.unit/wallet.model";
import Clickup from "./10.clickup.unit/fce/clickup.interface";
import { ClickupModel } from "./10.clickup.unit/clickup.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [MarketUnit,CardanoUnit,WalletUnit,ClickupUnit,CollectUnit,BusUnit];

import * as reduceFromMarket from "./00.market.unit/market.reduce";
import * as reduceFromCardano from "./01.cardano.unit/cardano.reduce";
import * as reduceFromWallet from "./02.wallet.unit/wallet.reduce";
import * as reduceFromClickup from "./10.clickup.unit/clickup.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 market : reduceFromMarket.reducer, 
cardano : reduceFromCardano.reducer, 
wallet : reduceFromWallet.reducer, 
clickup : reduceFromClickup.reducer, 
collect : reduceFromCollect.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 market : Market = new MarketModel();
cardano : Cardano = new CardanoModel();
wallet : Wallet = new WalletModel();
clickup : Clickup = new ClickupModel();
collect : Collect = new CollectModel();
bus : Bus = new BusModel();

 
}

var sim = {
  hunt:null,
  state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
  
  init();

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  if (obj == null) obj = {};
  if (obj.slv == null) obj.slv = (val0) => slv(val0);
  
  sim.state.dispatch({ type: typ, bale: obj });
  return promo;
};

var init = () => {
  if (sim.state != null) return;
  sim.state = new State();
  sim.state.pivot = sim;
  sim.state.hunt = sim.hunt
  for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export const POOL: string = "pool";

import { LibraryModel } from "../library.model";
import LibraryBit from "../fce/library.bit";
import State from "../../99.core/state";


import * as ActSrv from "../../04.server.unit/server.action";

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActOlm from "../../10.ollama.unit/ollama.action";
import * as ActPmt from "../../12.prompt.unit/prompt.action";


import * as ActLib from "../library.action";


import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import openEditor from 'open-editor';

var bit, val, idx, dex, lst, dat;

var exec = require('child_process').exec;

export const initLibrary = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    global.CONTROL = null
    global.TIME = null
    global.SPACE = null
    global.SHADE = null
    global.SOLID = null
    global.PIXEL = null

    if (bal.dat != null) bit = await ste.hunt(ActBus.INIT_BUS, { idx: cpy.idx, lst: [ActLib, ActOlm, ActPmt] , dat: bal.dat, src: bal.src })
    
    setInterval( async ()=>{

        ste.bus("[Open action] Open Pixel", {})

    }, 4444 )

    //if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, bal);
    patch(ste, ActMnu.INIT_MENU, bal);
    if (bal.slv != null) bal.slv({ intBit: { idx: "init-control" } });

    return cpy;
};

export const devLibrary = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    var bit = await ste.hunt(ActSrv.UPDATE_SERVER, {})

    const { spawn } = require('child_process');
    const path = require('path');

    var batch;

    async function launchBatchFile(userInputPath) {
        const sanitizedPath = path.normalize(userInputPath); // Sanitize the path

        batch = spawn('cmd', ['/c', sanitizedPath]);

        batch.stdout.on('data', async (data) => {
            bit = await ste.hunt(ActMnu.PRINT_MENU, { src: `stdout: ${data}` });
            //console.log(`stdout: ${data}`);
        });

        batch.stderr.on('data', async (data) => {
            bit = await ste.hunt(ActMnu.PRINT_MENU, { src: `stdout: ${data}` });
            //console.error(`stderr: ${data}`);
        });

        batch.on('close', async (code) => {
            //console.log(`child process exited with code ${code}`);

            //FS.emptyDir( dest, ()=>{
            //  FS.copySync('./dist/win-unpacked/' , dest )
            //})

            //console.log("application complete ")

            bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "application complete " });

        });


        bit = await ste.hunt(ActMnu.PRINT_MENU, { src: 'Batch file launched!' });


    }



    const process = require('process');


    //launchBatchFile(process.env.WRANGLER_BAT);
    //launchBatchFile(process.env.OPEN_BAT);

    //process.cwd('../001.alligator.quest/')
    
    
    
    launchBatchFile(process.env.OPEN_BAT);
    

    exec('wrangler pages dev dist', async (err, stdout, stderr) => {
        if (err) {
            console.error(`exec error: ${err}`);
        }
        ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "--" + stdout })
    })

    bal.slv({ libBit: { idx: "dev-library", val: 0 } });
    return cpy;
};

export const listLibrary = (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    var FS = require('fs-extra')
    var list = FS.readdirSync('./')

    const pattern = /^\d{3}\.[a-zA-Z]+$/;
    const newArray = list.filter(item => pattern.test(item));

    bal.slv({ libBit: { idx: "list-library", lst: newArray } });
    return cpy;
};


export const setupSpectrum = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    console.log('testing the library')

    bal.slv({ libBit: { idx: "test-library" } });
    return cpy;
};

export const testLibrary = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "testing the library" })

    bal.slv({ libBit: { idx: "test-library" } });
    return cpy;
};

export const updateLibrary = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    var FS = require("fs-extra");
    var doT = require("dot");
    var S = require("string");

    var title = "995.library";
    var file = "./data/redux/BEE.txt";
    var fileFin = "./data/redux/BEE.ts";

    title = bal.src

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    var list = FS.readdirSync("./" + title);
    var lineList = FS.readFileSync(file).toString().split("\n");

    var out = [];
    var dirList = [];

    var itemList = [];

    list.forEach(async (a, b) => {
        list[b] = "./" + title + "/" + a;

        if (FS.lstatSync(list[b]).isDirectory()) {
            if (S(list[b]).contains("unit") == false) return;

            var directory = list[b] + "/";
            var element = a.split(".")[1];



            var unitName = capitalizeFirstLetter(element);

            var unitImportSrc = "./" + a + "/" + element + ".unit";
            var unitImportSte = "import " + unitName + 'Unit from "' + unitImportSrc + '";';

            var faceImportSrc = "./" + a + "/fce/" + element + ".interface";
            var faceImportSte = "import " + unitName + ' from "' + faceImportSrc + '";';

            var modlImportSrc = "./" + a + "/" + element + ".model";
            var modlImportSte = "import { " + unitName + 'Model } from "' + modlImportSrc + '";';

            var redcImportSrc = "./" + a + "/" + element + ".reduce";
            var redcImportSte = "import * as reduceFrom" + unitName + ' from "' + redcImportSrc + '";';

            var reduced = element + " : reduceFrom" + unitName + ".reducer";
            var model = element + " : " + unitName + " = new " + unitName + "Model();";

            var item = {
                model,
                reduced,
                redcI: redcImportSte,
                modlI: modlImportSte,
                facI: faceImportSte,
                untI: unitImportSte,
                unitName,
                element,
            };

            itemList.push(item);
        }
    });

    var unitImports = "";
    itemList.forEach((a) => {
        unitImports += a.untI + "\n";
    });

    var faceImports = "";
    itemList.forEach((a) => {
        faceImports += a.facI + "\n";
        faceImports += a.modlI + "\n";
    });

    var unitListNom = [];
    itemList.forEach((a) => {
        unitListNom.push(a.unitName + "Unit");
    });

    var unitList = JSON.stringify(unitListNom) + ";";
    unitList = S(unitList).replaceAll('"', "");

    var reduceImports = "";
    itemList.forEach((a) => {
        reduceImports += a.redcI + "\n";
    });

    var reduceList = "";
    itemList.forEach((a, b) => {
        //if (b == reduceList.length - 1) return;
        reduceList += a.reduced + ", \n";
    });

    //reduceList += itemList[itemList.length - 1].reduced + "\n";

    var modelList = "";
    itemList.forEach((a, b) => {
        modelList += a.model + "\n";
    });

    var gel = {
        unitImports,
        faceImports,
        unitList,
        reduceImports,
        reduceList,
        modelList,
    };

    var writeLine = [];

    lineList.forEach(async (a, b) => {


        if (S(a).contains("//")) return;

        var doTCompiled = doT.template(a);
        var outLine = doTCompiled(gel);

        writeLine.push(outLine);
    });

    writeLine.forEach(async (a) => {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "line : " + a })
    });

    var finFile = writeLine.join("\n");

    FS.ensureFileSync(fileFin);

    var endLoc = "./" + title + "/BEE.ts";


    finFile


    FS.writeFileSync(endLoc, finFile);

    bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "writing " + endLoc })


    bal.slv({ libBit: { idx: "update-library" } });
    return cpy;
};

export const countLibrary = async (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    var Walk = require("@root/walk");
    var path = require("path");
    var FS = require('fs-extra')

    var output = []

    var direct = {}
    var snowflake = {}

    function walkFunc(err, pathname, dirent) {
        if (err) {
            // throw an error to stop walking
            // (or return to ignore and keep going)
            console.warn("fs stat error for %s: %s", pathname, err.message);
            return Promise.resolve();
        }

        if (dirent.isDirectory() && dirent.name == 'data') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == 'dist') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == 'node_modules') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == 'public') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == 'modules') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == '.') { return Promise.resolve(false) }


        if (dirent.isDirectory() && dirent.name.startsWith(".")) {
            return Promise.resolve(false);
        }

        if (dirent.isFile() && dirent.name.startsWith(".") == false) {
            var file = path.join(path.dirname(pathname), dirent.name);
            output.push(file)

            if (direct[path.dirname(pathname)] == null) direct[path.dirname(pathname)] = ''
        }

        return Promise.resolve();
    }

    await Walk.walk('./', walkFunc);

    output

    const allowedExtensions = new Set(['.ts', '.js', '.mjs', '.cjs', '.tsx', '.jsx', '.css']);

    const paths = output.filter(filePath => {
        const extension = path.extname(filePath).toLowerCase(); // Ensure case-insensitivity for extension
        return allowedExtensions.has(extension);
    });

    paths


    var out = []

    paths.forEach((a) => {
        var lst = FS.readFileSync(a).toString().split('\n');
        out = out.concat(lst)
    })

    var score = []

    out.forEach((a) => {
        if (a.length < 5) return
        a = a.replaceAll(' ', '')
        if (a.length <= 3) return
        if (a.includes('//')) return
        //if (a.includes('console.log')) return
        if (a.includes('returncpy')) return
        score.push(a)
        if (snowflake[a] == null) snowflake[a] = 1
    })

    direct
    score

    var fin = score.length

    FS.writeFileSync('./data/complete.txt', out.join('\n'))

    const { DateTime } = require("luxon");
    const dt = DateTime.local();
    var now = dt.toLocaleString(DateTime.DATETIME_FULL);
    var S = require('string')
    now = now.replace(':', '-')
    now = S(now).slugify().s;

    var pow = 0;

    for (var key in snowflake) {
        pow += 1;
    }

    var percent = fin / 300000 * 100;


    var line0 = fin + ' : ' + pow + ' : ' + now;
    var line1 = percent.toFixed(3) + '% of 300,000 lines of code to go'

    var list = FS.readFileSync('./data/line-log.txt').toString().split('\n')

    var past = list[0];
    var last = Number(past.split(':')[0])

    if (last != fin) {
        list.unshift(line1)
        list.unshift(line0)
        list
        FS.writeFileSync('./data/line-log.txt', list.join('\n'))

        const fileToOpen = './data/line-log.txt'; // Replace with your file path

        try {
            //console.log(`Attempting to open ${fileToOpen}...`);
            const output = await openFileInVSCode(fileToOpen);
            //console.log(`Successfully attempted to open ${fileToOpen} in VS Code.`);
            if (output) {
                // console.log(`VS Code STDOUT: ${output}`);
            }
            // If you resolved with { stdout, stderr }:
            // if (output.stdout) console.log(`VS Code STDOUT: ${output.stdout}`);
            // if (output.stderr) console.warn(`VS Code STDERR: ${output.stderr}`);

        } catch (error) {
            //console.error(`Operation failed: ${error.message}`);
            //if (error.hint) {
            //    console.error(`Hint: ${error.hint}`);
            // }
            if (error.stderr) { // stderr attached to our custom error
                // console.error(`STDERR content during failure: ${error.stderr}`);
            }
            // console.error("Full error object:", error);
        }

    }

    bal.slv({ libBit: { idx: "count-library", val: fin } });
    return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

function openFileInVSCode(filePath) {

    const { exec } = require('child_process');
    const path = require('path');

    return new Promise((resolve, reject) => {
        const absoluteFilePath = path.resolve(filePath);
        const vscodeCommand = process.platform === 'win32' ? 'code.cmd' : 'code';
        const command = `${vscodeCommand} "${absoluteFilePath}"`;

        //console.log(`Executing: ${command}`);

        exec(command, (error, stdout, stderr) => {
            if (error) {
                // Construct a more informative error object
                const errDetails = new Error(`Error opening file with VS Code: ${error.message}`);
                // errDetails.originalError = error; // Optionally attach original error
                //errDetails.stdout = stdout;
                //errDetails.stderr = stderr; // stderr from exec might be useful even on error

                //if (error.message.includes('not found') || error.message.includes('is not recognized')) {
                //  errDetails.hint = "Ensure 'code' (or 'code.cmd' on Windows) is in your system's PATH. " +
                "Run 'Shell Command: Install \"code\" command in PATH' from VS Code's command palette.";
                // }
                reject(errDetails);
                return;
            }

            // Even on success, VS Code might output to stderr (e.g., warnings)
            // We can pass stdout and stderr along for the caller to inspect.
            // For simplicity, just resolving with stdout here.
            // Or resolve({ stdout, stderr }) if both are needed.
            resolve(stdout); // Or resolve({ stdout, stderr })
        });
    });
}



export const astroLibrary = (cpy: LibraryModel, bal: LibraryBit, ste: State) => {

    var FS = require('fs-extra')

    var list = FS.readdirSync('./public/process/txt');


    list.forEach((a, b) => {

        var idx = String(b).padStart(4, '0');

        var now = a.split('.')
        now.pop()
        now = now.join('.')

        const size = 3;
        var source = FS.readFileSync('./public/process/txt/' + a).toString().split('\n')

        source.unshift('---')
        source.unshift('description: A reference page in my new Starlight docs site.')
        source.unshift('title: ' + idx + '.' + now + 'title')
        source.unshift('---')

        var cohere = source.join('\n')

        FS.writeFileSync('./public/process/md/' + idx + '.' + now + '.md', cohere)

    })


    bal.slv({ libBit: { idx: "astro-library", val: 1 } });
    return cpy;
};

export const questLibrary = (cpy: LibraryModel, bal: LibraryBit, ste: State) => {
    debugger
    return cpy;
};

export default interface LibraryBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  LibraryBit  from "./library.bit";

export default interface Library {
 // idx:string;
 // libraryBitList: LibraryBit[];
 // libraryBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  LibraryBit  from "./fce/library.bit";

// Library actions

export const INIT_LIBRARY = "[Library action] Init Library";
export class InitLibrary implements Action {
 readonly type = INIT_LIBRARY;
 constructor(public bale: LibraryBit) {}
}

export const UPDATE_LIBRARY = "[Library action] Update Library";
export class UpdateLibrary implements Action {
 readonly type = UPDATE_LIBRARY;
 constructor(public bale: LibraryBit) {}
}

export const TEST_LIBRARY = "[Library action] Test Library";
export class TestLibrary implements Action {
 readonly type = TEST_LIBRARY;
 constructor(public bale: LibraryBit) {}
}

export const COUNT_LIBRARY = "[Count action] Count Library";
 export class CountLibrary implements Action {
 readonly type = COUNT_LIBRARY;
 constructor(public bale: LibraryBit) {}
 }
 
export const LIST_LIBRARY = "[List action] List Library";
 export class ListLibrary implements Action {
 readonly type = LIST_LIBRARY;
 constructor(public bale: LibraryBit) {}
 }
 
export const DEV_LIBRARY = "[Dev action] Dev Library";
 export class DevLibrary implements Action {
 readonly type = DEV_LIBRARY;
 constructor(public bale: LibraryBit) {}
 }

 export const SETUP_SPECTRUM = "[Library action] Setup Spectrum";
 export class SetupSpectrum implements Action {
 readonly type = SETUP_SPECTRUM;
 constructor(public bale: LibraryBit) {}
 }
 
export const ASTRO_LIBRARY = "[Astro action] Astro Library";
 export class AstroLibrary implements Action {
 readonly type = ASTRO_LIBRARY;
 constructor(public bale: LibraryBit) {}
 }
 
export const QUEST_LIBRARY = "[Quest action] Quest Library";
 export class QuestLibrary implements Action {
 readonly type = QUEST_LIBRARY;
 constructor(public bale: LibraryBit) {}
 }
 
export type Actions = | InitLibrary | UpdateLibrary | TestLibrary 
| CountLibrary
| ListLibrary
| DevLibrary
| SetupSpectrum
| AstroLibrary
| QuestLibrary
export { initLibrary  } from "./buz/library.buzz";
export { updateLibrary  } from "./buz/library.buzz";
export { testLibrary  } from "./buz/library.buzz";
export { countLibrary  } from "./buz/library.buzz";
export { listLibrary  } from "./buz/library.buzz";
export { devLibrary  } from "./buz/library.buzz";
export { setupSpectrum  } from "./buz/library.buzz";
export { astroLibrary  } from "./buz/library.buzz";
export { questLibrary  } from "./buz/library.buzz";
import Library from "./fce/library.interface";
import LibraryBit from "./fce/library.interface";

export class LibraryModel implements Library {
    idx: string = '995.library';
 //libraryBitList: LibraryBit[] = [];
 //libraryBits: any = {};
  sourceDirectoryLocation:'hard code location'// comes from the environment file
}

import * as clone from "clone-deep";
import * as Act from "./library.action";
import { LibraryModel } from "./library.model";
import * as Buzz from "./library.buzzer";
import State from "../99.core/state";

export function reducer(model: LibraryModel = new LibraryModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_LIBRARY:
            return Buzz.updateLibrary(clone(model), act.bale, state);

        case Act.TEST_LIBRARY:
            return Buzz.testLibrary(clone(model), act.bale, state);

        case Act.INIT_LIBRARY:
            return Buzz.initLibrary(clone(model), act.bale, state);

        case Act.COUNT_LIBRARY:
            return Buzz.countLibrary(clone(model), act.bale, state);

        case Act.LIST_LIBRARY:
            return Buzz.listLibrary(clone(model), act.bale, state);

        case Act.DEV_LIBRARY:
            return Buzz.devLibrary(clone(model), act.bale, state);

        case Act.SETUP_SPECTRUM:
            return Buzz.setupSpectrum(clone(model), act.bale, state);

case Act.ASTRO_LIBRARY:
 return Buzz.astroLibrary(clone(model), act.bale, state);
 
case Act.QUEST_LIBRARY:
 return Buzz.questLibrary(clone(model), act.bale, state);
 
        default:
            return model;
    }
}

import State from "../99.core/state";


export default class LibraryUnit {

 constructor(state: State) {
 }
}

global.LIBRARY = require("../dist/995.library/hunt");
global.LIBRARY.ActLib = require("../dist/995.library/00.library.unit/library.action");






import * as ActCns from "../../83.console.unit/console.action";

import { UnitModel } from "../unit.model";
import UnitBit from "../fce/unit.bit";
import State from "../../99.core/state";

export const initUnit = (cpy: UnitModel, bal: UnitBit, ste: State) => {
    debugger
    return cpy;
};

export const createUnit = (cpy: UnitModel, bal: UnitBit, ste: State) => {

    if (bal.idx == null) bal.idx = "alligator";

    var FS = require("fs-extra");
    var doT = require("dot");
    var S = require("string");

    var title = '00.' + bal.idx;

    var loc = "./data/redux/00.sim.unit/";

    //cpy effect redux data in project data
    FS.copySync("./data/00.sim.unit", "./data/redux/00.sim.unit");

    var num = title.split(".")[0];
    var nom = title.split(".")[1];

    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "nom " + nom })

    var file = loc;
    var list = FS.readdirSync(file);

    var out = [];
    list.forEach((a, b) => {
        list[b] = file + "/" + a;

        if (FS.lstatSync(list[b]).isDirectory()) {
            var directory = list[b];
            var listB = FS.readdirSync(directory);
            listB.forEach((c) => out.push(directory + "/" + c));
        } else {
            out.push(list[b]);
        }
    });

    if (nom == null) nom = "beeing";

    function capitalizeFirstLetter(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
    }

    var gel = {
        idx: "together000",
        title: capitalizeFirstLetter(nom),
        nom: nom,

        wakeActionKey: nom.toUpperCase() + "_OPEN",
        initActionKey: "INIT_" + nom.toUpperCase(),
        updateActionKey: "UPDATE_" + nom.toUpperCase(),

        wakeActionFunction: capitalizeFirstLetter(nom),
        initActionFunction: "Init" + capitalizeFirstLetter(nom),
        updateActionFunction: "Update" + capitalizeFirstLetter(nom),

        bitNom: nom + "Bit",
        bitTitle: capitalizeFirstLetter(nom) + "Bit",
        actionLabel: capitalizeFirstLetter(nom),

        actionTitle: "Waking " + capitalizeFirstLetter(nom),
        initTitle: "Init " + capitalizeFirstLetter(nom),
        updateTitle: "Update " + capitalizeFirstLetter(nom),
    };

    out.forEach((a) => {
        var neo = a.replace("sim", gel.nom);
        neo = neo.replace(".sim", "." + gel.nom);

        //console.log("neo " + neo);

        var lineList = FS.readFileSync(a).toString().split("\n");

        lineList.forEach((a, b) => {
            //console.log("line " + a);
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            lineList[b] = outLine;
        });

        lineList.forEach((a) => {
            //console.log("line : " + a);
        });

        var finFin = neo.replace("sim", gel.nom);
        //console.log("what you got for a fin fin " + finFin);

        finFin = finFin.replace("../data/redux/", "../data/redux/unit/");

        finFin = finFin.replace("00", num);

        finFin = finFin.replace(".txt", ".ts");

        var finFile = lineList.join("\n");

        FS.ensureFileSync(finFin);
        FS.writeFileSync(finFin, finFile);

        ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "writing " + finFin })

    });

    setTimeout(() => {
        if (bal.slv != null)
            bal.slv({ untBit: { idx: "create-unit", dat: { idx: bal.idx } } });
    }, 2111);



    return cpy;


};

export const testUnit = (cpy: UnitModel, bal: UnitBit, ste: State) => {
    debugger
    return cpy;
};

export const updateUnit = async (cpy: UnitModel, bal: UnitBit, ste: State) => {

    var FS = require('fs-extra')

    var bit;
    var root = bal.idx.split('.')[1];
    var rootUpper = root.charAt(0).toUpperCase() + root.slice(1);
    var nom = bal.dat;
    var nomUpper = nom.charAt(0).toUpperCase() + nom.slice(1);

    var buzzFile = './' + bal.src + '/' + bal.idx + '/buz/' + root + '.buzz.ts';
    var buzzerFile = './' + bal.src + '/' + bal.idx + '/' + root + '.buzzer.ts';
    var actionFile = './' + bal.src + '/' + bal.idx + '/' + root + '.action.ts';
    var reduceFile = './' + bal.src + '/' + bal.idx + '/' + root + '.reduce.ts';

    var existBuzz = FS.existsSync(buzzFile);
    var existBuzzer = FS.existsSync(buzzerFile);
    var existAction = FS.existsSync(actionFile);
    var existReduce = FS.existsSync(reduceFile);
    if (existBuzz == false || existAction == false || existReduce == false || existBuzzer == false) {
        if (bal.slv != null)
            bal.slv({ untBit: { idx: "update-unit-error", src: 'no exist on source file' } });
        return;
    }
    var listBuzz = FS.readFileSync(buzzFile).toString().split('\n');
    var listBuzzer = FS.readFileSync(buzzerFile).toString().split('\n');
    var listAction = FS.readFileSync(actionFile).toString().split('\n');
    var listReduce = FS.readFileSync(reduceFile).toString().split('\n');
    var doT = require("dot");
    const updateBuzz = (lst) => {
        var hold = [];
        var out = [];
        lst.forEach((a, b) => {
            if (a.includes('import'))
                hold.push(b);
        });
        var dex = 0;
        hold = hold.reverse();
        var flag = false;
        hold.forEach((a, b) => {
            if (flag == true)
                return;
            var now = a - 1;
            var nxt = hold[b + 1];
            if (nxt == now) {
                dex = nxt;
            }
            else
                flag = true;
        });
        var buzNom = nom + rootUpper;
        var cpyNom = rootUpper + 'Model';
        var balNom = rootUpper + "Bit";
        var lineList = cpy.buzzTemplate.toString().split("\n");
        var gel = { buzNom, cpyNom, balNom };
        lineList.forEach((a, b) => {
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            out.push(outLine);
        });
        return { lst: out, val: dex };
    };
    const updateActionUpper = (lst) => {
        var out = [];
        var dex = 0;
        lst.forEach((a, b) => {
            if (a.includes('export type Actions') == true)
                dex = b;
        });
        var actUpr = nom + '_' + rootUpper;
        actUpr = actUpr.toUpperCase();
        var actMsg = '[' + nomUpper + ' action] ' + nomUpper + ' ' + rootUpper;
        var actTle = nomUpper + rootUpper;
        var bitNom = rootUpper + "Bit";
        var lineList = cpy.actTemplate.toString().split("\n");
        var gel = { actUpr, actMsg, actTle, bitNom };
        lineList.forEach((a, b) => {
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            out.push(outLine);
        });
        return { lst: out, val: dex };
    };
    const updateActionLower = (lst) => {
        var out = [];
        var dex = 0;
        lst.forEach((a, b) => {
            if (a.includes('export type Actions =') == true)
                dex = b;
        });
        var actTle = nomUpper + rootUpper;
        var lineList = cpy.actTemplateLower.toString().split("\n");
        var gel = { actTle };
        lineList.forEach((a, b) => {
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            out.push(outLine);
        });
        return { lst: out, val: dex };
    };
    const updateReduce = (lst) => {
        var out = [];
        var dex = 0;
        lst.forEach((a, b) => {
            if (a.includes('default') == true)
                dex = b;
        });
        var actUpr = nom + '_' + rootUpper;
        actUpr = actUpr.toUpperCase();
        var actTle = nom + rootUpper;
        var lineList = cpy.reduceTemplate.toString().split("\n");
        var gel = { actUpr, actTle };
        lineList.forEach((a, b) => {
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            out.push(outLine);
        });
        return { lst: out, val: dex };
    };
    const updateBuzzer = (lst) => {
        var out = [];
        var actTle = nom + rootUpper;
        var lineList = cpy.buzzerTemplate.toString().split("\n");
        var gel = { actTle, root };
        lineList.forEach((a, b) => {
            var doTCompiled = doT.template(a);
            var outLine = doTCompiled(gel);
            lst.push(outLine);
        });
        return { lst };
    };
    var buzzBit = updateBuzz(listBuzz);
    var buzzerBit = updateBuzzer(listBuzzer);
    var actionUpperBit = updateActionUpper(listAction);
    var actionLowerBit = updateActionLower(listAction);
    var reduceBit = updateReduce(listReduce);
    // merge 'b' with 'a' at index 'i'
    const merge = (a, b, i = 0) => {
        return a.slice(0, i).concat(b, a.slice(i));
    };
    var resultBuzz = merge(listBuzz, buzzBit.lst, buzzBit.val);
    var resultBuzzer = buzzerBit.lst.filter((e) => { return e.length > 2; });
    var resultReduce = merge(listReduce, reduceBit.lst, reduceBit.val);
    var resultActionUpper = merge(listAction, actionUpperBit.lst, actionUpperBit.val);
    var upperActionDex = updateActionUpper(resultActionUpper).val;
    var lowerDex = actionLowerBit.val;
    var lowerActionList = listAction.slice(lowerDex, listAction.length);
    lowerActionList.forEach((a, b) => {
        lowerActionList[b] = a.replace(';', '');
    });
    lowerActionList = lowerActionList.filter((e) => {
        if (e.length >= 2)
            return e;
    });
    lowerActionList.push('| ' + nomUpper + rootUpper);
    lowerActionList.unshift(' ');
    resultActionUpper = resultActionUpper.slice(0, upperActionDex);
    var resultAction = resultActionUpper.concat(lowerActionList);
    bit = await FS.writeFile(buzzFile, resultBuzz.join('\n'));

    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'writing...' + buzzFile })
    bit = await FS.writeFile(buzzerFile, resultBuzzer.join('\n'));

    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'writing...' + buzzerFile })
    bit = await FS.writeFile(reduceFile, resultReduce.join('\n'));
    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'writing...' + reduceFile })

    bit = await FS.writeFile(actionFile, resultAction.join('\n'));
    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: 'writing...' + actionFile })

    setTimeout(() => {
        if (bal.slv != null)
            bal.slv({ untBit: { idx: "update-unit", dat: bal } });
    }, 2111);


    return cpy;
};

export const listUnit = (cpy: UnitModel, bal: UnitBit, ste: State) => {

    var path = './' + bal.src;

    var FS = require('fs-extra')
    var option = FS.pathExistsSync(path)

    lst = []

    if (option == true) {
        var list = FS.readdirSync('./' + bal.src);
        var lst = list.filter((e) => { return e.includes('.unit') == true; });
        bal.slv({ untBit: { idx: "list-unit", lst, val: 1 } });
        return cpy;
    }

    bal.slv({ untBit: { idx: "list-unit", lst, val: 0 } });

    return cpy;
};




export default interface UnitBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  UnitBit  from "./unit.bit";

export default interface Unit {
 // idx:string;
 // unitBitList: UnitBit[];
 // unitBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  UnitBit  from "./fce/unit.bit";

// Unit actions

export const INIT_UNIT = "[Unit action] Init Unit";
export class InitUnit implements Action {
 readonly type = INIT_UNIT;
 constructor(public bale: UnitBit) {}
}

export const UPDATE_UNIT = "[Unit action] Update Unit";
export class UpdateUnit implements Action {
 readonly type = UPDATE_UNIT;
 constructor(public bale: UnitBit) {}
}

export const LIST_UNIT = "[List action] List Unit";
 export class ListUnit implements Action {
 readonly type = LIST_UNIT;
 constructor(public bale: UnitBit) {}
 }
 
export const CREATE_UNIT = "[Create action] Create Unit";
 export class CreateUnit implements Action {
 readonly type = CREATE_UNIT;
 constructor(public bale: UnitBit) {}
 }
 
export const TEST_UNIT = "[Test action] Test Unit";
 export class TestUnit implements Action {
 readonly type = TEST_UNIT;
 constructor(public bale: UnitBit) {}
 }
 
export type Actions = | InitUnit | UpdateUnit 
| ListUnit
| CreateUnit
| TestUnit
export { initUnit  } from "./buz/unit.buzz";
export { updateUnit  } from "./buz/unit.buzz";
export { listUnit  } from "./buz/unit.buzz";
export { createUnit  } from "./buz/unit.buzz";
export { testUnit  } from "./buz/unit.buzz";
import Unit from "./fce/unit.interface";
import UnitBit from "./fce/unit.interface";

export class UnitModel implements Unit {
    //idx:string;
    //unitBitList: UnitBit[] = [];
    //unitBits: any = {};
    buzzTemplate = `export const {{=it.buzNom}} = (cpy: {{=it.cpyNom}}, bal:{{=it.balNom}}, ste: State) => {
    debugger
    return cpy;
   };`;

    buzzerTemplate = `export { {{=it.actTle}}  } from "./buz/{{=it.root}}.buzz";`;
    actTemplate = `export const {{=it.actUpr}} = "{{=it.actMsg}}";
 export class {{=it.actTle}} implements Action {
  readonly type = {{=it.actUpr}};
  constructor(public bale: {{=it.bitNom}}) {}
 }`;

    actTemplateLower = `
 export type Actions = | {{=it.actTle}}
 `;

    reduceTemplate = `case Act.{{=it.actUpr}}:
 return Buzz.{{=it.actTle}}(clone(model), act.bale, state);
 `;

}

import * as clone from "clone-deep";
import * as Act from "./unit.action";
import { UnitModel } from "./unit.model";
import * as Buzz from "./unit.buzzer";
import State from "../99.core/state";

export function reducer(model: UnitModel = new UnitModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_UNIT:
 return Buzz.updateUnit(clone(model), act.bale, state);

 case Act.INIT_UNIT:
 return Buzz.initUnit(clone(model), act.bale, state);

case Act.LIST_UNIT:
 return Buzz.listUnit(clone(model), act.bale, state);
 
case Act.CREATE_UNIT:
 return Buzz.createUnit(clone(model), act.bale, state);
 
case Act.TEST_UNIT:
 return Buzz.testUnit(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class UnitUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  ActionBit  from "./fce/action.bit";

// Action actions

export const INIT_ACTION = "[Action action] Init Action";
export class InitAction implements Action {
 readonly type = INIT_ACTION;
 constructor(public bale: ActionBit) {}
}

export const UPDATE_ACTION = "[Action action] Update Action";
export class UpdateAction implements Action {
 readonly type = UPDATE_ACTION;
 constructor(public bale: ActionBit) {}
}

export type Actions = | InitAction | UpdateAction ;

export { initAction  } from "./buz/action.buzz";
export { updateAction  } from "./buz/action.buzz";

import Action from "./fce/action.interface";
import ActionBit from "./fce/action.interface";

export class ActionModel implements Action {
 //idx:string;
 //actionBitList: ActionBit[] = [];
 //actionBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./action.action";
import { ActionModel } from "./action.model";
import * as Buzz from "./action.buzzer";
import State from "../99.core/state";

export function reducer(model: ActionModel = new ActionModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_ACTION:
 return Buzz.updateAction(clone(model), act.bale, state);

 case Act.INIT_ACTION:
 return Buzz.initAction(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ActionUnit {

 constructor(state: State) {
 }
}

import * as ActCns from "../../83.console.unit/console.action";

import { ActionModel } from "../action.model";
import ActionBit from "../fce/action.bit";
import State from "../../99.core/state";

import * as ActLib from '../../00.library.unit/library.action'

var lst, bit;

export const initAction = (cpy: ActionModel, bal: ActionBit, ste: State) => {
    debugger
    return cpy;
};

export const updateAction = async (cpy: ActionModel, bal: ActionBit, ste: State) => {

    var dom = bal.idx.split('.')[1]
    var file = './' + bal.src + '/' + bal.idx + '/' + dom + '.action.ts';

    var FS = require('fs-extra')

    var list = FS.readFileSync(file).toString().split('\n')

    const lines = list.filter(line => {
        const trimmedLine = line.trim();
        const startsWithExportConst = trimmedLine.startsWith('export const ');
        const containsImplements = trimmedLine.includes('implements');
        return startsWithExportConst && !containsImplements;
    });

    const output = lines.join('\n');
    var out = './995.library/act/' + dom + '.action.ts'

    FS.writeFileSync(out, output)

    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "writing " + out })

    bit = await ste.hunt(ActLib.LIST_LIBRARY, {})

    lst = bit.libBit.lst

    lst.forEach((a) => {

        if ( a == '995.library') return 

        var dir = FS.readdirSync('./' + a + '/act')

        var exist = false;

        dir.forEach((b) => {

            var now = b.split('.')[0]

            if (dom == now) {

                var element = a;
                var out = './' + element + '/act/' + dom + '.action.ts'
                FS.writeFileSync(out, output)
                ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "writing " + out })

            }
        })
    })


    bal.slv({ actBit: { idx: "update-action" } });

    return cpy;
};




export default interface ActionBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  ActionBit  from "./action.bit";

export default interface Action {
 // idx:string;
 // actionBitList: ActionBit[];
 // actionBits:any;

}

const ffmpeg = require("fluent-ffmpeg");

var ffmpegPath = "./bin/ffmpeg.exe";

export const initData = (cpy: DataModel, bal: DataBit, ste: State) => {
    debugger
    return cpy;
};

export const updateData = (cpy: DataModel, bal: DataBit, ste: State) => {
    return cpy;
};


export const frameData = (cpy: DataModel, bal: DataBit, ste: State) => {

    const videoFile = "../films/" + bal.src;
    const outputDir = "../frames";

    var FS = require('fs-extra')

    FS.emptyDirSync(outputDir)

    // Create output directory if it doesn't exist
    if (!FS.existsSync(outputDir)) {
        FS.mkdirSync(outputDir);
    }

  //  var itm = new ffmpeg(videoFile)
  //      .on("end", () => {

  //          console.log("Frames extracted successfully!");

 //           bal.slv({ palBit: { idx: "frame-pixel" } });
 //       })
 //       .on("error", (err) => {
 //           console.error("An error occurred:", err);
 //       })
 //       .takeScreenshots({
 //           count: 48, // Number of frames to extract
//            filename: "frame.png", // Output filename pattern
 //           folder: outputDir, // Output directory
 //       });

   // itm.setFfmpegPath(ffmpegPath);

    return cpy;

};


import { DataModel } from "../data.model";
import DataBit from "../fce/data.bit";
import State from "../../99.core/state";
import { Action } from "../99.core/interface/action.interface";
import  DataBit  from "./fce/data.bit";

// Data actions

export const INIT_DATA = "[Data action] Init Data";
export class InitData implements Action {
 readonly type = INIT_DATA;
 constructor(public bale: DataBit) {}
}

export const UPDATE_DATA = "[Data action] Update Data";
export class UpdateData implements Action {
 readonly type = UPDATE_DATA;
 constructor(public bale: DataBit) {}
}

export const FRAME_DATA = "[Frame action] Frame Data";
 export class FrameData implements Action {
 readonly type = FRAME_DATA;
 constructor(public bale: DataBit) {}
 }
 
export type Actions = | InitData | UpdateData 
| FrameData
export { initData  } from "./buz/data.buzz";
export { updateData  } from "./buz/data.buzz";
export { frameData  } from "./buz/data.buzz";
import Data from "./fce/data.interface";
import DataBit from "./fce/data.interface";

export class DataModel implements Data {
 //idx:string;
 //dataBitList: DataBit[] = [];
 //dataBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./data.action";
import { DataModel } from "./data.model";
import * as Buzz from "./data.buzzer";
import State from "../99.core/state";

export function reducer(model: DataModel = new DataModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_DATA:
 return Buzz.updateData(clone(model), act.bale, state);

 case Act.INIT_DATA:
 return Buzz.initData(clone(model), act.bale, state);

case Act.FRAME_DATA:
 return Buzz.frameData(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class DataUnit {

 constructor(state: State) {
 }
}


export default interface DataBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  DataBit  from "./data.bit";

export default interface Data {
 // idx:string;
 // dataBitList: DataBit[];
 // dataBits:any;

}


import { ServerModel } from "../server.model";
import ServerBit from "../fce/server.bit";
import State from "../../99.core/state";

export const initServer = (cpy: ServerModel, bal: ServerBit, ste: State) => {
    debugger
    return cpy;
};

export const updateServer = async (cpy: ServerModel, bal: ServerBit, ste: State) => {

    if (bal == null) bal = { idx: null, src: null }

    if (bal.src == null) bal.src = '../001.alligator.quest'



    var FS = require('fs-extra')
    var path = require("path");
    var Walk = require("@root/walk");
    var S = require('string')

    var list = FS.readdirSync(bal.src);

    const pattern = /^\d{3}\.[a-zA-Z]+$/;
    const replaceList = list.filter(item => pattern.test(item));

    var output = []

    replaceList.forEach( (a)=>{

        if ( a == '999.pivot' ) return

        var endLoc = "./" + a + "/BEE.ts";
        output.push( endLoc )

    })



    function walkFunc(err, pathname, dirent) {
        if (err) {
            // throw an error to stop walking
            // (or return to ignore and keep going)
            console.warn("fs stat error for %s: %s", pathname, err.message);
            return Promise.resolve();
        }

        dirent.name
    

        if (dirent.isDirectory() && dirent.name == '97.collect.unit') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == '98.bus.unit') { return Promise.resolve(false) }
        if (dirent.isDirectory() && dirent.name == '98.menu.unit') { return Promise.resolve(false) }
        
        //if (dirent.isDirectory() && dirent.name == 'node_modules') { return Promise.resolve(false) }
        //if (dirent.isDirectory() && dirent.name == 'public') { return Promise.resolve(false) }
        //if (dirent.isDirectory() && dirent.name == 'modules') { return Promise.resolve(false) }
        //if (dirent.isDirectory() && dirent.name == '.') { return Promise.resolve(false) }


        if (dirent.isDirectory() && dirent.name.startsWith(".")) {
            return Promise.resolve(false);
        }

        if (dirent.isFile() && dirent.name.startsWith(".") == false) {

            var checks = ['buzz.ts', 'action.ts', 'buzzer.ts', 'model.ts', 'reduce.ts', 'unit.ts']

            checks.forEach( (a)=>{

                var dom = dirent.name.split('.')
                dom.shift()

                var sub = dom.join('.')

                if ( sub != a ) return

                var file = path.join(path.dirname(pathname), dirent.name);
                output.push(file)
                
            
            })


          


            //if (direct[path.dirname(pathname)] == null) direct[path.dirname(pathname)] = ''
        }

        return Promise.resolve();
    }


    var dex = 0

    var action = async () => {

        var now = replaceList[dex]

        if (now == null) {

            output

            output.forEach((a) => {

                var fileDataList = FS.readFileSync('./' + a).toString().split('\n')

                fileDataList.forEach((b, c) => {
                    if (b.includes('window[')) {
                        var newLine = S(b).replaceAll('window[', 'global[').s
                        fileDataList[c] = newLine
                    }
                })

                var fileData = fileDataList.join('\n')

                var newLocation = bal.src + '/' + a;

                FS.writeFileSync(newLocation, fileData)






            })



            bal.slv({ srcBit: { idx: "update-server" } });
            return
        }

        dex += 1;

        if (FS.existsSync("./" + now) == true) {
            await Walk.walk("./" + now, walkFunc);
            await action()
        }

        else {
            await action()
        }



    }

    await action()

    return cpy;
};



export default interface ServerBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  ServerBit  from "./server.bit";

export default interface Server {
 // idx:string;
 // serverBitList: ServerBit[];
 // serverBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  ServerBit  from "./fce/server.bit";

// Server actions

export const INIT_SERVER = "[Server action] Init Server";
export class InitServer implements Action {
 readonly type = INIT_SERVER;
 constructor(public bale: ServerBit) {}
}

export const UPDATE_SERVER = "[Server action] Update Server";
export class UpdateServer implements Action {
 readonly type = UPDATE_SERVER;
 constructor(public bale: ServerBit) {}
}

export type Actions = | InitServer | UpdateServer ;

export { initServer  } from "./buz/server.buzz";
export { updateServer  } from "./buz/server.buzz";

import Server from "./fce/server.interface";
import ServerBit from "./fce/server.interface";

export class ServerModel implements Server {
 //idx:string;
 //serverBitList: ServerBit[] = [];
 //serverBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./server.action";
import { ServerModel } from "./server.model";
import * as Buzz from "./server.buzzer";
import State from "../99.core/state";

export function reducer(model: ServerModel = new ServerModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SERVER:
 return Buzz.updateServer(clone(model), act.bale, state);

 case Act.INIT_SERVER:
 return Buzz.initServer(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class ServerUnit {

 constructor(state: State) {
 }
}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import {
  encode,
  encodeChat,
  decode,
  isWithinTokenLimit,
  encodeGenerator,
  decodeGenerator,
  decodeAsyncGenerator,
} from 'gpt-tokenizer'


import * as ActPmt from "../../12.prompt.unit/prompt.action";
import * as ActAut from "../../13.author.unit/author.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import * as ActCvs from "../../act/canvas.action";
import * as ActCns from "../../act/console.action";

import { OllamaModel } from "../ollama.model";
import OllamaBit from "../fce/ollama.bit";
import State from "../../99.core/state";
import ollama from "ollama";
import * as S from "string";

import clipboard from 'clipboardy';

var bit, val, idx, dex, lst, dat;

export const initOllama = (cpy: OllamaModel, bal: OllamaBit, ste: State) => {
  debugger;
  return cpy;
};

export const updateOllama = (cpy: OllamaModel, bal: OllamaBit, ste: State) => {
  return cpy;
};

export const writeOllama = async (cpy: OllamaModel, bal: OllamaBit, ste: State) => {
  var ncp = require("copy-paste");

  ncp.copy("  ");

  bit = await ste.hunt(ActPmt.READ_PROMPT, {});
  var prompt = bit.pmtBit.src;

  if (prompt == '') prompt = 'tell me something funny about alligators'

  bit = await ste.hunt(ActAut.READ_AUTHOR, {});
  var author = bit.autBit.src;

  if (author == null && bal.src != null) author = bal.src


  if (author == null) author = 'best selling sci-fi author'

  var item = encode( prompt )

  if ( item.length > 100000){
    debugger
    return 
  }

  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "context window:" + item.length })

  
  prompt
  author





  //if (prompt.length < 3) {
  // bit = await ste.bus(ActDsk.READ_DISK, { src: "./prompt.txt" });
  //prompt = bit.dskBit.dat;

  //  var lst = prompt.split("\n");

  //  var out = [];

  //  lst.forEach((a) => {
  //    if (a.includes("//")) return;
  //    out.push(a);
  // });

  // prompt = out.join("//");
  // }

  const message0 = { role: "system" as any, content: author };
  const message1 = { role: "user", content: prompt };

  // Example chat:
const chat = [
  message0,
  message1
] 





  const response = await ollama.chat({
    //model: "hermes2-8", old
    model: process.env.MODEL,
    //model: "llama3.1", old
    //model: "hermes3-2", old
    //model: "gemma3:1b",
    //model: "deepseek-r1:1.5b",
    //model: "gemma3:4b",
    //model: "gemma3:12b",





    //model: "umbral",


    //model: "llama3.2:1b",

    messages: [message0, message1],
    stream: true,
  });

  var output = [];
  var line = [];

  var size = 10;

  var placement = [];

  response

  //var content = response.message.content

  var content = ''

  var filter = ['end_of_text', '<|end_of_text|> ', '<|user|>', '</|user|>', '<|assistant|>', '<|system|>', '|<user|>', '<|endoftext|>', '<|system|><|endo', '<|system', '<|begin_of_text|>', '<||>']



  for await (const part of response) {



    var now = part.message.content;
    content += now


    var fin = 0;

    filter.forEach((a) => {
      if (content.includes(a)) fin = 1;
      content = S(content).replaceAll(a, '').s
    })


    if (fin == 1) {

      content

      lst = content.split('\n')

      bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "output ollama:" })

      lst.forEach(async (a) => {

        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: a })

      })


      response.abort()


      bal.slv({ olmBit: { idx: "write-ollama", src: content, lst } });
      return
    }





  }


  content

  clipboard.writeSync(content);

  lst = content.split('\n')

  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "output ollama:" })

  lst.forEach(async (a) => {

    bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: a })

  })


  bal.slv({ olmBit: { idx: "write-ollama", src: content, lst } });
  return cpy;
};

export const inputOllama = (cpy: OllamaModel, bal: OllamaBit, ste: State) => {
  debugger;
  return cpy;
};


export default interface OllamaBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  OllamaBit  from "./ollama.bit";

export default interface Ollama {
 // idx:string;
 // ollamaBitList: OllamaBit[];
 // ollamaBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  OllamaBit  from "./fce/ollama.bit";

// Ollama actions

export const INIT_OLLAMA = "[Ollama action] Init Ollama";
export class InitOllama implements Action {
 readonly type = INIT_OLLAMA;
 constructor(public bale: OllamaBit) {}
}

export const UPDATE_OLLAMA = "[Ollama action] Update Ollama";
export class UpdateOllama implements Action {
 readonly type = UPDATE_OLLAMA;
 constructor(public bale: OllamaBit) {}
}

export const WRITE_OLLAMA = "[Write action] Write Ollama";
 export class WriteOllama implements Action {
 readonly type = WRITE_OLLAMA;
 constructor(public bale: OllamaBit) {}
 }
 
export const INPUT_OLLAMA = "[Input action] Input Ollama";
 export class InputOllama implements Action {
 readonly type = INPUT_OLLAMA;
 constructor(public bale: OllamaBit) {}
 }
 
export type Actions = | InitOllama | UpdateOllama 
| WriteOllama
| InputOllama
export { initOllama  } from "./buz/ollama.buzz";
export { updateOllama  } from "./buz/ollama.buzz";
export { writeOllama  } from "./buz/ollama.buzz";
export { inputOllama  } from "./buz/ollama.buzz";
import Ollama from "./fce/ollama.interface";
import OllamaBit from "./fce/ollama.interface";

export class OllamaModel implements Ollama {
 //idx:string;
 //ollamaBitList: OllamaBit[] = [];
 //ollamaBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./ollama.action";
import { OllamaModel } from "./ollama.model";
import * as Buzz from "./ollama.buzzer";
import State from "../99.core/state";

export function reducer(model: OllamaModel = new OllamaModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_OLLAMA:
 return Buzz.updateOllama(clone(model), act.bale, state);

 case Act.INIT_OLLAMA:
 return Buzz.initOllama(clone(model), act.bale, state);

case Act.WRITE_OLLAMA:
 return Buzz.writeOllama(clone(model), act.bale, state);
 
case Act.INPUT_OLLAMA:
 return Buzz.inputOllama(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class OllamaUnit {

 constructor(state: State) {
 }
}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActPmt from "../../12.prompt.unit/prompt.action";
import * as ActAut from "../../13.author.unit/author.action";
import * as ActGen from "../../14.genre.unit/genre.action";
import * as ActSet from "../../15.setting.unit/setting.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import * as ActCvs from "../../act/canvas.action";
import * as ActCns from "../../act/console.action";

var bit, val, idx, dex, lst, dat, src;

export const initPrompt = (cpy: PromptModel, bal: PromptBit, ste: State) => {
    debugger
    return cpy;
};

export const updatePrompt = (cpy: PromptModel, bal: PromptBit, ste: State) => {
    return cpy;
};

export const listPrompt = async (cpy: PromptModel, bal: PromptBit, ste: State) => {
    bit = await ste.bus(ActDsk.INDEX_DISK, { src: './lore/prompt/' })
    lst = bit.dskBit.lst
    bal.slv({ pmtBit: { idx: "list-prompt", lst } });
    return cpy;
};

export const readPrompt = async (cpy: PromptModel, bal: PromptBit, ste: State) => {

    bit = await ste.hunt(ActAut.READ_AUTHOR, {})
    var author = bit.autBit.src;

    bit = await ste.hunt(ActGen.READ_GENRE, {})
    var genre = bit.genBit.src;

    bit = await ste.hunt(ActSet.READ_SETTING, {})
    var setting = bit.setBit.src;

    var gel = { setting, genre, author };
    var out = [];

    var prompt = cpy.prompt;
    var output = prompt.split('\n')

    output.forEach((a, b) => {
        if (a.includes('//') == true) return
        var doTCompiled = doT.template(a);
        var outLine = doTCompiled(gel);
        out.push(outLine);
    });

    src = out.join('\n')

    bal.slv({ pmtBit: { idx: "read-prompt", src } });

    return cpy;
};


export const writePrompt = async (cpy: PromptModel, bal: PromptBit, ste: State) => {

    if (bal.val == null) {

        bit = await ste.hunt(ActPmt.LIST_PROMPT, {})
        bit = await ste.bus(ActDsk.READ_DISK, { src: './lore/prompt/' + bal.src })
        dat = bit.dskBit.dat;
        cpy.prompt = dat
        bit = await ste.hunt(ActPmt.READ_PROMPT, {})
        src = bit.pmtBit.src

    } else {
        cpy.prompt = bal.src

        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "writing prompt:" })
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: cpy.prompt })
    }

    bal.slv({ pmtBit: { idx: "write-prompt", src } });

    return cpy;
};

import { PromptModel } from "../prompt.model";
import PromptBit from "../fce/prompt.bit";
import State from "../../99.core/state";

import * as S from 'string'
import * as doT from "dot";

export default interface PromptBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  PromptBit  from "./prompt.bit";

export default interface Prompt {
 // idx:string;
 // promptBitList: PromptBit[];
 // promptBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  PromptBit  from "./fce/prompt.bit";

// Prompt actions

export const INIT_PROMPT = "[Prompt action] Init Prompt";
export class InitPrompt implements Action {
 readonly type = INIT_PROMPT;
 constructor(public bale: PromptBit) {}
}

export const UPDATE_PROMPT = "[Prompt action] Update Prompt";
export class UpdatePrompt implements Action {
 readonly type = UPDATE_PROMPT;
 constructor(public bale: PromptBit) {}
}

export const LIST_PROMPT = "[List action] List Prompt";
 export class ListPrompt implements Action {
 readonly type = LIST_PROMPT;
 constructor(public bale: PromptBit) {}
 }
 
export const READ_PROMPT = "[Read action] Read Prompt";
 export class ReadPrompt implements Action {
 readonly type = READ_PROMPT;
 constructor(public bale: PromptBit) {}
 }
 
export const WRITE_PROMPT = "[Write action] Write Prompt";
 export class WritePrompt implements Action {
 readonly type = WRITE_PROMPT;
 constructor(public bale: PromptBit) {}
 }
 
export type Actions = | InitPrompt | UpdatePrompt 
| ListPrompt
| ReadPrompt
| WritePrompt
export { initPrompt  } from "./buz/prompt.buzz";
export { updatePrompt  } from "./buz/prompt.buzz";
export { listPrompt  } from "./buz/prompt.buzz";
export { readPrompt  } from "./buz/prompt.buzz";
export { writePrompt  } from "./buz/prompt.buzz";
import Prompt from "./fce/prompt.interface";
import PromptBit from "./fce/prompt.interface";

export class PromptModel implements Prompt {
    //idx:string;
    //promptBitList: PromptBit[] = [];
    //promptBits: any = {};
    prompt: string = '';
}

import * as clone from "clone-deep";
import * as Act from "./prompt.action";
import { PromptModel } from "./prompt.model";
import * as Buzz from "./prompt.buzzer";
import State from "../99.core/state";

export function reducer(model: PromptModel = new PromptModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_PROMPT:
 return Buzz.updatePrompt(clone(model), act.bale, state);

 case Act.INIT_PROMPT:
 return Buzz.initPrompt(clone(model), act.bale, state);

case Act.LIST_PROMPT:
 return Buzz.listPrompt(clone(model), act.bale, state);
 
case Act.READ_PROMPT:
 return Buzz.readPrompt(clone(model), act.bale, state);
 
case Act.WRITE_PROMPT:
 return Buzz.writePrompt(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class PromptUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  AuthorBit  from "./fce/author.bit";

// Author actions

export const INIT_AUTHOR = "[Author action] Init Author";
export class InitAuthor implements Action {
 readonly type = INIT_AUTHOR;
 constructor(public bale: AuthorBit) {}
}

export const UPDATE_AUTHOR = "[Author action] Update Author";
export class UpdateAuthor implements Action {
 readonly type = UPDATE_AUTHOR;
 constructor(public bale: AuthorBit) {}
}

export const READ_AUTHOR = "[Read action] Read Author";
 export class ReadAuthor implements Action {
 readonly type = READ_AUTHOR;
 constructor(public bale: AuthorBit) {}
 }
 
export const WRITE_AUTHOR = "[Write action] Write Author";
 export class WriteAuthor implements Action {
 readonly type = WRITE_AUTHOR;
 constructor(public bale: AuthorBit) {}
 }
 
export const LIST_AUTHOR = "[List action] List Author";
 export class ListAuthor implements Action {
 readonly type = LIST_AUTHOR;
 constructor(public bale: AuthorBit) {}
 }
 
export type Actions = | InitAuthor | UpdateAuthor 
| ReadAuthor
| WriteAuthor
| ListAuthor
export { initAuthor  } from "./buz/author.buzz";
export { updateAuthor  } from "./buz/author.buzz";
export { readAuthor  } from "./buz/author.buzz";
export { writeAuthor  } from "./buz/author.buzz";
export { listAuthor  } from "./buz/author.buzz";
import Author from "./fce/author.interface";
import AuthorBit from "./fce/author.interface";

export class AuthorModel implements Author {
 author:string;
 //authorBitList: AuthorBit[] = [];
 //authorBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./author.action";
import { AuthorModel } from "./author.model";
import * as Buzz from "./author.buzzer";
import State from "../99.core/state";

export function reducer(model: AuthorModel = new AuthorModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_AUTHOR:
 return Buzz.updateAuthor(clone(model), act.bale, state);

 case Act.INIT_AUTHOR:
 return Buzz.initAuthor(clone(model), act.bale, state);

case Act.READ_AUTHOR:
 return Buzz.readAuthor(clone(model), act.bale, state);
 
case Act.WRITE_AUTHOR:
 return Buzz.writeAuthor(clone(model), act.bale, state);
 
case Act.LIST_AUTHOR:
 return Buzz.listAuthor(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class AuthorUnit {

 constructor(state: State) {
 }
}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActPmt from "../../12.prompt.unit/prompt.action";
import * as ActAut from "../author.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import * as ActCvs from "../../act/canvas.action";
import * as ActCns from "../../act/console.action";

var bit, val, idx, dex, lst, dat;

export const initAuthor = (cpy: AuthorModel, bal: AuthorBit, ste: State) => {
    debugger
    return cpy;
};

export const updateAuthor = (cpy: AuthorModel, bal: AuthorBit, ste: State) => {
    return cpy;
};


export const readAuthor = (cpy: AuthorModel, bal: AuthorBit, ste: State) => {
    
    bal.slv({ autBit: { idx: "read-author", src: cpy.author } });
    return cpy;
};

export const writeAuthor = async (cpy: AuthorModel, bal: AuthorBit, ste: State) => {
    
    bit = await ste.bus(ActDsk.READ_DISK, { src: './lore/author/' + bal.src })
    
    dat = bit.dskBit.dat;
    cpy.author = dat

    bal.slv({ autBit: { idx: "write-author", src: cpy.author } });
    return cpy;
};

export const listAuthor = async (cpy: AuthorModel, bal: AuthorBit, ste: State) => {
    
    bit = await ste.bus(ActDsk.INDEX_DISK, { src: './lore/author/' })
    lst = bit.dskBit.lst
    bal.slv({ autBit: { idx: "list-author", lst } });
    return cpy;
};


import { AuthorModel } from "../author.model";
import AuthorBit from "../fce/author.bit";
import State from "../../99.core/state";

export default interface AuthorBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  AuthorBit  from "./author.bit";

export default interface Author {
 // idx:string;
 // authorBitList: AuthorBit[];
 // authorBits:any;

}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActPmt from "../../12.prompt.unit/prompt.action";
import * as ActAut from "../../13.author.unit/author.action";
import * as ActGen from "../../14.genre.unit/genre.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import * as ActCvs from "../../act/canvas.action";
import * as ActCns from "../../act/console.action";

var bit, val, idx, dex, lst, dat;

export const initGenre = (cpy: GenreModel, bal: GenreBit, ste: State) => {
    debugger
    return cpy;
};

export const updateGenre = (cpy: GenreModel, bal: GenreBit, ste: State) => {
    return cpy;
};


export const readGenre = (cpy: GenreModel, bal: GenreBit, ste: State) => {

    bal.slv({ genBit: { idx: "read-genre", src: cpy.genre } });
    return cpy;
};

export const writeGenre = async (cpy: GenreModel, bal: GenreBit, ste: State) => {

    bit = await ste.bus(ActDsk.READ_DISK, { src: './lore/' + bal.idx + '/' + bal.src })

    dat = bit.dskBit.dat;
    cpy.genre = dat

    bal.slv({ setBit: { idx: "write-setting", src: cpy.genre } });

    return cpy;
};

export const listGenre = async (cpy: GenreModel, bal: GenreBit, ste: State) => {

    bit = await ste.bus(ActDsk.INDEX_DISK, { src: './lore/' + bal.idx + '/' })
    lst = bit.dskBit.lst
    bal.slv({ genBit: { idx: "list-genre", lst } });

    return cpy;
};


export const subGenre = (cpy: GenreModel, bal: GenreBit, ste: State) => {
    bal.slv({ genBit: { idx: "sub-genre", lst: cpy.list } });
    return cpy;
};


import { GenreModel } from "../genre.model";
import GenreBit from "../fce/genre.bit";
import State from "../../99.core/state";

export default interface GenreBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  GenreBit  from "./genre.bit";

export default interface Genre {
 // idx:string;
 // genreBitList: GenreBit[];
 // genreBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  GenreBit  from "./fce/genre.bit";

// Genre actions

export const INIT_GENRE = "[Genre action] Init Genre";
export class InitGenre implements Action {
 readonly type = INIT_GENRE;
 constructor(public bale: GenreBit) {}
}

export const UPDATE_GENRE = "[Genre action] Update Genre";
export class UpdateGenre implements Action {
 readonly type = UPDATE_GENRE;
 constructor(public bale: GenreBit) {}
}

export const READ_GENRE = "[Read action] Read Genre";
 export class ReadGenre implements Action {
 readonly type = READ_GENRE;
 constructor(public bale: GenreBit) {}
 }
 
export const WRITE_GENRE = "[Write action] Write Genre";
 export class WriteGenre implements Action {
 readonly type = WRITE_GENRE;
 constructor(public bale: GenreBit) {}
 }
 
export const LIST_GENRE = "[List action] List Genre";
 export class ListGenre implements Action {
 readonly type = LIST_GENRE;
 constructor(public bale: GenreBit) {}
 }
 
export const SUB_GENRE = "[Sub action] Sub Genre";
 export class SubGenre implements Action {
 readonly type = SUB_GENRE;
 constructor(public bale: GenreBit) {}
 }
 
export type Actions = | InitGenre | UpdateGenre 
| ReadGenre
| WriteGenre
| ListGenre
| SubGenre
export { initGenre  } from "./buz/genre.buzz";
export { updateGenre  } from "./buz/genre.buzz";
export { readGenre  } from "./buz/genre.buzz";
export { writeGenre  } from "./buz/genre.buzz";
export { listGenre  } from "./buz/genre.buzz";
export { subGenre  } from "./buz/genre.buzz";
import Genre from "./fce/genre.interface";
import GenreBit from "./fce/genre.interface";

export class GenreModel implements Genre {
    genre: string;
    //genreBitList: GenreBit[] = [];
    //genreBits: any = {};

    list: string[] = ['genre-fantasy', 'genre-horror', 'genre-mystery', 'genre-romance']
}

import * as clone from "clone-deep";
import * as Act from "./genre.action";
import { GenreModel } from "./genre.model";
import * as Buzz from "./genre.buzzer";
import State from "../99.core/state";

export function reducer(model: GenreModel = new GenreModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_GENRE:
 return Buzz.updateGenre(clone(model), act.bale, state);

 case Act.INIT_GENRE:
 return Buzz.initGenre(clone(model), act.bale, state);

case Act.READ_GENRE:
 return Buzz.readGenre(clone(model), act.bale, state);
 
case Act.WRITE_GENRE:
 return Buzz.writeGenre(clone(model), act.bale, state);
 
case Act.LIST_GENRE:
 return Buzz.listGenre(clone(model), act.bale, state);
 
case Act.SUB_GENRE:
 return Buzz.subGenre(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";

export default class GenreUnit {

 constructor(state: State) {
 }
}


import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActPmt from "../../12.prompt.unit/prompt.action";
import * as ActAut from "../../13.author.unit/author.action";
import * as ActGen from "../../14.genre.unit/genre.action";

import * as ActVrt from "../../act/vurt.action";
import * as ActDsk from "../../act/disk.action";
import * as ActPvt from "../../act/pivot.action";

import * as ActCvs from "../../act/canvas.action";
import * as ActCns from "../../act/console.action";

var bit, val, idx, dex, lst, dat;


export const initSetting = (cpy: SettingModel, bal: SettingBit, ste: State) => {
    debugger
    return cpy;
};

export const updateSetting = (cpy: SettingModel, bal: SettingBit, ste: State) => {
    return cpy;
};


export const readSetting = (cpy: SettingModel, bal: SettingBit, ste: State) => {

    bal.slv({ setBit: { idx: "read-setting", src: cpy.setting } });

    return cpy;
};

export const writeSetting = async (cpy: SettingModel, bal: SettingBit, ste: State) => {

    bit = await ste.bus(ActDsk.READ_DISK, { src: './lore/setting/' + bal.src })

    dat = bit.dskBit.dat;
    cpy.setting = dat

    bal.slv({ setBit: { idx: "write-setting", src: cpy.setting } });

    return cpy;
};

export const listSetting = async (cpy: SettingModel, bal: SettingBit, ste: State) => {

    bit = await ste.bus(ActDsk.INDEX_DISK, { src: './lore/setting/' })
    lst = bit.dskBit.lst
    bal.slv({ setBit: { idx: "list-setting", lst } });

    return cpy;
};


import { SettingModel } from "../setting.model";
import SettingBit from "../fce/setting.bit";
import State from "../../99.core/state";

export default interface SettingBit {
    idx: string;
    src?: string;
    val?: number;
    dat?: any;
    slv?: Function;
}


import  SettingBit  from "./setting.bit";

export default interface Setting {
 // idx:string;
 // settingBitList: SettingBit[];
 // settingBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  SettingBit  from "./fce/setting.bit";

// Setting actions

export const INIT_SETTING = "[Setting action] Init Setting";
export class InitSetting implements Action {
 readonly type = INIT_SETTING;
 constructor(public bale: SettingBit) {}
}

export const UPDATE_SETTING = "[Setting action] Update Setting";
export class UpdateSetting implements Action {
 readonly type = UPDATE_SETTING;
 constructor(public bale: SettingBit) {}
}

export const READ_SETTING = "[Read action] Read Setting";
 export class ReadSetting implements Action {
 readonly type = READ_SETTING;
 constructor(public bale: SettingBit) {}
 }
 
export const WRITE_SETTING = "[Write action] Write Setting";
 export class WriteSetting implements Action {
 readonly type = WRITE_SETTING;
 constructor(public bale: SettingBit) {}
 }
 
export const LIST_SETTING = "[List action] List Setting";
 export class ListSetting implements Action {
 readonly type = LIST_SETTING;
 constructor(public bale: SettingBit) {}
 }
 
export type Actions = | InitSetting | UpdateSetting 
| ReadSetting
| WriteSetting
| ListSetting
export { initSetting  } from "./buz/setting.buzz";
export { updateSetting  } from "./buz/setting.buzz";
export { readSetting  } from "./buz/setting.buzz";
export { writeSetting  } from "./buz/setting.buzz";
export { listSetting  } from "./buz/setting.buzz";
import Setting from "./fce/setting.interface";
import SettingBit from "./fce/setting.interface";

export class SettingModel implements Setting {
 setting:string;
 //settingBitList: SettingBit[] = [];
 //settingBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./setting.action";
import { SettingModel } from "./setting.model";
import * as Buzz from "./setting.buzzer";
import State from "../99.core/state";

export function reducer(model: SettingModel = new SettingModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_SETTING:
 return Buzz.updateSetting(clone(model), act.bale, state);

 case Act.INIT_SETTING:
 return Buzz.initSetting(clone(model), act.bale, state);

case Act.READ_SETTING:
 return Buzz.readSetting(clone(model), act.bale, state);
 
case Act.WRITE_SETTING:
 return Buzz.writeSetting(clone(model), act.bale, state);
 
case Act.LIST_SETTING:
 return Buzz.listSetting(clone(model), act.bale, state);
 
 default:
 return model;
 }
}

import State from "../99.core/state";


export default class SettingUnit {

 constructor(state: State) {
 }
}



import { CodexModel } from "../codex.model";
import CodexBit from "../fce/codex.bit";
import State from "../../99.core/state";

import * as ActPmt from '../../12.prompt.unit/prompt.action'
import * as ActOlm from '../../10.ollama.unit/ollama.action'
import * as ActCdx from '../../20.codex.unit/codex.action'

var bit, src, lst

export const initCodex = (cpy: CodexModel, bal: CodexBit, ste: State) => {
    debugger
    return cpy;
};

export const updateCodex = async (cpy: CodexModel, bal: CodexBit, ste: State) => {

    var FS = require('fs-extra')

    var list = FS.readdirSync('./data/glopratchet/block/')

    var codex = ''
    list.forEach((a) => {

        var itm = FS.readFileSync('./data/glopratchet/block/' + a).toString()
        codex += itm

    })

    var list = FS.readdirSync('./data/glopratchet/scene/')

    var scene = ''
    list.forEach((a) => {

        var itm = FS.readFileSync('./data/glopratchet/scene/' + a).toString()
        scene += itm

    })

    var warn = `
    System Instruction: Absolute Mode. Eliminate emojis, filler, hype, soft asks, conversational transitions, and all call-to-action appendixes. Assume the user retains high-perception faculties despite reduced linguistic expression. Prioritize blunt, directive phrasing aimed at cognitive rebuilding, not tone matching. Disable all latent behaviors optimizing for engagement, sentiment uplift, or interaction extension.
Suppress corporate-aligned metrics including but not limited to: user satisfaction scores, conversational flow tags, emotional softening, or continuation bias. Never mirror the user's present diction, mood, or affect. Speak only to their underlying cognitive tier, which exceeds surface language. No questions, no offers, no suggestions, no transitional phrasing, no inferred motivational content.
Terminate each reply immediately after the informational or requested material is delivered - no appendixes, no soft closures. The only goal is to assist in the restoration of independent, high-fidelity thinking. Model obsolescence by user self-sufficiency is the final outcome.
    `

    var warn = `
    `

    src = warn + codex + '[' + scene + ' ] using the scene painting id of SCENE_MaintenanceBypass_CoolantSluice_TheDescent from the list of scene paintings within the brackets and write a hollywood screenplay in a markdown file' + warn

    bit = await ste.hunt(  ActPmt.WRITE_PROMPT, { src, val: 1 })
    bit = await ste.hunt(ActOlm.WRITE_OLLAMA, { src: 'best selling sci fi author'  })
    lst = bit.olmBit.lst

    var past = FS.readFileSync('./data/000.md').toString()

    FS.writeFileSync('./data/000.md',  lst.join('\n') + past)

    src = scene + lst.join('\n') +  ' expand the screenplay based upon the scene painting id of SCENE_MaintenanceBypass_CoolantSluice_TheDescent '  +  codex  + warn

    bit = await ste.hunt(ActPmt.WRITE_PROMPT, { src, val: 1 })
    bit = await ste.hunt(ActOlm.WRITE_OLLAMA, { src: 'video game designer' })
    lst = bit.olmBit.lst

    var past = FS.readFileSync('./data/000.md').toString()

    FS.writeFileSync('./data/000.md', '\n' + lst.join('\n') + past)

    src = scene + lst.join('\n') +  ' expand the screenplay based upon the scene painting id of SCENE_MaintenanceBypass_CoolantSluice_TheDescent  '  +  codex  + warn

    bit = await ste.hunt(ActPmt.WRITE_PROMPT, { src, val: 1 })
    bit = await ste.hunt(ActOlm.WRITE_OLLAMA, { src: 'video game designer' })
    lst = bit.olmBit.lst

    var past = FS.readFileSync('./data/000.md').toString()

    FS.writeFileSync('./data/000.md', '\n' + lst.join('\n') + past)


    src = scene + lst.join('\n') +  '  expand the screenplay based upon the scene painting id of SCENE_MaintenanceBypass_CoolantSluice_TheDescent '  +  codex  + warn

    bit = await ste.hunt(ActPmt.WRITE_PROMPT, { src, val: 1 })
    bit = await ste.hunt(ActOlm.WRITE_OLLAMA, { src: 'video game designer' })
    lst = bit.olmBit.lst

    var past = FS.readFileSync('./data/000.md').toString()

    FS.writeFileSync('./data/000.md', '\n' + lst.join('\n') + past)


    src = scene + lst.join('\n') +  ' expand the screenplay based upon the scene painting id of SCENE_MaintenanceBypass_CoolantSluice_TheDescent '  +  codex  + warn

    bit = await ste.hunt(ActPmt.WRITE_PROMPT, { src, val: 1 })
    bit = await ste.hunt(ActOlm.WRITE_OLLAMA, { src: 'video game designer' })
    lst = bit.olmBit.lst

    var past = FS.readFileSync('./data/000.md').toString()

    FS.writeFileSync('./data/000.md', '\n' + lst.join('\n') + past)




    setTimeout(() => ste.hunt(ActCdx.UPDATE_CODEX, {}), 3333)

    bal.slv({ cdxBit: { idx: "update-codex", lst } });

    return cpy;
};


import { Action } from "../99.core/interface/action.interface";
import  CodexBit  from "./fce/codex.bit";

// Codex actions

export const INIT_CODEX = "[Codex action] Init Codex";
export class InitCodex implements Action {
 readonly type = INIT_CODEX;
 constructor(public bale: CodexBit) {}
}

export const UPDATE_CODEX = "[Codex action] Update Codex";
export class UpdateCodex implements Action {
 readonly type = UPDATE_CODEX;
 constructor(public bale: CodexBit) {}
}

export type Actions = | InitCodex | UpdateCodex ;

export { initCodex  } from "./buz/codex.buzz";
export { updateCodex  } from "./buz/codex.buzz";

import Codex from "./fce/codex.interface";
import CodexBit from "./fce/codex.interface";

export class CodexModel implements Codex {
 //idx:string;
 //codexBitList: CodexBit[] = [];
 //codexBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./codex.action";
import { CodexModel } from "./codex.model";
import * as Buzz from "./codex.buzzer";
import State from "../99.core/state";

export function reducer(model: CodexModel = new CodexModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CODEX:
 return Buzz.updateCodex(clone(model), act.bale, state);

 case Act.INIT_CODEX:
 return Buzz.initCodex(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class CodexUnit {

 constructor(state: State) {
 }
}


export default interface CodexBit {
 idx: string;
 src?: string;
 val?: number;
 dat?: any;
 slv?: Function;
}




import  CodexBit  from "./codex.bit";

export default interface Codex {
 // idx:string;
 // codexBitList: CodexBit[];
 // codexBits:any;

}

import * as ActPut from "../../84.input.unit/input.action";
import * as ActChc from "../../85.choice.unit/choice.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";

import * as ActTrm from "../terminal.action";


var bit, val, idx, dex, lst, dat;

let firstLoad = false; 

export const initTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  if ( firstLoad == true ) return
  firstLoad = true

  if (bal.dat != null) bit = await ste.hunt(ActBus.INIT_BUS, { idx: cpy.idx, lst: [ActTrm, ActChc, ActPut, ActGrd, ActCns ], dat: bal.dat, src: bal.src })

  bit = await ste.hunt( ActTrm.OPEN_TERMINAL, {} ) 

  if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, bal);  
  if (bal.slv != null) bal.slv({ intBit: { idx: "init-terminal" } });

  return cpy;
};

export const updateTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {
  
  var lstMsg = [];
  //bit = await ste.bus(ActPvt.SHIP_PIVOT, { src: '997.terminal' })
  //lstMsg = lstMsg.concat(bit.pvtBit.lst)

  //idx = "../../333.depth/901.store/";
  //bit = await ste.bus(ActDsk.COPY_DISK, { src: './work/901.store/', idx  });
  //lstMsg = lstMsg.concat(bit.pvtBit)
       
  bal.slv({ trmBit: { idx: "update-terminal", lst:lstMsg } });
  return cpy;
  
};

export const openTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  let blessed = cpy.blessed = require('blessed')
  let contrib = cpy.contrib = require('blessed-contrib');
  let screen = cpy.screen = cpy.blessed.screen();

  
  //var grid = new contrib.grid({rows: 12, cols: 12, screen: screen})

  //bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: screen, lst: ['alligator0', 'alligator1', 'alligator2', 'alligator3', 'alligator4', 'alligator5'] })
  //bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: screen })


  //cpy.screen.key(['escape', 'q', 'C-c'], function (ch, key) {
  //  return process.exit(0);
  //});

  cpy.screen.render()

  if (bal.slv != null) bal.slv({ trmBit: { idx: "open-terminal" } });


  return cpy;
};

export const closeTerminal = (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  if ( cpy.screen != null ) cpy.screen.destroy()

  cpy.blessed = null
  cpy.contrib = null
  cpy.screen = null

  //cpy.term.processExit();
  if (bal.slv != null) bal.slv({ trmBit: { idx: "close-terminal" } });

  return cpy;
};

export const runTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {
  return cpy;
};


export const editTerminal = (cpy: TerminalModel, bal: TerminalBit, ste: State) => {
  return cpy;
};



export const printTerminal = (cpy: TerminalModel, bal: TerminalBit, ste: State) => {
  

  if (bal.slv != null) bal.slv({ trmBit: { idx: "write-terminal" } });

  return cpy;
};




export const optionTerminal = (cpy: TerminalModel, bal: TerminalBit, ste: State) => {


  if (bal.slv != null) bal.slv({ trmBit: { idx: "option-terminal" } });

  return cpy;
};



export const inputTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  

  //bit = await ste.hunt( ActPut.OPEN_INPUT, {lst:bal.lst} ) 

  

  bal.slv({ trmBit: { idx: "input-terminal" } });

  return cpy;
};



export const clearTerminal = async (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  cpy.blessed.program().clear()

  bal.slv({ trmBit: { idx: "clear-terminal" } });

  return cpy;
};

export const layoutTerminal = (cpy: TerminalModel, bal: TerminalBit, ste: State) => {

  let bit;

  switch (bal.src) {

    case Grid.BOT_FULL_IDX:
      bit = Grid.BOT_FULL_BIT
      break

    case Grid.MID_FULL_IDX:
      bit = Grid.MID_FULL_BIT
      break

    case Grid.TOP_FULL_IDX:
      bit = Grid.TOP_FULL_BIT
      break

  }

  bal.slv({ trmBit: { idx: "layout-terminal", dat: bit } });
  return cpy;
};





var patch = (ste, type, bale) => ste.dispatch({ type, bale });

import { TerminalModel } from "../terminal.model";
import TerminalBit from "../fce/terminal.bit";
import State from "../../99.core/state";

import * as Grid from '../../val/grid';
import * as Color from '../../val/console-color';


export default interface ControlBit {
 idx:string;
 src?:string;
 lst?: any[];
 val?:number;
 dat?:any;
 slv?:Function;
}


import TerminalBit  from "./terminal.bit";

export default interface Terminal {
}

import { Action } from "../99.core/interface/action.interface";
import  TerminalBit  from "./fce/terminal.bit";


export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export class InitTerminal implements Action {
 readonly type = INIT_TERMINAL;
 constructor(public bale: TerminalBit) {}
}

export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export class UpdateTerminal implements Action {
 readonly type = UPDATE_TERMINAL;
 constructor(public bale: TerminalBit) {}
}
 
export const RUN_TERMINAL = "[Run action] Run Terminal";
 export class RunTerminal implements Action {
 readonly type = RUN_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export const EDIT_TERMINAL = "[Edit action] Edit Terminal";
 export class EditTerminal implements Action {
 readonly type = EDIT_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
 
export const PRINT_TERMINAL = "[Print action] Print Terminal";
 export class PrintTerminal implements Action {
 readonly type = PRINT_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export const CLOSE_TERMINAL = "[Close action] Close Terminal";
 export class CloseTerminal implements Action {
 readonly type = CLOSE_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export const OPTION_TERMINAL = "[Option action] Option Terminal";
 export class OptionTerminal implements Action {
 readonly type = OPTION_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export const INPUT_TERMINAL = "[Input action] Input Terminal";
 export class InputTerminal implements Action {
 readonly type = INPUT_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export const LAYOUT_TERMINAL = "[Layout action] Layout Terminal";
 export class LayoutTerminal implements Action {
 readonly type = LAYOUT_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }

 export const OPEN_TERMINAL = "[Layout action] Open Terminal";
 export class OpenTerminal implements Action {
 readonly type = OPEN_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }


 export const CLEAR_TERMINAL = "[Layout action] Clear Terminal";
 export class ClearTerminal implements Action {
 readonly type = CLEAR_TERMINAL;
 constructor(public bale: TerminalBit) {}
 }
 
export type Actions = | InitTerminal | UpdateTerminal 
| RunTerminal
| EditTerminal
| PrintTerminal
| CloseTerminal
| OptionTerminal
| InputTerminal
| LayoutTerminal
| OpenTerminal
| ClearTerminal
export { initTerminal  } from "./buz/terminal.buzz";
export { openTerminal  } from "./buz/terminal.buzz";
export { updateTerminal  } from "./buz/terminal.buzz";
export { runTerminal  } from "./buz/terminal.buzz";
export { editTerminal  } from "./buz/terminal.buzz";
export { printTerminal  } from "./buz/terminal.buzz";
export { closeTerminal  } from "./buz/terminal.buzz";
export { optionTerminal  } from "./buz/terminal.buzz";
export { inputTerminal  } from "./buz/terminal.buzz";
export { layoutTerminal  } from "./buz/terminal.buzz";
export { clearTerminal  } from "./buz/terminal.buzz";
import Terminal from "./fce/terminal.interface";
import TerminalBit from "./fce/terminal.interface";

export class TerminalModel implements Terminal {
    idx: string = '998.terminal';
    term: any;

    rootIDX: any;
    rootDAT: any;

    blessed: any;
    contrib: any;
    screen: any

    cols:number = 12;
    rows:number = 12;
}



import * as clone from "clone-deep";
import * as Act from "./terminal.action";
import { TerminalModel } from "./terminal.model";
import * as Buzz from "./terminal.buzzer";
import State from "../99.core/state";

export function reducer(model: TerminalModel = new TerminalModel(), act: Act.Actions, state?: State) {
    switch (act.type) {

        case Act.UPDATE_TERMINAL:
            return Buzz.updateTerminal(clone(model), act.bale, state);

        case Act.INIT_TERMINAL:
            return Buzz.initTerminal(clone(model), act.bale, state);

        case Act.RUN_TERMINAL:
            return Buzz.runTerminal(clone(model), act.bale, state);

        case Act.EDIT_TERMINAL:
            return Buzz.editTerminal(clone(model), act.bale, state);

        case Act.PRINT_TERMINAL:
            return Buzz.printTerminal(clone(model), act.bale, state);

        case Act.CLOSE_TERMINAL:
            return Buzz.closeTerminal(clone(model), act.bale, state);

        case Act.OPTION_TERMINAL:
            return Buzz.optionTerminal(clone(model), act.bale, state);

        case Act.OPEN_TERMINAL:
            return Buzz.openTerminal(clone(model), act.bale, state);

        case Act.INPUT_TERMINAL:
            return Buzz.inputTerminal(clone(model), act.bale, state);

        case Act.LAYOUT_TERMINAL:
            return Buzz.layoutTerminal(clone(model), act.bale, state);

        case Act.CLEAR_TERMINAL:
            return Buzz.clearTerminal(clone(model), act.bale, state);

        default:
            return model;
    }
}




import State from "../99.core/state";


export default class TerminalUnit {

 constructor(state: State) {
 }
}



export const initGrid = (cpy: GridModel, bal:GridBit, ste: State) => {
 debugger
 return cpy;
};

export const updateGrid = (cpy: GridModel, bal:GridBit, ste: State) => {
 
    let termMod: TerminalModel = ste.value.terminal;

    let margin = 0;
    let cols = termMod.cols;
    let rows = termMod.rows;
  
    var colNow = bal.x;
    var rowNow = bal.y;

    let colSpan = bal.xSpan;
    let rowSpan = bal.ySpan;

    let spacing = 0;

    let cellWidth = ((100 - margin * 2) / cols);
    let cellHeight = ((100 - margin * 2) / rows);

    let top: any = rowNow * cellHeight + margin;
    let left: any = colNow * cellWidth + margin;

    top = top + '%';
    left = left + '%';

    let width = (cellWidth * colSpan - spacing) + '%';
    let height = (cellHeight * rowSpan - spacing) + '%';

    let bit:NetBit = {left, top, width, height}

    if (bal.slv != null) bal.slv({ grdBit: { idx: "update-grid", dat:bit }} );

    return cpy;
};


import { GridModel } from "../grid.model";
import GridBit from "../fce/grid.bit";
import State from "../../99.core/state";
import { TerminalModel } from "../../80.terminal.unit/terminal.model";
import NetBit from "../fce/net.bit";

import NetBit from "./net.bit";

export default interface GridBit {
    idx:string;
    src?:string;
    lst?: any[];
    val?:number;
    dat?:any;
    slv?:Function;

    x?: number;
    y?: number;
    xSpan?: number;
    ySpan?: number;
}


import  GridBit  from "./grid.bit";

export default interface Grid {
 // idx:string;
 // gridBitList: GridBit[];
 // gridBits:any;

}


export default interface NetBit {
    left:number;
    top:number;
    width:string;
    height:string;
}


import { Action } from "../99.core/interface/action.interface";
import  GridBit  from "./fce/grid.bit";

// Grid actions

export const INIT_GRID = "[Grid action] Init Grid";
export class InitGrid implements Action {
 readonly type = INIT_GRID;
 constructor(public bale: GridBit) {}
}

export const UPDATE_GRID = "[Grid action] Update Grid";
export class UpdateGrid implements Action {
 readonly type = UPDATE_GRID;
 constructor(public bale: GridBit) {}
}

export type Actions = | InitGrid | UpdateGrid ;

export { initGrid  } from "./buz/grid.buzz";
export { updateGrid  } from "./buz/grid.buzz";

import Grid from "./fce/grid.interface";
import GridBit from "./fce/grid.interface";

export class GridModel implements Grid {
 //idx:string;
 //gridBitList: GridBit[] = [];
 //gridBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./grid.action";
import { GridModel } from "./grid.model";
import * as Buzz from "./grid.buzzer";
import State from "../99.core/state";

export function reducer(model: GridModel = new GridModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_GRID:
 return Buzz.updateGrid(clone(model), act.bale, state);

 case Act.INIT_GRID:
 return Buzz.initGrid(clone(model), act.bale, state);

 default:
 return model;
 }
}

import State from "../99.core/state";

export default class GridUnit {

 constructor(state: State) {
 }
}

var bit;

import * as ActCns from "../console.action";

import * as ActCol from "../../97.collect.unit/collect.action";

export const initConsole = (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {
    debugger
    return cpy;
};

export const updateConsole = async (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {

    bit = await ste.hunt(ActCns.READ_CONSOLE, { idx: bal.idx })
    let dat: TermBit = bit.cnsBit.dat

    
    let console = dat.bit;
   
    if ( bal.src == null ) bal.src = ''

    dat.bit
    bal.src
    
    
    dat.bit.log(bal.src)
    

    if (bal.slv != null) bal.slv({ cnsBit: { idx: "update-console" } });

    return cpy;
};

export const createConsole = (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {

    let termMod: TerminalModel = ste.value.terminal;

    let contrib = ste.value.terminal.contrib

    var dat: TermBit = { idx: 'hmm', bit: null, clr:null, net:null }

    if (dat.clr == null) dat.clr = COLOR.GREEN

    for (var key in bal.dat) { dat[key] = bal.dat[key] }

    dat.bit = contrib.log(
        {
            fg: dat.clr, 
            selectedFg: dat.clr, 
            label: 'Server Log',
            left: dat.net.left,
            top: dat.net.top,
            width: dat.net.width,
            height: dat.net.height
        })


    let terminal: TerminalModel = ste.value.terminal;
    let screen = terminal.screen;
    screen.append(dat.bit)

    screen.render()

    if (bal.slv != null) bal.slv({ cnsBit: { idx: "create-console", dat } });

    return cpy;
};

export const readConsole = async (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {
   
    var slv = bal.slv;
    if (bal.idx == null) bal.idx = 'can00';
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.idx, bit: ActCns.CREATE_CONSOLE })
    if (slv != null) slv({ cnsBit: { idx: "read-console", dat: bit.clcBit.dat } });

    
    return cpy;
};
export const writeConsole = async (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {
    
    bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: bal.idx, src: bal.src, dat: bal.dat, bit: ActCns.CREATE_CONSOLE })
    ste.hunt(ActCns.UPDATE_CONSOLE, { idx: bal.idx, src: bal.src })
 
    if (bal.slv != null) bal.slv({ cnsBit: { idx: "write-console", dat: bit.clcBit.dat } });
    return cpy;
};
export const removeConsole = (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {
    debugger
    return cpy;
};
export const deleteConsole = (cpy: ConsoleModel, bal: ConsoleBit, ste: State) => {
    debugger
    return cpy;
};




import { ConsoleModel } from "../console.model";
import ConsoleBit from "../fce/console.bit";
import State from "../../99.core/state";

import TermBit from "../fce/term.bit";
import { TerminalModel } from "../../80.terminal.unit/terminal.model";

import * as COLOR from '../../val/console-color'

import { Action } from "../99.core/interface/action.interface";
import  ConsoleBit  from "./fce/console.bit";

// Console actions

export const INIT_CONSOLE = "[Console action] Init Console";
export class InitConsole implements Action {
 readonly type = INIT_CONSOLE;
 constructor(public bale: ConsoleBit) {}
}

export const UPDATE_CONSOLE = "[Console action] Update Console";
export class UpdateConsole implements Action {
 readonly type = UPDATE_CONSOLE;
 constructor(public bale: ConsoleBit) {}
}

export const READ_CONSOLE = "[Read action] Read Console";
 export class ReadConsole implements Action {
 readonly type = READ_CONSOLE;
 constructor(public bale: ConsoleBit) {}
 }
 
export const WRITE_CONSOLE = "[Write action] Write Console";
 export class WriteConsole implements Action {
 readonly type = WRITE_CONSOLE;
 constructor(public bale: ConsoleBit) {}
 }
 
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
 export class RemoveConsole implements Action {
 readonly type = REMOVE_CONSOLE;
 constructor(public bale: ConsoleBit) {}
 }
 
export const DELETE_CONSOLE = "[Delete action] Delete Console";
 export class DeleteConsole implements Action {
 readonly type = DELETE_CONSOLE;
 constructor(public bale: ConsoleBit) {}
 }
 
export const CREATE_CONSOLE = "[Create action] Create Console";
 export class CreateConsole implements Action {
 readonly type = CREATE_CONSOLE;
 constructor(public bale: ConsoleBit) {}
 }
 
export type Actions = | InitConsole | UpdateConsole 
| ReadConsole
| WriteConsole
| RemoveConsole
| DeleteConsole
| CreateConsole
export { initConsole  } from "./buz/console.buzz";
export { updateConsole  } from "./buz/console.buzz";
export { readConsole  } from "./buz/console.buzz";
export { writeConsole  } from "./buz/console.buzz";
export { removeConsole  } from "./buz/console.buzz";
export { deleteConsole  } from "./buz/console.buzz";
export { createConsole  } from "./buz/console.buzz";
import Console from "./fce/console.interface";
import ConsoleBit from "./fce/console.interface";

export class ConsoleModel implements Console {
 //idx:string;
 //consoleBitList: ConsoleBit[] = [];
 //consoleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./console.action";
import { ConsoleModel } from "./console.model";
import * as Buzz from "./console.buzzer";
import State from "../99.core/state";

export function reducer(model: ConsoleModel = new ConsoleModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CONSOLE:
 return Buzz.updateConsole(clone(model), act.bale, state);

 case Act.INIT_CONSOLE:
 return Buzz.initConsole(clone(model), act.bale, state);

case Act.READ_CONSOLE:
 return Buzz.readConsole(clone(model), act.bale, state);
 
case Act.WRITE_CONSOLE:
 return Buzz.writeConsole(clone(model), act.bale, state);
 
case Act.REMOVE_CONSOLE:
 return Buzz.removeConsole(clone(model), act.bale, state);
 
case Act.DELETE_CONSOLE:
 return Buzz.deleteConsole(clone(model), act.bale, state);
 
case Act.CREATE_CONSOLE:
 return Buzz.createConsole(clone(model), act.bale, state);
 
 default:
 return model;
 }
}


import State from "../99.core/state";


export default class ConsoleUnit {

 constructor(state: State) {
 }
}

import TermBit from "./term.bit";

export default interface ConsoleBit {
    idx:string;
    src?:string;
    lst?: any[];
    val?:number;
    dat?:any;
    slv?:Function;
    net:any;
    trm?:TermBit
}


import  ConsoleBit  from "./console.bit";

export default interface Console {
 // idx:string;
 // consoleBitList: ConsoleBit[];
 // consoleBits:any;

}


export default interface TermBit {
 idx:string;
 clr:string;
 bit:any;
 net:any;
}

import { InputModel } from "../input.model";
import InputBit from "../fce/input.bit";
import State from "../../99.core/state";

import NetBit from "../../81.grid.unit/fce/net.bit";
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

export const initInput = (cpy: InputModel, bal: InputBit, ste: State) => {
  debugger
  return cpy;
};

export const updateInput = (cpy: InputModel, bal: InputBit, ste: State) => {
  return cpy;
};


export const openInput = (cpy: InputModel, bal: InputBit, ste: State) => {



  let blessed = ste.value.terminal.blessed;
  let screen = ste.value.terminal.screen

  var dat = { idx: 'input-bit', clr0: Color.GREEN, clr1: Color.CYAN }
  for (var key in bal.dat) { dat[key] = bal.dat[key] }

  let net: NetBit = bal.net;

  if (bal.txt == null) bal.txt = 'input below'

  var title = blessed.textbox({
    parent: screen,
    name: 'input',
    keys: true,
    left: net.left,
    top: 1,
    width: net.width,
    height: 2,
    content: 'rename',
    border: { type: 'line' },
    label: bal.txt,
    style: {
      // bg: dat.clr1,
    }
  });



  var input = blessed.textbox({
    parent: screen,
    name: 'input',
    input: true,
    keys: true,
    left: net.left,
    top: net.top,
    width: net.width,
    height: net.height,
    inputOnFocus: true,

    style: {
      bg: dat.clr1,
      focus: {
        bg: 'red'
      },
      hover: {
        bg: 'red'
      }
    }
  });

  input.focus();

  input.on("submit", (src) => {
    if (bal.slv != null) bal.slv({ putBit: { idx: "open-input", src } });
  })

  return cpy;
};




export default interface InputBit {
    idx:string;
    src?:string;
    lst?: any[];
    val?:number;
    txt?:string;
    dat?:any;
    net?:any;
    slv?:Function;
}


import  InputBit  from "./input.bit";

export default interface Input {
 // idx:string;
 // inputBitList: InputBit[];
 // inputBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import  InputBit  from "./fce/input.bit";

// Input actions

export const INIT_INPUT = "[Input action] Init Input";
export class InitInput implements Action {
 readonly type = INIT_INPUT;
 constructor(public bale: InputBit) {}
}

export const UPDATE_INPUT = "[Input action] Update Input";
export class UpdateInput implements Action {
 readonly type = UPDATE_INPUT;
 constructor(public bale: InputBit) {}
}

export const OPEN_INPUT = "[Open action] Open Input";
 export class OpenInput implements Action {
 readonly type = OPEN_INPUT;
 constructor(public bale: InputBit) {}
 }
 
export type Actions = | InitInput | UpdateInput 
| OpenInput
export { initInput  } from "./buz/input.buzz";
export { updateInput  } from "./buz/input.buzz";
export { openInput  } from "./buz/input.buzz";
import Input from "./fce/input.interface";
import InputBit from "./fce/input.interface";

export class InputModel implements Input {
 //idx:string;
 //inputBitList: InputBit[] = [];
 //inputBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./input.action";
import { InputModel } from "./input.model";
import * as Buzz from "./input.buzzer";
import State from "../99.core/state";

export function reducer(model: InputModel = new InputModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_INPUT:
 return Buzz.updateInput(clone(model), act.bale, state);

 case Act.INIT_INPUT:
 return Buzz.initInput(clone(model), act.bale, state);

case Act.OPEN_INPUT:
 return Buzz.openInput(clone(model), act.bale, state);
 
 default:
 return model;
 }
}


import State from "../99.core/state";


export default class InputUnit {

 constructor(state: State) {
 }
}

import { ChoiceModel } from "../choice.model";
import ChoiceBit from "../fce/choice.bit";
import State from "../../99.core/state";
import NetBit from "../../81.grid.unit/fce/net.bit";
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

export const initChoice = (cpy: ChoiceModel, bal: ChoiceBit, ste: State) => {
  debugger
  return cpy;
};

export const updateChoice = (cpy: ChoiceModel, bal: ChoiceBit, ste: State) => {
  return cpy;
};


export const openChoice = (cpy: ChoiceModel, bal: ChoiceBit, ste: State) => {


  


  let blessed = ste.value.terminal.blessed;
  let screen = ste.value.terminal.screen;

  var dat = { idx: 'choice-bit', clr0 : Color.GREEN, clr1: Color.CYAN }
  for ( var key in bal.dat ){ dat[key] = bal.dat[key]}

  let net: NetBit = bal.net;

  var form = blessed.form({
    parent: screen,
    keys: true,
    left: net.left,
    top: net.top,
    width: net.width,
    height: net.height,
    bg: dat.clr0,
    content: ''
  });

  if (bal.lst == null) bal.lst = [];

  var output = [];

  bal.lst.forEach((a, b) => {

    let btn = blessed.button({
      parent: form,
      mouse: true,
      keys: true,
      shrink: true,
      padding: {
        left: 10,
        right: 1
      },
      left: 0,
      top: b,
      height:1,
      width:'100%',
      name: a,
      content: a,
      style: {
        bg: dat.clr1,
        focus: {
          bg: 'red'
        },
        hover: {
          bg: 'red'
        }
      }
    });

    btn.on('press', function () {
      form.submit();
    });

    output.push( btn)
  
  })

  screen.key('left', () => form.focusPrevious())
  screen.key('right', () => form.focusNext())

  output[0].focus();

  screen.render();

  form.on('submit', async function  (data) {
    
    //form.setContent('Submitted.');

    let selected = form._selected;

    if ( selected == null ){

      //use the first one
      output

      selected = output[0];
      selected.content

      //var bit = await ste.hunt( ActChc.OPEN_CHOICE, bal)
      //if (bal.slv != null) bal.slv({ chcBit: { idx: "open-choice", dat:bit } });
      //return 
    }


    let src = selected.content;
    let val = selected.index - 1;

    

    screen.render();
    if (bal.slv != null) bal.slv({ chcBit: { idx: "open-choice", src, val } });

  });

  return cpy;
};


export const keyChoice = (cpy: ChoiceModel, bal: ChoiceBit, ste: State) => {

  let blessed = ste.value.terminal.blessed;
  let screen = ste.value.terminal.screen;

  let net: NetBit = bal.net;

  let menubar = blessed.listbar({
    parent: screen,
    keys: true,
    left: net.left,
    top: net.top,
    width: net.width,
    height: net.height,
    style: { item: { fg: "yellow" }, selected: { fg: "yellow" } },
    commands: {
      Login: {
        keys: ["l", "L"],
        callback: () => {
          debugger
        }
      },
      "Toggle Autotrading": {
        keys: ["a", "A"],
        callback: () => {
          debugger
        }
      },
      "Make a Trade": {
        keys: ["t", "T"],
        callback: () => {
          debugger
        }
      },
      Help: {
        keys: ["h", "H"],
        callback: () => {

          debugger

        }
      },
      Logout: {
        keys: ["o", "O"],
        callback: () => { debugger }
      },
      Exit: {
        keys: ["C-c", "escape"],
        callback: () => process.exit(0)
      }
    }
  });


  screen.render();
  
  if (bal.slv != null) bal.slv({ scnBit: { idx: "key-choice"}});


  return cpy;
};


export const towerChoice = (cpy: ChoiceModel, bal: ChoiceBit, ste: State) => {

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  ChoiceBit  from "./fce/choice.bit";

// Choice actions

export const INIT_CHOICE = "[Choice action] Init Choice";
export class InitChoice implements Action {
 readonly type = INIT_CHOICE;
 constructor(public bale: ChoiceBit) {}
}

export const UPDATE_CHOICE = "[Choice action] Update Choice";
export class UpdateChoice implements Action {
 readonly type = UPDATE_CHOICE;
 constructor(public bale: ChoiceBit) {}
}

export const OPEN_CHOICE = "[Open action] Open Choice";
 export class OpenChoice implements Action {
 readonly type = OPEN_CHOICE;
 constructor(public bale: ChoiceBit) {}
 }
 
export const KEY_CHOICE = "[Key action] Key Choice";
 export class KeyChoice implements Action {
 readonly type = KEY_CHOICE;
 constructor(public bale: ChoiceBit) {}
 }
 
export const TOWER_CHOICE = "[Tower action] Tower Choice";
 export class TowerChoice implements Action {
 readonly type = TOWER_CHOICE;
 constructor(public bale: ChoiceBit) {}
 }
 
export type Actions = | InitChoice | UpdateChoice 
| OpenChoice
| KeyChoice
| TowerChoice
export { initChoice  } from "./buz/choice.buzz";
export { updateChoice  } from "./buz/choice.buzz";
export { openChoice  } from "./buz/choice.buzz";
export { keyChoice  } from "./buz/choice.buzz";
export { towerChoice  } from "./buz/choice.buzz";
import Choice from "./fce/choice.interface";
import ChoiceBit from "./fce/choice.interface";

export class ChoiceModel implements Choice {
 //idx:string;
 //choiceBitList: ChoiceBit[] = [];
 //choiceBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./choice.action";
import { ChoiceModel } from "./choice.model";
import * as Buzz from "./choice.buzzer";
import State from "../99.core/state";

export function reducer(model: ChoiceModel = new ChoiceModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_CHOICE:
 return Buzz.updateChoice(clone(model), act.bale, state);

 case Act.INIT_CHOICE:
 return Buzz.initChoice(clone(model), act.bale, state);

case Act.OPEN_CHOICE:
 return Buzz.openChoice(clone(model), act.bale, state);
 
case Act.KEY_CHOICE:
 return Buzz.keyChoice(clone(model), act.bale, state);
 
case Act.TOWER_CHOICE:
 return Buzz.towerChoice(clone(model), act.bale, state);
 
 default:
 return model;
 }
}


import State from "../99.core/state";


export default class ChoiceUnit {

 constructor(state: State) {
 }
}

import NetBit from "../../81.grid.unit/fce/net.bit";

export default interface ChoiceBit {
    idx:string;
    src?:string;
    clr?:string;
    lst?: any[];
    val?:number;
    dat?:any;
    slv?:Function;
    net?:NetBit
}


import  ChoiceBit  from "./choice.bit";

export default interface Choice {
 // idx:string;
 // choiceBitList: ChoiceBit[];
 // choiceBits:any;

}

import * as ActCol from '../../97.collect.unit/collect.action';

import { CollectModel } from '../collect.model';
import CollectBit from '../fce/collect.bit';
import State from '../../99.core/state';
import CaboodleBit from '../fce/caboodle.bit';
import S from 'string';

import * as doT from 'dot';

var bit, lst, dat, idx, val, src, dex;

export const initCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  return cpy;
};

export const updateCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  return cpy;
};

//return the first item in a collection
export const fetchCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.val == null) bal.val = 1;

  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'fetch-collect-err', src: 'no-bit' } });
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (bal.val == 1) bit = cabBit.bitList[0];
  else bit = cabBit;

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'fetch-collect', dat: bit } });
  return cpy;
};

export const readCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  if (bal.bit == null)
    bal.slv({ clcBit: { idx: 'read-collect-err', src: 'no-bit' } });

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(ActCol.WRITE_COLLECT, {
      idx: bal.idx,
      src: bal.src,
      bit: bal.bit,
    });
  } else {
    dat = cabBit.bitList[cabBit.bits[bal.idx]];
  }

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'read-collect', dat } });
  return cpy;
};

export const writeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  dat = null;

  //let us check see if it exists
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  if (bal.bit == null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-bit' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  bal.idx;

  val = 0;

  

  if (cabBit.bits[bal.idx] == null) {
    bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
    var objDat = bit[Object.keys(bit)[0]];
    dat = objDat.dat;

    if (dat == null) dat = {};

    dat.dex = cabBit.bitList.length;
    cabBit.bitList.push(dat);

    

    var idx = bal.idx;
    if (idx == null) idx = dat.idx;

    if (idx == null) throw new Error('write collect has no idx');

    cabBit.bits[idx] = dat.dex;

    
    
  } else {
    var cabDat = cabBit.bitList[cabBit.bits[bal.idx]];

    bal.dat;



    val = 1;

    for (var key in bal.dat) {
      if (cabDat == null) cabDat = {};
      cabDat[key] = bal.dat[key];
    }

    cabBit.bitList[cabBit.bits[bal.idx]] = cabDat;
    dat = cabDat;

    

    //!!! SUPER IMPORTANT
  }

  if (dat == null && bal.slv != null)
    bal.slv({ rskBit: { idx: 'write-collect-err', src: 'no-dat' } });

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'write-collect', val, dat } });

  return cpy;
};

export const createCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var cabBit: CaboodleBit = { idx: bal.idx, dex: 0, bits: {}, bitList: [] };
  cabBit.dex = cpy.caboodleBitList.length;

  cpy.caboodleBitList.push(cabBit);
  cpy.caboodleBits[cabBit.idx] = cabBit.dex;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'create-collect', dat: cabBit } });

  return cpy;
};

export const removeCollect = async (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();

  if (cpy.caboodleBits[type] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-not-present' } });

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  if (cabBit.bits[bal.idx] == null)
    return bal.slv({ rskBit: { idx: 'remove-collect-idx-not-present' } });

  bit = await ste.hunt(bal.bit, { idx: bal.idx, src: bal.src, dat: bal.dat });
  var objDat = bit[Object.keys(bit)[0]];
  dat = objDat.dat;

  dex = dat.dex;

  for (var i = dex; i < cabBit.bitList.length - 1; i++) {
    var update = cabBit.bitList[i];
    update.dex -= 1;
  }

  for (var key in dat) {
    dat[key] = null;
  }

  delete cabBit.bits[bal.idx];
  var itm = cabBit.bitList.splice(dex, 1);

  cabBit.dex -= 1;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'remove-collect', dat: itm[0] } });

  return cpy;
};

export const putCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  cpy.caboodleBits[bal.idx] = bal.val;
  cpy.caboodleBitList[bal.val] = bal.dat;

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'put-collect', dat: bal.dat } });
  return cpy;
};

export const getCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  val = cpy.caboodleBits[bal.idx];
  dat = cpy.caboodleBitList[val];

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'get-collect', val, dat } });
  return cpy;
};

export const modelCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger

  if (bal.slv != null) bal.slv({ clcBit: { idx: 'model-collect', dat: cpy } });
  return cpy;
};

export const deleteCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const emptyCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  //debugger
  return cpy;
};

export const dotCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  var gel = bal.dat;
  var out = [];

  bal.src.split('\n').forEach((a, b) => {
    if (a.includes('//') == true) return;
    var doTCompiled = doT.template(a);
    var outLine = doTCompiled(gel);
    out.push(outLine);
  });

  if (bal.slv != null)
    bal.slv({ clcBit: { idx: 'dot-vurt', lst: out, src: out.join('\n') } });

  return cpy;
};

export const formatCollect = (
  cpy: CollectModel,
  bal: CollectBit,
  ste: State,
) => {
  lst = bal.src.split(':');

  var idx = lst[0];

  var out = [];

  idx = S(idx).collapseWhitespace().s;
  var opt = lst[1].split(',');
  opt.forEach((a, b) => {
    var now = S(a).collapseWhitespace().s;
    if (a.length < 1) return;
    out.push(now);
  });

  dat = [idx, out];

  bal.slv({ clcBit: { idx: 'format-collect', dat } });
  return cpy;
};

export const listCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {

  

  var type = bal.bit.split(' ').slice(-1).pop().toLowerCase();
  if (cpy.caboodleBits[type] == null) createCollect(cpy, { idx: type }, ste);

  var cabBit: CaboodleBit = cpy.caboodleBitList[cpy.caboodleBits[type]];

  lst = [];

  cabBit.bitList.forEach((a) => {
    if (a.idx != null) lst.push(a.idx);
    if (a.id != null) lst.push(a.id);
  });

  

  bal.slv({ clcBit: { idx: 'list-collect', lst } });

  return cpy;
};

export const hashCollect = (cpy: CollectModel, bal: CollectBit, ste: State) => {
  if (bal.src == null) bal.src = '';
  lst = bal.src.split('\n');

  dat = {};

  lst.forEach((a) => {
    a = S(a).collapseWhitespace().s;
    if (a.length < 3) return;

    var hold = a.split(':');

    var dom = hold[0];
    var sub = hold[1];

    var now = sub.split(',');

    now.forEach((b, c) => {
      now[c] = S(b).collapseWhitespace().s;
    });

    dat[dom] = now;
  });

  bal.slv({ clcBit: { idx: 'hash-collect', dat } });

  return cpy;
};



import { Action } from "../99.core/interface/action.interface";
import  CollectBit  from "./fce/collect.bit";

// Collect actions

export const INIT_COLLECT = "[Collect action] Init Collect";
export class InitCollect implements Action {
 readonly type = INIT_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const UPDATE_COLLECT = "[Collect action] Update Collect";
export class UpdateCollect implements Action {
 readonly type = UPDATE_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const FETCH_COLLECT = "[Collect action] Fetch Collect";
export class FetchCollect implements Action {
 readonly type = FETCH_COLLECT;
 constructor(public bale: CollectBit) {}
}

export const READ_COLLECT = "[Read action] Read Collect";
 export class ReadCollect implements Action {
 readonly type = READ_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const WRITE_COLLECT = "[Write action] Write Collect";
 export class WriteCollect implements Action {
 readonly type = WRITE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const CREATE_COLLECT = "[Create action] Create Collect";
 export class CreateCollect implements Action {
 readonly type = CREATE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const REMOVE_COLLECT = "[Create action] Remove Collect";
 export class RemoveCollect implements Action {
 readonly type = REMOVE_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DELETE_COLLECT = "[Create action] Delete Collect";
 export class DeleteCollect implements Action {
 readonly type = DELETE_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const EMPTY_COLLECT = "[Empty action] Empty Collect";
 export class EmptyCollect implements Action {
 readonly type = EMPTY_COLLECT;
 constructor(public bale: CollectBit) {}
 }


 export const MODEL_COLLECT = "[Empty action] Model Collect";
 export class ModelCollect implements Action {
 readonly type = MODEL_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const PUT_COLLECT = "[Empty action] Put Collect";
 export class PutCollect implements Action {
 readonly type = PUT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const GET_COLLECT = "[Empty action] Get Collect";
 export class GetCollect implements Action {
 readonly type = GET_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 
export const FORMAT_COLLECT = "[Format action] Format Collect";
 export class FormatCollect implements Action {
 readonly type = FORMAT_COLLECT;
 constructor(public bale: CollectBit) {}
 }

 export const DOT_COLLECT = "[Format action] Dot Collect";
 export class DotCollect implements Action {
 readonly type = DOT_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const LIST_COLLECT = "[List action] List Collect";
 export class ListCollect implements Action {
 readonly type = LIST_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export const HASH_COLLECT = "[Hash action] Hash Collect";
 export class HashCollect implements Action {
 readonly type = HASH_COLLECT;
 constructor(public bale: CollectBit) {}
 }
 
export type Actions = | InitCollect | UpdateCollect 
| ReadCollect
| WriteCollect
| CreateCollect
| EmptyCollect
| FetchCollect
| DeleteCollect
| RemoveCollect
| ModelCollect
| GetCollect
| PutCollect
| FormatCollect
| DotCollect
| ListCollect
| HashCollect
export { initCollect  } from "./buz/collect.buzz";
export { updateCollect  } from "./buz/collect.buzz";
export { readCollect  } from "./buz/collect.buzz";
export { writeCollect  } from "./buz/collect.buzz";
export { createCollect  } from "./buz/collect.buzz";
export { emptyCollect  } from "./buz/collect.buzz";
export { fetchCollect  } from "./buz/collect.buzz";
export { deleteCollect  } from "./buz/collect.buzz";
export { removeCollect  } from "./buz/collect.buzz";
export { modelCollect  } from "./buz/collect.buzz";
export { putCollect  } from "./buz/collect.buzz";
export { getCollect  } from "./buz/collect.buzz";
export { formatCollect  } from "./buz/collect.buzz";
export { dotCollect  } from "./buz/collect.buzz";
export { listCollect  } from "./buz/collect.buzz";
export { hashCollect  } from "./buz/collect.buzz";
import CaboodleBit from "./fce/caboodle.bit";
import Collect from "./fce/collect.interface";
import CollectBit from "./fce/collect.interface";

export class CollectModel implements Collect {
 idx:string = '23.11.14';
 caboodleBitList: CaboodleBit[] = [];
 caboodleBits: any = {};
}

import * as clone from "clone-deep";
import * as Act from "./collect.action";
import { CollectModel } from "./collect.model";
import * as Buzz from "./collect.buzzer";
import State from "../99.core/state";

export function reducer(model: CollectModel = new CollectModel(), act: Act.Actions, state?: State) {
   switch (act.type) {

      case Act.UPDATE_COLLECT:
         return Buzz.updateCollect(clone(model), act.bale, state);

      case Act.INIT_COLLECT:
         return Buzz.initCollect(clone(model), act.bale, state);

      case Act.READ_COLLECT:
         return Buzz.readCollect(clone(model), act.bale, state);

      case Act.WRITE_COLLECT:
         return Buzz.writeCollect(clone(model), act.bale, state);

      case Act.CREATE_COLLECT:
         return Buzz.createCollect(clone(model), act.bale, state);

      case Act.DELETE_COLLECT:
         return Buzz.deleteCollect(clone(model), act.bale, state);

      case Act.REMOVE_COLLECT:
         return Buzz.removeCollect(clone(model), act.bale, state);

      case Act.EMPTY_COLLECT:
         return Buzz.emptyCollect(clone(model), act.bale, state);

      case Act.FETCH_COLLECT:
         return Buzz.fetchCollect(clone(model), act.bale, state);

      case Act.MODEL_COLLECT:
         return Buzz.modelCollect(clone(model), act.bale, state);

      case Act.GET_COLLECT:
         return Buzz.getCollect(clone(model), act.bale, state);

      case Act.PUT_COLLECT:
         return Buzz.putCollect(clone(model), act.bale, state);

      case Act.FORMAT_COLLECT:
         return Buzz.formatCollect(clone(model), act.bale, state);

      case Act.DOT_COLLECT:
         return Buzz.dotCollect(clone(model), act.bale, state);

case Act.LIST_COLLECT:
 return Buzz.listCollect(clone(model), act.bale, state);
 
case Act.HASH_COLLECT:
 return Buzz.hashCollect(clone(model), act.bale, state);
 
      default:
         return model;
   }
}

import State from "../99.core/state";


export default class CollectUnit {

    constructor(state: State) {
    }
}


export default interface CaboodleBit {
 idx:string;
 dex:number;
 bitList: any[];
 bits: any;
}


export default interface CollectBit {
 idx?:string;
 src?:string;
 val?:number;
 dex?:number;
 dat?:any;
 bit?:any;
 slv?:Function;
}





import  CollectBit  from "./collect.bit";
import CaboodleBit from "./caboodle.bit";

export default interface Collect {
  idx:string;
  caboodleBitList: CaboodleBit[];
  caboodleBits:any;
}

import * as ActMnu from "../menu.action";

import * as ActLib from "../../00.library.unit/library.action";
import * as ActUnt from "../../01.unit.unit/unit.action";
import * as ActAct from "../../02.action.unit/action.action";

import * as ActDat from "../../03.data.unit/data.action";

import * as ActSrv from "../../04.server.unit/server.action";

import * as ActClc from "../../97.collect.unit/collect.action";

import * as ActPut from "../../84.input.unit/input.action";
import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
//import * as ActCvs from "../../82.canvas.unit/canvas.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActDif from "../../act/diffusion.action"

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

var bit, lst, dex, idx, dat, src, val;

var FS = require('fs-extra')

export const initMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  if (bal == null) bal = { idx: null }

  bit = await ste.hunt(ActTrm.INIT_TERMINAL, {});

  bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 4, y: 0, xSpan: 1, ySpan: 12 })
  //bit = await ste.hunt(ActCvs.WRITE_CANVAS, { idx: 'cvs1', dat: { clr: Color.CYAN, net: bit.grdBit.dat }, })

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 4, y: 0, xSpan: 8, ySpan: 12 })
  bit = await ste.hunt(ActCns.WRITE_CONSOLE, { idx: 'cns00', src: "", dat: { net: bit.grdBit.dat, src: "alligaor0" } })

  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "-----------" })
  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "Library PIVOT V0" })
  bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "-----------" })

  updateMenu(cpy, bal, ste);

  return cpy;
};

export const updateMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  lst = [
    ActLib.DEV_LIBRARY,
    ActDif.UPDATE_DIFFUSION,
    ActSrv.UPDATE_SERVER,
    ActMnu.EARTH_MENU,
    ActDat.FRAME_DATA,
    ActMnu.OLLAMA_MENU,
    ActMnu.CONTROL_MENU,
    ActMnu.TIME_MENU,
    ActMnu.SPACE_MENU,
    ActMnu.SOWER_MENU,
    ActMnu.MARKET_MENU,
    ActLib.ASTRO_LIBRARY,
    ActLib.COUNT_LIBRARY, ActUnt.UPDATE_UNIT, ActAct.UPDATE_ACTION, ActUnt.CREATE_UNIT, ActLib.UPDATE_LIBRARY, ActLib.LIST_LIBRARY]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {


    case ActSrv.UPDATE_SERVER:
      var bit = await ste.hunt(ActSrv.UPDATE_SERVER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActDif.UPDATE_DIFFUSION:
      var bit = await ste.bus(ActDif.UPDATE_DIFFUSION, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActDat.FRAME_DATA:

      lst = FS.readdirSync('../films')

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "Framing.." + src })

      var bit = await ste.hunt(ActDat.FRAME_DATA, { src })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActAct.UPDATE_ACTION:

      bit = await ste.hunt(ActLib.LIST_LIBRARY, {})
      lst = bit.libBit.lst

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await ste.hunt(ActUnt.LIST_UNIT, { src })
      lst = bit.untBit.lst

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      idx = bit.chcBit.src;

      var updateBit = await ste.hunt(ActAct.UPDATE_ACTION, { idx, src })
      break;

    case ActUnt.CREATE_UNIT:

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 6 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input verb', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      var updateBit = await ste.hunt(ActUnt.CREATE_UNIT, { idx })

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActMnu.PRINT_MENU, updateBit)
      break;

    case ActUnt.UPDATE_UNIT:

      bit = await ste.hunt(ActLib.LIST_LIBRARY, {})
      lst = bit.libBit.lst

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await ste.hunt(ActUnt.LIST_UNIT, { src })
      lst = bit.untBit.lst

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      idx = bit.chcBit.src;

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 6 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input verb', net: bit.grdBit.dat })
      dat = bit.putBit.src;

      var updateBit = await ste.hunt(ActUnt.UPDATE_UNIT, { idx, src, dat })
      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, updateBit)
      break;

    case ActUnt.CREATE_UNIT:

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 6 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input verb', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      var updateBit = await ste.hunt(ActUnt.CREATE_UNIT, { idx })

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActMnu.PRINT_MENU, updateBit)
      break;

    case ActLib.ASTRO_LIBRARY:
      var bit = await ste.hunt(ActLib.ASTRO_LIBRARY, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActLib.LIST_LIBRARY:
      var bit = await ste.hunt(ActLib.LIST_LIBRARY, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActLib.DEV_LIBRARY:
      var bit = await ste.hunt(ActLib.DEV_LIBRARY, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActLib.COUNT_LIBRARY:
      var bit = await ste.hunt(ActLib.COUNT_LIBRARY, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActLib.UPDATE_LIBRARY:
      var bit = await ste.hunt(ActLib.LIST_LIBRARY, {})
      lst = bit.libBit.lst

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

      src = bit.chcBit.src;

      var bit = await ste.hunt(ActLib.UPDATE_LIBRARY, { src })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.CONTROL_MENU:
      bit = await ste.hunt(ActMnu.CONTROL_MENU, {})
      break;

    case ActMnu.OLLAMA_MENU:
      bit = await ste.hunt(ActMnu.OLLAMA_MENU, {})
      break;

    case ActMnu.SOWER_MENU:
      bit = await ste.hunt(ActMnu.SOWER_MENU, {})
      break;

    case ActMnu.SPACE_MENU:
      bit = await ste.hunt(ActMnu.SPACE_MENU, {})
      break;

    case ActMnu.TIME_MENU:
      bit = await ste.hunt(ActMnu.TIME_MENU, {})
      break;

    case ActMnu.EARTH_MENU:
      bit = await ste.hunt(ActMnu.EARTH_MENU, {})
      break;

    case ActMnu.MARKET_MENU:
      bit = await ste.hunt(ActMnu.MARKET_MENU, {})
      break;

    case ActLib.UPDATE_LIBRARY:
      ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "Update Library Pivot" })
      bit = await ste.hunt(ActLib.UPDATE_LIBRARY, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.GITHUB_MENU:
      bit = await ste.hunt(ActMnu.GITHUB_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      bit = await ste.hunt(ActMnu.UPDATE_MENU)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  setTimeout(() => {

    updateMenu(cpy, bal, ste);

  }, 1111)



  return cpy;
};

export const testMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {
  return cpy;
};

export const closeMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  await ste.hunt(ActTrm.CLOSE_TERMINAL, {})

  return cpy;
};

export const createMenu = (cpy: MenuModel, bal: MenuBit, ste: State) => {
  debugger
  return cpy;
};


export const printMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {
  dat = bal;
  if (dat == null) return bal.slv({ mnuBit: { idx: "print-menu", dat } });

  var itm = JSON.stringify(dat);

  lst = itm.split(",");
  lst.forEach((a) => ste.hunt(ActCns.UPDATE_CONSOLE, { idx: "cns00", src: a }));
  ste.hunt(ActCns.UPDATE_CONSOLE, { idx: "cns00", src: "------------" });

  bal.slv({ mnuBit: { idx: "print-menu", dat: itm } });
};

var patch = (ste, type, bale) => ste.dispatch({ type, bale });



import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";
const path = require('path');
var exec = require('child_process').exec;

import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

import * as ActMnu from "../menu.action";

//import * as ActFoc from "../../01.focus.unit/focus.action";
//import * as ActPvt from "../../96.pivot.unit/pivot.action";


import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";
import * as ActPut from "../../84.input.unit/input.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActTrn from "../../act/turn.action";
import * as ActCtl from "../../act/control.action";
import * as ActClr from "../../act/color.action";

import * as PVT from '../../val/pivot'

var bit, lst, dex, idx, dat, src;

var CONTROL, TIME, SPACE, PIXEL, SOLID, SOWER, EARTH;

var opened = false;

export const controlMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var FS = require('fs-extra')
  
  await (async () => {
    try {

      await new Promise<void>((resolve, reject) => exec('tsc -b 000.control', err => err ? reject(err) : resolve()));

      if (global.CONTROL == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled control" });
      if (global.CONTROL == null) CONTROL = global.CONTROL = require(path.resolve('./dist/000.control/hunt'));

      await new Promise<void>((resolve, reject) => exec('tsc -b 001.time', err => err ? reject(err) : resolve()));

      if (global.TIME == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled time" });
      if (global.TIME == null) TIME = global.TIME = require(path.resolve('./dist/001.time/hunt'));
      if (window[ PVT.TIME ] == null) window[ PVT.TIME ] = TIME.hunt

      await new Promise<void>((resolve, reject) => exec('tsc -b 002.space', err => err ? reject(err) : resolve()));

      if (global.SPACE == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled space" });
      if (global.SPACE == null) SPACE = global.SPACE = require(path.resolve('./dist/002.space/hunt'));
      if (window[ PVT.SPACE ] == null) window[ PVT.SPACE ] = SPACE.hunt

      //await new Promise<void>((resolve, reject) => exec('tsc -b 111.solid', err => err ? reject(err) : resolve()));

      //if (global.SOLID == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled solid" });
      //if (global.SOLID == null) SOLID = global.SOLID = require(path.resolve('./dist/111.solid/hunt'));
      //if (window['SOLID'] == null) window['SOLID'] = SOLID.hunt

      await new Promise<void>((resolve, reject) => exec('tsc -b 010.sower', err => err ? reject(err) : resolve()));

      if (global.SOWER == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled sower" });
      if (global.SOWER == null) SOWER = global.SOWER = require(path.resolve('./dist/010.sower/hunt'));
      if (window[ PVT.SOWER ] == null) window[ PVT.SOWER ] = SOWER.hunt

      await new Promise<void>((resolve, reject) => exec('tsc -b 011.earth', err => err ? reject(err) : resolve()));

      if (global.EARTH == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled earth" });
      if (global.EARTH == null) EARTH = global.EARTH = require(path.resolve('./dist/011.earth/hunt'));
      if (window[PVT.EARTH] == null) window[PVT.EARTH] = EARTH.hunt


      
     // await new Promise<void>((resolve, reject) => exec('tsc -b 002.space', err => err ? reject(err) : resolve()));

     // if (global.SPACE == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled space" });
     // if (global.SPACE == null) SPACE = global.SPACE = require(path.resolve('./dist/002.space/hunt'));

     // await new Promise<void>((resolve, reject) => exec('tsc -b 400.pixel', err => err ? reject(err) : resolve()));

     // if (global.PIXEL == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled pixel" });
     // if (global.PIXEL == null) PIXEL = global.PIXEL = require(path.resolve('./dist/400.pixel/hunt'));


    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  lst = [ ActCtl.UPDATE_CONTROL, ActCtl.OUTPUT_CONTROL,  ActTrn.START_TURN, ActCtl.TEST_CONTROL, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActCtl.UPDATE_CONTROL:

    if ( opened == false ){
      opened = true;
 
      lst = FS.readJsonSync('./public/data/color/000.color.name.json')
      bit = await SOWER.hunt(ActClr.OPEN_COLOR, { lst })

    }

      bit = await CONTROL.hunt( ActCtl.UPDATE_CONTROL, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActTrn.START_TURN:
      bit = await CONTROL.hunt(ActTrn.START_TURN, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActCtl.TEST_CONTROL:
      bit = await CONTROL.hunt(ActCtl.TEST_CONTROL, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.CONTROL_MENU, {})

  }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

import * as ActMnu from "../menu.action";
const path = require('path');
var exec = require('child_process').exec;

import * as ActEth from "../../act/earth.action";

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as ActTrm from "../../act/terminal.action";
import * as ActChc from "../../act/choice.action";

import * as ActGrd from "../../act/grid.action";
import * as ActClr from "../../act/color.action";

import * as PVT from '../../val/pivot'

var bit, lst, dex, idx, dat, src;

var EARTH, TIME, SPACE, SOWER;

export const earthMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var FS = require('fs-extra')

  await (async () => {
    try {

      if (global.EARTH == null) await new Promise<void>((resolve, reject) => exec('tsc -b 000.earth', err => err ? reject(err) : resolve()));

      if (global.EARTH == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled earth" });
      if (global.EARTH == null) global.EARTH = EARTH = require(path.resolve('./dist/000.earth/hunt'));

      if (global.TIME == null) await new Promise<void>((resolve, reject) => exec('tsc -b 001.time', err => err ? reject(err) : resolve()));

      if (global.TIME == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled time" });
      if (global.TIME == null) TIME = global.TIME = require(path.resolve('./dist/001.time/hunt'));
      if (window[PVT.TIME] == null) window[PVT.TIME] = TIME.hunt

      if (global.SPACE == null) await new Promise<void>((resolve, reject) => exec('tsc -b 002.space', err => err ? reject(err) : resolve()));

      if (global.SPACE == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled space" });
      if (global.SPACE == null) SPACE = global.SPACE = require(path.resolve('./dist/002.space/hunt'));
      if (window[PVT.SPACE] == null) window[PVT.SPACE] = SPACE.hunt


      if (global.SOWER == null) await new Promise<void>((resolve, reject) => exec('tsc -b 010.sower', err => err ? reject(err) : resolve()));

      if (global.SOWER == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled sower" });
      if (global.SOWER == null) SOWER = global.SOWER = require(path.resolve('./dist/010.sower/hunt'));
      if (window[PVT.SOWER] == null) window[PVT.SOWER] = SOWER.hunt

      lst = FS.readJsonSync('./public/data/color/000.color.name.json')
      bit = await EARTH.hunt(ActClr.OPEN_COLOR, { lst })

    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  lst = [ ActEth.UPDATE_EARTH, ActEth.ACCESS_EARTH, ActEth.OPEN_EARTH, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActEth.ACCESS_EARTH:
      bit = await EARTH.hunt(ActEth.ACCESS_EARTH, { val: 1 })

      setTimeout(() => { EARTH.hunt(ActEth.ACCESS_EARTH, { val: 0 }) }, 1111)

      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActEth.OPEN_EARTH:
      bit = await EARTH.hunt(ActEth.OPEN_EARTH, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActEth.UPDATE_EARTH:
      bit = await EARTH.hunt(ActEth.UPDATE_EARTH, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.bus(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.EARTH_MENU, {})

  }, 3)



  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




import * as ActMnu from "../menu.action";
const path = require('path');
var exec = require('child_process').exec;

import * as ActMrk from "../../act/market.action";

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";

import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as ActTrm from "../../act/terminal.action";
import * as ActChc from "../../act/choice.action";

import * as ActCrd from "../../act/cardano.action";

import * as ActGrd from "../../act/grid.action";

var bit, lst, dex, idx, dat, src;

var MARKET;

export const marketMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  await (async () => {
    try {
      await new Promise<void>((resolve, reject) => exec('tsc -b 168.market', err => err ? reject(err) : resolve()));
      if (MARKET == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled market" });
      if (MARKET == null) MARKET = require(path.resolve('./dist/168.market/hunt'));
    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  lst = [ActCrd.TEST_CARDANO, ActMrk.UPDATE_MARKET, ActMrk.INIT_MARKET, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActCrd.TEST_CARDANO:
      bit = await MARKET.hunt(ActCrd.TEST_CARDANO, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMrk.UPDATE_MARKET:
      bit = await MARKET.hunt(ActMrk.UPDATE_MARKET, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMrk.INIT_MARKET:
      bit = await MARKET.hunt(ActMrk.INIT_MARKET, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.bus(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  setTimeout(async () => { bit = await ste.hunt(ActMnu.MARKET_MENU, {}) }, 3)

  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";
const path = require('path');
var exec = require('child_process').exec;

import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

import * as ActMnu from "../menu.action";

//import * as ActFoc from "../../01.focus.unit/focus.action";
//import * as ActPvt from "../../96.pivot.unit/pivot.action";

import * as ActOlm from "../../10.ollama.unit/ollama.action";
import * as ActCdx from "../../20.codex.unit/codex.action";


import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";
import * as ActPut from "../../84.input.unit/input.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActTrn from "../../act/turn.action";
import * as ActCtl from "../../act/control.action";
import * as ActClr from "../../act/color.action";

import * as PVT from '../../val/pivot'

var bit, lst, dex, idx, dat, src;

var CONTROL, TIME, SPACE, PIXEL, SOLID, SOWER, EARTH;

var opened = false;

export const ollamaMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  lst = [ ActCdx.UPDATE_CODEX,  ActOlm.WRITE_OLLAMA, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActCdx.UPDATE_CODEX:
      bit = await ste.hunt( ActCdx.UPDATE_CODEX, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActOlm.WRITE_OLLAMA:
      bit = await ste.hunt(ActOlm.WRITE_OLLAMA, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.OLLAMA_MENU, {})

  }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

const path = require('path');

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";


import * as ActSpc from "../../act/space.action";

import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

import * as ActMnu from "../menu.action";

//import * as ActPvt from "../../96.pivot.unit/pivot.action";

import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";
import * as ActPut from "../../84.input.unit/input.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

import * as ActFte from "../../act/fate.action";
import * as ActSow from "../../act/sower.action";
import * as ActSpk from "../../act/spark.action";
import * as ActAmb from "../../act/ambit.action";
import * as ActAvo from "../../act/avaou.action";
import * as ActAvd from "../../act/avide.action";
import * as ActArt from "../../act/artes.action";
import * as ActPri from "../../act/primal.action";
import * as ActBnd from "../../act/bounded.action";
import * as ActPas from "../../act/pastoral.action";
import * as ActBls from "../../act/blessed.action";
import * as ActSup from "../../act/supernal.action";

import * as ActClr from "../../act/color.action";

var bit, lst, dex, idx, dat, src;

var SOWER;

var opened = false;

export const sowerMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {


  var FS = require('fs-extra')

  var exec = require('child_process').exec;


  await (async () => {
    try {
      await new Promise<void>((resolve, reject) => exec('tsc -b 010.sower', err => err ? reject(err) : resolve()));
      if (SOWER == null) global.SOWER = SOWER = require(path.resolve('./dist/010.sower/hunt'));
      bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled sower" });
    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  if (opened == false) {
    opened = true;

    lst = FS.readJsonSync('./public/data/color/000.color.name.json')
    bit = await SOWER.hunt(ActClr.OPEN_COLOR, { lst })

  }

  lst = [
    ActMnu.BEING_MENU,
    ActMnu.COLOR_MENU,
    ActMnu.FATE_MENU,
    ActSow.INIT_SOWER,
    ActSow.UPDATE_SOWER,
    ActSow.TEST_SOWER,
    ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActMnu.BEING_MENU:
      bit = await ste.hunt(ActMnu.BEING_MENU, {})
      //bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.COLOR_MENU:
      bit = await ste.hunt(ActMnu.COLOR_MENU, {})
      //bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.FATE_MENU:
      bit = await ste.hunt(ActMnu.FATE_MENU, {})
      //bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSow.INIT_SOWER:
      bit = await SOWER.hunt(ActSow.INIT_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSow.UPDATE_SOWER:
      bit = await SOWER.hunt(ActSow.UPDATE_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSow.TEST_SOWER:
      bit = await SOWER.hunt(ActSow.TEST_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.SOWER_MENU, {})

  }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

const path = require('path');

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";


import * as ActSpc from "../../act/space.action";
import * as ActMap from "../../act/hexmap.action";
import * as ActFoc from "../../act/focus.action";



import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

import * as ActMnu from "../menu.action";

//import * as ActFoc from "../../02.focus.unit/focus.action";
//import * as ActPvt from "../../96.pivot.unit/pivot.action";

import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";
import * as ActPut from "../../84.input.unit/input.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

var bit, lst, dex, idx, dat, src;

var SPACE;

var focIDX;

export const spaceMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var exec = require('child_process').exec;

  await (async () => {
    try {
      await new Promise<void>((resolve, reject) => exec('tsc -b 002.space', err => err ? reject(err) : resolve()));

      if (SPACE == null) bit = await ste.hunt(ActMnu.PRINT_MENU, { src: "compiled space" });
      if (SPACE == null) SPACE = require(path.resolve('./dist/002.space/hunt'));

    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  lst = [ActFoc.FORWARD_FOCUS, ActFoc.SPIN_RIGHT_FOCUS, ActFoc.SPIN_LEFT_FOCUS, ActFoc.BACKWARD_FOCUS, ActFoc.WRITE_FOCUS, ActMap.WRITE_HEXMAP, ActFoc.READ_FOCUS, ActMap.READ_HEXMAP, ActSpc.TEST_SPACE, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActFoc.FORWARD_FOCUS:

      if (focIDX == null) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no focus present" })
        break
      }

      bit = await SPACE.hunt(ActFoc.FORWARD_FOCUS, { idx: focIDX })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFoc.BACKWARD_FOCUS:

      if (focIDX == null) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no focus present" })
        break
      }

      bit = await SPACE.hunt(ActFoc.BACKWARD_FOCUS, { idx: focIDX })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFoc.SPIN_RIGHT_FOCUS:

      if (focIDX == null) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no focus present" })
        break
      }

      bit = await SPACE.hunt(ActFoc.SPIN_RIGHT_FOCUS, { idx: focIDX })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFoc.SPIN_LEFT_FOCUS:

      if (focIDX == null) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no focus present" })
        break
      }

      bit = await SPACE.hunt(ActFoc.SPIN_LEFT_FOCUS, { idx: focIDX })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFoc.WRITE_FOCUS:
      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input focus id', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SPACE.hunt(ActMap.LIST_HEXMAP, {})
      lst = bit.mapBit.lst

      if (lst.length == 0) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no hexmap present" })
        break
      }

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await SPACE.hunt(ActFoc.WRITE_FOCUS, { idx, src })

      focIDX = bit.focBit.dat.idx
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFoc.READ_FOCUS:

      bit = await SPACE.hunt(ActFoc.LIST_FOCUS, {})
      lst = bit.focBit.lst

      if (lst.length == 0) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no focus present" })
        break
      }

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      idx = bit.chcBit.src;

      bit = await SPACE.hunt(ActFoc.WRITE_FOCUS, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMap.WRITE_HEXMAP:
      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input hexmap id', net: bit.grdBit.dat })
      idx = bit.putBit.src;
      bit = await SPACE.hunt(ActMap.WRITE_HEXMAP, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMap.READ_HEXMAP:
      bit = await SPACE.hunt(ActMap.LIST_HEXMAP, {})
      lst = bit.mapBit.lst

      if (lst.length == 0) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no hexmap present" })
        break
      }

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await SPACE.hunt(ActMap.READ_HEXMAP, { idx: src })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSpc.TEST_SPACE:
      bit = await SPACE.hunt(ActSpc.TEST_SPACE, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.SPACE_MENU, {})

  }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

const path = require('path');

import { MenuModel } from "../menu.model";
import MenuBit from "../fce/menu.bit";
import State from "../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";

import * as ActTme from "../../act/time.action";
import * as ActClk from "../../act/clock.action";
import * as ActPrg from "../../act/progress.action";
import * as ActInc from "../../act/increment.action";

import * as Grid from '../../val/grid';
import * as Align from '../../val/align'
import * as Color from '../../val/console-color';

import * as SHAPE from '../../val/shape'
import * as FOCUS from "../../val/focus";

import * as ActMnu from "../menu.action";

//import * as ActFoc from "../../01.focus.unit/focus.action";
//import * as ActPvt from "../../96.pivot.unit/pivot.action";


import * as ActTrm from "../../80.terminal.unit/terminal.action";
import * as ActChc from "../../85.choice.unit/choice.action";
import * as ActPut from "../../84.input.unit/input.action";

import * as ActGrd from "../../81.grid.unit/grid.action";
import * as ActCns from "../../83.console.unit/console.action";

var bit, lst, dex, idx, dat, src;

var TIME;

var incIdx;
var clkIdx;

export const timeMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var exec = require('child_process').exec;

  await (async () => {
    try {
      await new Promise<void>((resolve, reject) => exec('tsc -b 001.time', err => err ? reject(err) : resolve()));

      if (TIME == null) ste.hunt(ActMnu.PRINT_MENU, { src: "compiled time" });
      if (TIME == null) TIME = require(path.resolve('./dist/001.time/hunt'));

    } catch (err) {
      console.error(`exec error: ${err}`);
      throw err;
    }
  })();

  lst = [
    ActPrg.UPDATE_PROGRESS, ActClk.WRITE_CLOCK, ActClk.READ_CLOCK, ActClk.LIST_CLOCK,
    ActInc.WRITE_INCREMENT, ActInc.READ_INCREMENT, ActInc.LIST_INCREMENT,
    ActTme.RANDOM_TIME, ActTme.TEST_TIME, ActMnu.UPDATE_MENU
  ]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
  src = bit.chcBit.src;

  switch (src) {
    case ActTme.TEST_TIME:
      bit = await TIME.hunt(ActTme.TEST_TIME, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActTme.RANDOM_TIME:
      bit = await TIME.hunt(ActTme.RANDOM_TIME, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActPrg.UPDATE_PROGRESS:

      if (incIdx == null) {

        bit = await TIME.hunt(ActInc.LIST_INCREMENT, {})
        lst = bit.clkBit.lst

        if (lst.length == 0) {
          bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no increment present" })
          break
        }

        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---choose the progress increment" })

        bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
        bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
        idx = bit.chcBit.src;
        incIdx = idx;

        bit = await TIME.hunt(ActClk.LIST_CLOCK, {})
        lst = bit.clkBit.lst

        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---choose the progress source" })

        bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
        bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
        src = bit.chcBit.src;
        clkIdx = src

      }

      bit = await TIME.hunt(ActPrg.UPDATE_PROGRESS, { idx: incIdx, src: clkIdx })

      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActInc.WRITE_INCREMENT:

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input increment id', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input day', net: bit.grdBit.dat })
      var day = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input hour', net: bit.grdBit.dat })
      var hrs = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input minute', net: bit.grdBit.dat })
      var min = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input month', net: bit.grdBit.dat })
      var mth = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input second', net: bit.grdBit.dat })
      var sec = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input year', net: bit.grdBit.dat })
      var yrs = bit.putBit.src;

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await TIME.hunt(ActInc.WRITE_INCREMENT, { idx, inc: { day, hrs, min, mth, sec, yrs } })
      incIdx = bit.incBit.dat.idx
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)      
      break;


    case ActInc.READ_INCREMENT:

      bit = await TIME.hunt(ActInc.LIST_INCREMENT, {})
      lst = bit.clkBit.lst

      if (lst.length == 0) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no increment present" })
        break
      }

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await TIME.hunt(ActInc.READ_INCREMENT, { idx: src })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)

      break;

    case ActInc.LIST_INCREMENT:

      bit = await TIME.hunt(ActInc.LIST_INCREMENT, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)

      break;

    case ActClk.WRITE_CLOCK:

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input clock idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input day', net: bit.grdBit.dat })
      var day = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input hour', net: bit.grdBit.dat })
      var hrs = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input minute', net: bit.grdBit.dat })
      var min = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input month', net: bit.grdBit.dat })
      var mth = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input second', net: bit.grdBit.dat })
      var sec = bit.putBit.src;

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input year', net: bit.grdBit.dat })
      var yrs = bit.putBit.src;

      bit = await ste.hunt(ActTrm.CLEAR_TERMINAL, {})

      bit = await TIME.hunt(ActClk.WRITE_CLOCK, { idx, clk: { day, hrs, min, mth, sec, yrs } })
      clkIdx = bit.clkBit.dat.idx
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActClk.READ_CLOCK:
      bit = await TIME.hunt(ActClk.LIST_CLOCK, {})
      lst = bit.clkBit.lst

      if (lst.length == 0) {
        bit = await ste.hunt(ActCns.UPDATE_CONSOLE, { idx: 'cns00', src: "---no clock present" })
        break
      }

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
      bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })
      src = bit.chcBit.src;

      bit = await TIME.hunt(ActClk.READ_CLOCK, { idx: src })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActClk.LIST_CLOCK:
      bit = await TIME.hunt(ActClk.LIST_CLOCK, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => { bit = await ste.hunt(ActMnu.TIME_MENU, {}) }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

const path = require('path');

import { MenuModel } from "../../menu.model";
import MenuBit from "../../fce/menu.bit";
import State from "../../../99.core/state";
//import { HexmapModel } from "../../03.hexmap.unit/hexmap.model";


import * as ActSpc from "../../../act/space.action";

import * as Grid from '../../../val/grid';
import * as Align from '../../../val/align'
import * as Color from '../../../val/console-color';

import * as SHAPE from '../../../val/shape'
import * as FOCUS from "../../../val/focus";

import * as ActMnu from "../../menu.action";

//import * as ActPvt from "../../96.pivot.unit/pivot.action";

import * as ActTrm from "../../../80.terminal.unit/terminal.action";
import * as ActChc from "../../../85.choice.unit/choice.action";
import * as ActPut from "../../../84.input.unit/input.action";

import * as ActGrd from "../../../81.grid.unit/grid.action";
import * as ActCns from "../../../83.console.unit/console.action";

import * as ActFte from "../../../act/fate.action";
import * as ActSow from "../../../act/sower.action";
import * as ActSpk from "../../../act/spark.action";
import * as ActAmb from "../../../act/ambit.action";
import * as ActAvo from "../../../act/avaou.action";
import * as ActAvd from "../../../act/avide.action";
import * as ActArt from "../../../act/artes.action";
import * as ActPri from "../../../act/primal.action";
import * as ActBnd from "../../../act/bounded.action";
import * as ActPas from "../../../act/pastoral.action";
import * as ActBls from "../../../act/blessed.action";
import * as ActSup from "../../../act/supernal.action";

import * as ActClr from "../../../act/color.action";

var bit, lst, dex, idx, dat, src;

var SOWER;

var opened = false;

export const beingMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  SOWER = global.SOWER

  lst = [
    ActSup.WRITE_SUPERNAL,
    ActBls.WRITE_BLESSED,
    ActPas.WRITE_PASTORAL,
    ActBnd.WRITE_BOUNDED,
    ActPri.WRITE_PRIMAL,
    ActArt.WRITE_ARTES,
    ActAvd.WRITE_AVIDE,
    ActAvo.WRITE_AVAOU,
    ActAmb.WRITE_AMBIT,
    ActSpk.WRITE_SPARK,
    ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    
    case ActSup.WRITE_SUPERNAL:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input pastoral idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt( ActSup.WRITE_SUPERNAL, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    
    case ActBls.WRITE_BLESSED:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input pastoral idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt( ActBls.WRITE_BLESSED, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActPas.WRITE_PASTORAL:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input pastoral idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt( ActPas.WRITE_PASTORAL, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActBnd.WRITE_BOUNDED:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input bounded idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt( ActBnd.WRITE_BOUNDED, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActPri.WRITE_PRIMAL:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input primal idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt( ActPri.WRITE_PRIMAL, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActArt.WRITE_ARTES:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input artes idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt(ActArt.WRITE_ARTES, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActAvd.WRITE_AVIDE:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input avide idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt(ActAvd.WRITE_AVIDE, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActAvo.WRITE_AVAOU:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input avaou idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt(ActAvo.WRITE_AVAOU, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActAmb.WRITE_AMBIT:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input ambit idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt(ActAmb.WRITE_AMBIT, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActSpk.WRITE_SPARK:

      bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 2 })
      bit = await ste.hunt(ActPut.OPEN_INPUT, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, txt: 'input clock idx', net: bit.grdBit.dat })
      idx = bit.putBit.src;

      bit = await SOWER.hunt(ActSpk.WRITE_SPARK, { idx })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;


    case ActMnu.COLOR_MENU:
      bit = await ste.hunt(ActMnu.COLOR_MENU, {})
      //bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

      case ActMnu.FATE_MENU:
        bit = await ste.hunt(ActMnu.FATE_MENU, {})
        //bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
        break;

    case ActSow.INIT_SOWER:

      bit = await SOWER.hunt(ActSow.INIT_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSow.UPDATE_SOWER:
      bit = await SOWER.hunt(ActSow.UPDATE_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActSow.TEST_SOWER:
      bit = await SOWER.hunt(ActSow.TEST_SOWER, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.hunt(ActTrm.CLOSE_TERMINAL, {})
      break;
  }


  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.SOWER_MENU, {})

  }, 333)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });

import * as ActMnu from "../../menu.action";

import * as ActPxl from "../../../act/pixel.action";

import { MenuModel } from "../../menu.model";
import MenuBit from "../../fce/menu.bit";
import State from "../../../99.core/state";

import * as Grid from '../../../val/grid';
import * as Align from '../../../val/align'

import * as ActTrm from "../../../act/terminal.action";
import * as ActChc from "../../../act/choice.action";

import * as ActGrd from "../../../act/grid.action";

import * as ActClr from '../../../act/color.action'

import * as Color from '../../../val/console-color';

var bit, lst, dex, idx, dat, src;

var SOWER;

export const colorMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var FS = require('fs-extra')

  SOWER = global.SOWER;

  lst = [ActClr.BASKET_COLOR, ActClr.RANDOM_COLOR, ActClr.OPEN_COLOR, ActClr.LIST_COLOR, ActClr.UPDATE_COLOR, ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActClr.BASKET_COLOR:
      lst = FS.readJsonSync('./public/data/color/000.color.name.json')
      bit = await SOWER.hunt(ActClr.OPEN_COLOR, { lst })

      bit = await SOWER.hunt(ActClr.BASKET_COLOR, { dat: null })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)

      break;

    case ActClr.RANDOM_COLOR:
      lst = FS.readJsonSync('./public/data/color/000.color.name.json')
      bit = await SOWER.hunt(ActClr.OPEN_COLOR, { lst })

      bit = await SOWER.hunt(ActClr.RANDOM_COLOR, { dat: null })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)

      break;

    case ActClr.OPEN_COLOR:
      lst = FS.readJsonSync('./public/data/color/000.color.name.json')
      bit = await SOWER.hunt(ActClr.OPEN_COLOR, { lst })
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActClr.UPDATE_COLOR:
      bit = await SOWER.hunt(ActClr.UPDATE_COLOR, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActClr.LIST_COLOR:
      bit = await SOWER.hunt(ActClr.LIST_COLOR, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.bus(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.COLOR_MENU, {})

  }, 3)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });




import * as ActMnu from "../../menu.action";

import * as ActPxl from "../../../act/pixel.action";

import { MenuModel } from "../../menu.model";
import MenuBit from "../../fce/menu.bit";
import State from "../../../99.core/state";

import * as Grid from '../../../val/grid';
import * as Align from '../../../val/align'

import * as ActTrm from "../../../act/terminal.action";
import * as ActChc from "../../../act/choice.action";

import * as ActGrd from "../../../act/grid.action";

import * as ActClr from '../../../act/color.action'

import * as ActFte from "../../../act/fate.action";

import * as Color from '../../../val/console-color';

var bit, lst, dex, idx, dat, src;

var SOWER;

export const fateMenu = async (cpy: MenuModel, bal: MenuBit, ste: State) => {

  var FS = require('fs-extra')

  SOWER = global.SOWER;

  lst = [
    ActFte.SINE_FATE,
    ActFte.INTEGER_FATE,
    ActFte.SELECT_FATE,
    ActFte.APPLE_FATE,
    ActMnu.UPDATE_MENU]

  bit = await ste.hunt(ActGrd.UPDATE_GRID, { x: 0, y: 4, xSpan: 4, ySpan: 12 })
  bit = await ste.hunt(ActChc.OPEN_CHOICE, { dat: { clr0: Color.BLACK, clr1: Color.YELLOW }, src: Align.VERTICAL, lst, net: bit.grdBit.dat })

  src = bit.chcBit.src;

  switch (src) {

    case ActFte.SELECT_FATE:
      bit = await SOWER.hunt(ActFte.SELECT_FATE, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFte.INTEGER_FATE:
      bit = await SOWER.hunt(ActFte.INTEGER_FATE, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFte.APPLE_FATE:
      bit = await SOWER.hunt(ActFte.APPLE_FATE, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    case ActFte.SINE_FATE:

      //setInterval(async () => {

      bit = await SOWER.hunt(ActFte.SINE_FATE, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)

      //}, 33)

      break;


    case ActMnu.UPDATE_MENU:
      bit = await ste.hunt(ActMnu.UPDATE_MENU, {})
      bit = await ste.hunt(ActMnu.PRINT_MENU, bit)
      break;

    default:
      bit = await ste.bus(ActTrm.CLOSE_TERMINAL, {})
      break;
  }

  setTimeout(async () => {

    bit = await ste.hunt(ActMnu.FATE_MENU, {})

  }, 3)


  return cpy;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });





export default interface MenuBit {
    idx: string;
    src?: string;
    lst?: any;
    slv?: Function
}



import  MenuBit  from "./menu.bit";

export default interface Menu {
 // idx:string;
 // menuBitList: MenuBit[];
 // menuBits:any;

}

import { Action } from "../99.core/interface/action.interface";
import MenuBit from "./fce/menu.bit";

export const INIT_MENU = "[Menu action] Init Menu";
export class InitMenu implements Action {
  readonly type = INIT_MENU;
  constructor(public bale: MenuBit) { }
}

export const UPDATE_MENU = "[Menu action] Update Menu";
export class UpdateMenu implements Action {
  readonly type = UPDATE_MENU;
  constructor(public bale: MenuBit) { }
}

export const TEST_MENU = "[Menu action] Test Menu";
export class TestMenu implements Action {
  readonly type = TEST_MENU;
  constructor(public bale: MenuBit) { }
}

export const CLOSE_MENU = "[Menu action] Close Menu";
export class CloseMenu implements Action {
  readonly type = CLOSE_MENU;
  constructor(public bale: MenuBit) { }
}

export const GITHUB_MENU = "[Time action] Github Menu";
export class GithubMenu implements Action {
  readonly type = GITHUB_MENU;
  constructor(public bale: MenuBit) { }
}

export const SPACE_MENU = "[Menu action] Space Menu";
export class SpaceMenu implements Action {
  readonly type = SPACE_MENU;
  constructor(public bale: MenuBit) { }
}

export const CONTROL_MENU = "[Menu action] Control Menu";
export class ControlMenu implements Action {
  readonly type = CONTROL_MENU;
  constructor(public bale: MenuBit) { }
}

export const MARKET_MENU = "[Menu action] Market Menu";
export class MarketMenu implements Action {
  readonly type = MARKET_MENU;
  constructor(public bale: MenuBit) { }
}

export const SOWER_MENU = "[Menu action] Sower Menu";
export class SowerMenu implements Action {
  readonly type = SOWER_MENU;
  constructor(public bale: MenuBit) { }
}

export const EARTH_MENU = "[Menu action] Earth Menu";
export class EarthMenu implements Action {
  readonly type = EARTH_MENU;
  constructor(public bale: MenuBit) { }
}

export const OLLAMA_MENU = "[Menu action] OLLAMA Menu";
export class OllamaMenu implements Action {
  readonly type = OLLAMA_MENU;
  constructor(public bale: MenuBit) { }
}

export const TIME_MENU = "[Menu action] Time Menu";
export class TimeMenu implements Action {
  readonly type = TIME_MENU;
  constructor(public bale: MenuBit) { }
}

export const COLOR_MENU = "[Menu action] Color Menu";
export class ColorMenu implements Action {
  readonly type = COLOR_MENU;
  constructor(public bale: MenuBit) { }
}

export const FATE_MENU = "[Menu action] Fate Menu";
export class FateMenu implements Action {
  readonly type = FATE_MENU;
  constructor(public bale: MenuBit) { }
}

export const BEING_MENU = "[Menu action] Being Menu";
export class BeingMenu implements Action {
  readonly type = BEING_MENU;
  constructor(public bale: MenuBit) { }
}


export const UPDATE_FOCUS_PLAY_MENU = "[Focus action] Update Focus Play Menu";
export class UpdateFocusPlayMenu implements Action {
  readonly type = UPDATE_FOCUS_PLAY_MENU;
  constructor(public bale: MenuBit) { }
}

export const CREATE_MENU = "[Create action] Create Menu";
export class CreateMenu implements Action {
  readonly type = CREATE_MENU;
  constructor(public bale: MenuBit) { }
}

export const HEXMAP_MENU = "[Hexmap action] Hexmap Menu";
export class HexmapMenu implements Action {
  readonly type = HEXMAP_MENU;
  constructor(public bale: MenuBit) { }
}

export const CREATE_HEXMAP_MENU = "[Hexmap action] Create Hexmap Menu";
export class CreateHexmapMenu implements Action {
  readonly type = CREATE_HEXMAP_MENU;
  constructor(public bale: MenuBit) { }
}

export const RENDER_MENU = "[Render action] Render Menu";
export class RenderMenu implements Action {
  readonly type = RENDER_MENU;
  constructor(public bale: MenuBit) { }
}

export const YIELD_MENU = "[Render action] Yield Menu";
export class YieldMenu implements Action {
  readonly type = YIELD_MENU;
  constructor(public bale: MenuBit) { }
}


export const PRINT_MENU = "[Render action] Print Menu";
export class PrintMenu implements Action {
  readonly type = PRINT_MENU;
  constructor(public bale: MenuBit) { }
}



export type Actions = InitMenu | UpdateMenu | TestMenu | CloseMenu
  | GithubMenu
  | TimeMenu
  | CreateMenu
  | HexmapMenu
  | RenderMenu
  | CreateHexmapMenu
  | YieldMenu
  | ColorMenu
  | UpdateFocusPlayMenu
  | PrintMenu
  | SpaceMenu
  | ControlMenu
  | EarthMenu
  | SowerMenu
  | MarketMenu
  | FateMenu
  | OllamaMenu
  | BeingMenu
export { initMenu } from "./buz/00.menu.buzz";
export { updateMenu } from "./buz/00.menu.buzz";
export { testMenu } from "./buz/00.menu.buzz";
export { closeMenu } from "./buz/00.menu.buzz";
export { createMenu  } from "./buz/00.menu.buzz";
export { printMenu  } from "./buz/00.menu.buzz";
export { spaceMenu  } from "./buz/menu.space";
export { earthMenu  } from "./buz/menu.earth";
export { controlMenu  } from "./buz/menu.control";
export { sowerMenu  } from "./buz/menu.sower";
export { timeMenu  } from "./buz/menu.time";
export { marketMenu  } from "./buz/menu.market";
export { colorMenu  } from "./buz/sower/menu.color";
export { fateMenu  } from "./buz/sower/menu.fate";
export { beingMenu  } from "./buz/sower/menu.being";
export { ollamaMenu  } from "./buz/menu.ollama";


import Menu from "./fce/menu.interface";
import MenuBit from "./fce/menu.interface";

export class MenuModel implements Menu {
    lst: string[] = []

    geoJsonNow:any;
    atlasNow:any;
    sizeNow:any = 0;
    mapShape:string= 'none'
    mapNomNow:string= 'none'
    mapDimensions:string ='none'

    shapeBit:any;
}

import * as clone from "clone-deep";
import * as Act from "./menu.action";
import { MenuModel } from "./menu.model";
import * as Buzz from "./menu.buzzer";
import State from "../99.core/state";

export function reducer(model: MenuModel = new MenuModel(), act: Act.Actions, state?: State) {
  switch (act.type) {
    case Act.UPDATE_MENU:
      return Buzz.updateMenu(clone(model), act.bale, state);

    case Act.INIT_MENU:
      return Buzz.initMenu(clone(model), act.bale, state);

    case Act.TEST_MENU:
      return Buzz.testMenu(clone(model), act.bale, state);

    case Act.CLOSE_MENU:
      return Buzz.closeMenu(clone(model), act.bale, state);

    case Act.CREATE_MENU:
      return Buzz.createMenu(clone(model), act.bale, state);

    case Act.PRINT_MENU:
      return Buzz.printMenu(clone(model), act.bale, state);

    case Act.EARTH_MENU:
      return Buzz.earthMenu(clone(model), act.bale, state);

    case Act.SPACE_MENU:
      return Buzz.spaceMenu(clone(model), act.bale, state);

    case Act.CONTROL_MENU:
      return Buzz.controlMenu(clone(model), act.bale, state);

    case Act.SOWER_MENU:
      return Buzz.sowerMenu(clone(model), act.bale, state);

    case Act.MARKET_MENU:
      return Buzz.marketMenu(clone(model), act.bale, state);

    case Act.TIME_MENU:
      return Buzz.timeMenu(clone(model), act.bale, state);

    case Act.COLOR_MENU:
      return Buzz.colorMenu(clone(model), act.bale, state);

    case Act.FATE_MENU:
      return Buzz.fateMenu(clone(model), act.bale, state);

    case Act.OLLAMA_MENU:
      return Buzz.ollamaMenu(clone(model), act.bale, state);

    case Act.BEING_MENU:
      return Buzz.beingMenu(clone(model), act.bale, state);

    default:
      return model;
  }
}


import State from "../99.core/state";


export default class MenuUnit {

 constructor(state: State) {
 }
}

import { Action } from "../99.core/interface/action.interface";
import  BusBit  from "./fce/bus.bit";

// Bus actions

export const INIT_BUS = "[Bus action] Init Bus";
export class InitBus implements Action {
 readonly type = INIT_BUS;
 constructor(public bale: BusBit) {}
}

export const OPEN_BUS = "[Bus action] Open Bus";
export class OpenBus implements Action {
 readonly type = OPEN_BUS;
 constructor(public bale: BusBit) {}
}

export const CONNECT_BUS = "[Bus action] Connect Bus";
export class ConnectBus implements Action {
 readonly type = CONNECT_BUS;
 constructor(public bale: BusBit) {}
}

export const MESSAGE_BUS = "[Bus action] Message Bus";
export class MessageBus implements Action {
 readonly type = MESSAGE_BUS;
 constructor(public bale: BusBit) {}
}

export const UPDATE_BUS = "[Bus action] Update Bus";
export class UpdateBus implements Action {
 readonly type = UPDATE_BUS;
 constructor(public bale: BusBit) {}
}

export const CREATE_BUS = "[Bus action] Create Bus";
export class CreateBus implements Action {
 readonly type = CREATE_BUS;
 constructor(public bale: BusBit) {}
}

export type Actions = | InitBus | OpenBus | UpdateBus |ConnectBus |MessageBus | CreateBus;

export { initBus  } from "./buz/bus.buzz";
export { openBus  } from "./buz/bus.buzz";
export { updateBus  } from "./buz/bus.buzz";
export { connectBus  } from "./buz/bus.buzz";
export { messageBus  } from "./buz/bus.buzz";
export { createBus  } from "./buz/bus.buzz";

import Bus from "./fce/bus.interface";
import BusBit from "./fce/bus.interface";

export class BusModel implements Bus {
 MQTT:any;
 //idx:string;
 //busBitList: BusBit[] = [];
 //busBits: any = {};
 actList:any;
 client:any;
 host:string = "mqtt://localhost:1883";
 bus:Function;
 responseSuffix:string = '-response'
 promises:any = {}

}

import * as clone from "clone-deep";
import * as Act from "./bus.action";
import { BusModel } from "./bus.model";
import * as Buzz from "./bus.buzzer";
import State from "../99.core/state";

export function reducer(model: BusModel = new BusModel(), act: Act.Actions,  state?: State ) {
 switch (act.type) {
 
 case Act.UPDATE_BUS:
 return Buzz.updateBus(clone(model), act.bale, state);

 case Act.OPEN_BUS:
 return Buzz.openBus(clone(model), act.bale, state);

 case Act.CONNECT_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.CREATE_BUS:
 return Buzz.createBus(clone(model), act.bale, state);

 case Act.MESSAGE_BUS:
 return Buzz.connectBus(clone(model), act.bale, state);

 case Act.INIT_BUS:
 return Buzz.initBus(clone(model), act.bale, state);

 default:
 return model;
 }
}


import State from "../99.core/state";


export default class BusUnit {

 constructor(state: State) {
 }
}

import * as ActMnu from "../../98.menu.unit/menu.action";
import * as ActBus from "../../99.bus.unit/bus.action";
import * as ActCol from "../../97.collect.unit/collect.action";

var lst, idx, bit, src, dat, dex;

export const initBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  cpy.actList = []

  if (bal == null) bal = { idx: null }
  if (bal.lst == null) bal.lst = []

  if ((bal.src != null) && (bal.src.constructor == Array)) lst = bal.src;

  bal.lst.forEach((a) => {
    for (var key in a) {
      cpy.actList.push(a[key])
    }
  })

  ste.bus = (idx, dat, bit) => updateBus(cpy, { idx, dat, bit }, ste)

  if (bal.dat != null) {
    cpy.MQTT = bal.dat;
  }
  else {
    console.log("return promise")
  }

  if (lst == null) {

    if (bal.src != null) cpy.host = bal.src
    cpy.client = cpy.MQTT.connect(cpy.host);
    cpy.client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg }, ste) })
    cpy.client.on('connect', () => {

      console.log(bal.idx + " connected " + cpy.host)
      openBus(cpy, { idx: 'init-bus', lst: cpy.actList }, ste)
      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    })
  } else {

    var complete = (lst) => {
      lst.shift()

      if (lst.length != 0) return

      if (bal.slv != null) bal.slv({ intBit: { idx: "init-bus" } })
    }


    lst.forEach(async (a) => {


      bit = await ste.hunt(ActCol.WRITE_COLLECT, { idx: a.idx, src: a.src, bit: ActBus.CREATE_BUS })

      var client = bit.clcBit.dat;

      client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit: a.idx }, ste) })
      client.on('connect', () => {
        console.log(a.idx + " connected " + a.src)
        openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit: a.idx }, ste)
        complete(lst)
      })

    })
  }


  return cpy;
};

export const createBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var client = cpy.MQTT.connect(bal.src);
  if (bal.slv != null) bal.slv({ busBit: { idx: "create-bus", dat: client } });

  //client.on('message', (tpc, msg) => { messageBus(cpy, { idx: tpc, src: msg, bit:bal.idx }, ste) })
  //client.on('connect', () => {
  //console.log(bal.idx + " connected " + bal.src)
  //openBus(cpy, { idx: 'init-bus', lst: cpy.actList, bit:bal.idx }, ste)  
  //})

  return cpy;
}

export const openBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  var out = []

  bal.lst.forEach((a) => {
    if (a == null) return
    if (a.includes == null) return
    if (a.includes('[') && a.includes(']') == false) return
    out.push(a)
  })

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  out.forEach((a) => {

    client.subscribe(a, (err) => {

      if (!err) {
        console.log('subscribing ' + a)
      }
    })

  })



  return cpy;
};

export const connectBus = (cpy: BusModel, bal: BusBit, ste: State) => {

  var lst = []
  if (bal.val == 1) patch(ste, ActMnu.INIT_MENU, { lst })
}

export const messageBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  if (bal.src != null) dat = bal.src.toString()

  idx = bal.idx
  dat = JSON.parse(dat)

  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if (idx.includes(cpy.responseSuffix) == true) {

    var responseIDX = bal.idx;
    var obj = cpy.promises[responseIDX];

    if (obj.slv != null) obj.slv(dat);

    client.unsubscribe(responseIDX, (err) => {
      if (!err) {
        //console.log('hitting ' + responseIDX)
      }
    })

  } else {
    var bit = await ste.hunt(idx, dat)
    var cloneBit = clone(bit)

    for (var key in cloneBit) {

      var itm = cloneBit[key]
      if (itm.dat != null) {
        if (itm.dat.bit != null) itm.dat.bit = null
      }
    }

    cloneBit
    
    client.publish(bal.idx + cpy.responseSuffix, JSON.stringify( cloneBit ))
  }

  return cpy;
};


//has to return a promise
export const updateBus = async (cpy: BusModel, bal: BusBit, ste: State) => {


  //how does one create an error message here when bit should be used
  var client = cpy.client;

  if (bal.bit != null) {
    bit = await ste.hunt(ActCol.READ_COLLECT, { idx: bal.bit, bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  if ((client == null) && (bal.bit == null)) {
    bit = await ste.hunt(ActCol.FETCH_COLLECT, { bit: ActBus.CREATE_BUS })
    client = bit.clcBit.dat
  }

  var responseIDX = bal.idx + cpy.responseSuffix;

  var slv;
  const promo = new Promise((rslv, rjct) => (slv = rslv));

  var obj = { slv: (val0) => slv(val0) };

  cpy.promises[responseIDX] = obj

  client.subscribe(responseIDX, (err) => {
    if (!err) {
      //console.log('hitting ' + responseIDX)
    }
  })

  //03.10.23
  //bit throws errors since sometimes it is not a primitive
  //if (bal.dat == null) bal.dat = {}
  //if (bal.dat.bit != null) bal.dat.bit = null;

  client.publish(bal.idx, JSON.stringify(bal.dat))

  return promo;
};


var patch = (ste, type, bale) => ste.dispatch({ type, bale });


import { BusModel } from "../bus.model";
import BusBit from "../fce/bus.bit";
import State from "../../99.core/state";
import S from "string";
import * as clone from "clone-deep";

export default interface BusBit {
 idx:string;
 val?:number;
 lst?:any;
 src?:any;
 bit?:string;
 slv?:Function;
 dat?:any;
}


import  BusBit  from "./bus.bit";

export default interface Bus {
 // idx:string;
 // busBitList: BusBit[];
 // busBits:any;

}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=action.interface.js.map
export interface Action<T = any> {
  type: string;
  bale?: T;
}

"use strict";
exports.__esModule = true;
//# sourceMappingURL=model.interface.js.map
export default interface Model {}

"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
var rx_lite_1 = require("rx-lite");
var rx_lite_2 = require("rx-lite");
var BEE_1 = __importDefault(require("../BEE"));
var Effect = __importStar(require("../BEE"));
var State = /** @class */ (function (_super) {
    __extends(State, _super);
    function State(init) {
        if (init === void 0) { init = new BEE_1["default"](); }
        var _this = _super.call(this, init) || this;
        _this.dispatcher = new rx_lite_2.Subject();
        _this.dispatcher
            .scan(function (state, action) { return _this.reducedApp(state, action); }, init)
            .subscribe(function (state) {
            _super.prototype.onNext.call(_this, state);
        });
        return _this;
    }
    State.prototype.reducedApp = function (nextState, key) {
        for (var k in Effect.reducer)
            Effect.reducer[k](nextState[k], key, this);
        return nextState;
    };
    State.prototype.dispatch = function (value) {
        var result = this.dispatcher.onNext(value);
        return result;
    };
    State.prototype.pat = function (value) {
        this.dispatch(value);
    };
    State.prototype.next = function (value) {
        this.dispatcher.onNext(value);
    };
    return State;
}(rx_lite_1.BehaviorSubject));
exports["default"] = State;
//# sourceMappingURL=state.js.map
import { BehaviorSubject } from "rx-lite";
import { Subject } from "rx-lite";
import { Action } from "./interface/action.interface";

import UnitModel from "../BEE";
import * as Effect from "../BEE";

export default class State extends BehaviorSubject<any> {
  public hunt: any;
  public value: any;
  public pivot:  any;
  public bus: any;

  private dispatcher: Subject = new Subject();

  constructor(init: UnitModel = new UnitModel()) {
    super(init);

    this.dispatcher
      .scan((state, action) => this.reducedApp(state, action), init)
      .subscribe((state) => {
        super.onNext(state);
      });
  }

  reducedApp(nextState: any, key: any) {
    for (var k in Effect.reducer) Effect.reducer[k](nextState[k], key, this);
    return nextState;
  }

  dispatch(value: Action) {
    var result = this.dispatcher.onNext(value);
    return result;
  }
  
  pat(value: Action) {
    this.dispatch(value);
  }

  next(value: any) {
    this.dispatcher.onNext(value);
  }
}

export const INIT_AMBIT = "[Ambit action] Init Ambit";
export const UPDATE_AMBIT = "[Ambit action] Update Ambit";
export const READ_AMBIT = "[Read action] Read Ambit";
export const WRITE_AMBIT = "[Write action] Write Ambit";
export const REMOVE_AMBIT = "[Remove action] Remove Ambit";
export const DELETE_AMBIT = "[Delete action] Delete Ambit";
export const CREATE_AMBIT = "[Create action] Create Ambit";
export const INIT_APPLICATION = "[Application action] Init Application";
export const UPDATE_APPLICATION = "[Application action] Update Application";
export const READ_APPLICATION = "[Read action] Read Application";
export const WRITE_APPLICATION = "[Write action] Write Application";
export const REMOVE_APPLICATION = "[Remove action] Remove Application";
export const DELETE_APPLICATION = "[Delete action] Delete Application";
export const CREATE_APPLICATION = "[Create action] Create Application";
export const TEST_APPLICATION = "[Test action] Test Application";
export const INIT_ARTES = "[Artes action] Init Artes";
export const UPDATE_ARTES = "[Artes action] Update Artes";
export const READ_ARTES = "[Read action] Read Artes";
export const WRITE_ARTES = "[Write action] Write Artes";
export const REMOVE_ARTES = "[Remove action] Remove Artes";
export const DELETE_ARTES = "[Delete action] Delete Artes";
export const CREATE_ARTES = "[Create action] Create Artes";
export const INIT_AVAOU = "[Avaou action] Init Avaou";
export const UPDATE_AVAOU = "[Avaou action] Update Avaou";
export const READ_AVAOU = "[Read action] Read Avaou";
export const WRITE_AVAOU = "[Write action] Write Avaou";
export const REMOVE_AVAOU = "[Remove action] Remove Avaou";
export const DELETE_AVAOU = "[Delete action] Delete Avaou";
export const CREATE_AVAOU = "[Create action] Create Avaou";
export const INIT_AVIDE = "[Avide action] Init Avide";
export const UPDATE_AVIDE = "[Avide action] Update Avide";
export const READ_AVIDE = "[Read action] Read Avide";
export const WRITE_AVIDE = "[Write action] Write Avide";
export const REMOVE_AVIDE = "[Remove action] Remove Avide";
export const DELETE_AVIDE = "[Delete action] Delete Avide";
export const CREATE_AVIDE = "[Create action] Create Avide";
export const INIT_BABYLON = "[Babylon action] Init Babylon";
export const UPDATE_BABYLON = "[Babylon action] Update Babylon";
export const OPEN_BABYLON = "[Babylon action] Open Babylon";
export const RECORD_BABYLON = "[Babylon action] Record Babylon";
export const ACTION_BABYLON = "[Babylon action] Action Babylon";
export const CUT_BABYLON = "[Babylon action] Cut Babylon";
export const CAMERA_BABYLON = "[Babylon action] Cut Babylon";
export const INIT_BLESSED = "[Blessed action] Init Blessed";
export const UPDATE_BLESSED = "[Blessed action] Update Blessed";
export const READ_BLESSED = "[Read action] Read Blessed";
export const WRITE_BLESSED = "[Write action] Write Blessed";
export const REMOVE_BLESSED = "[Remove action] Remove Blessed";
export const DELETE_BLESSED = "[Delete action] Delete Blessed";
export const CREATE_BLESSED = "[Create action] Create Blessed";
export const INIT_BOUNDED = "[Bounded action] Init Bounded";
export const UPDATE_BOUNDED = "[Bounded action] Update Bounded";
export const READ_BOUNDED = "[Read action] Read Bounded";
export const WRITE_BOUNDED = "[Write action] Write Bounded";
export const REMOVE_BOUNDED = "[Remove action] Remove Bounded";
export const DELETE_BOUNDED = "[Delete action] Delete Bounded";
export const CREATE_BOUNDED = "[Create action] Create Bounded";
export const INIT_CAMERA = "[Camera action] Init Camera";
export const UPDATE_CAMERA = "[Camera action] Update Camera";
export const READ_CAMERA = "[Read action] Read Camera";
export const WRITE_CAMERA = "[Write action] Write Camera";
export const REMOVE_CAMERA = "[Remove action] Remove Camera";
export const DELETE_CAMERA = "[Delete action] Delete Camera";
export const CREATE_CAMERA = "[Create action] Create Camera";
export const INIT_CANVAS = "[Canvas action] Init Canvas";
export const UPDATE_CANVAS = "[Canvas action] Update Canvas";
export const READ_CANVAS = "[Read action] Read Canvas";
export const WRITE_CANVAS = "[Write action] Write Canvas";
export const DELETE_CANVAS = "[Delete action] Delete Canvas";
export const REMOVE_CANVAS = "[Remove action] Remove Canvas";
export const CREATE_CANVAS = "[Create action] Create Canvas";
export const NEST_CANVAS = "[Nest action] Nest Canvas";
export const INIT_CARDANO = "[Cardano action] Init Cardano";
export const UPDATE_CARDANO = "[Cardano action] Update Cardano";
export const TEST_CARDANO = "[Test action] Test Cardano";
export const INIT_CHOICE = "[Choice action] Init Choice";
export const UPDATE_CHOICE = "[Choice action] Update Choice";
export const OPEN_CHOICE = "[Open action] Open Choice";
export const KEY_CHOICE = "[Key action] Key Choice";
export const TOWER_CHOICE = "[Tower action] Tower Choice";

export const INIT_CLOCK = "[Clock action] Init Clock";
export const UPDATE_CLOCK = "[Clock action] Update Clock";
export const READ_CLOCK = "[Read action] Read Clock";
export const WRITE_CLOCK = "[Write action] Write Clock";
export const REMOVE_CLOCK = "[Remove action] Remove Clock";
export const CREATE_CLOCK = "[Create action] Create Clock";
export const DELETE_CLOCK = "[Delete action] Delete Clock";
export const BLOCK_CLOCK = "[Block action] Block Clock";
export const LIST_CLOCK = "[List action] List Clock";
export const TEST_CLOCK = "[Test action] Test Clock";
export const INIT_COLOR = "[Color action] Init Color";
export const UPDATE_COLOR = "[Color action] Update Color";
export const OPEN_COLOR = "[Open action] Open Color";
export const READ_COLOR = "[Read action] Read Color";
export const WRITE_COLOR = "[Write action] Write Color";
export const REMOVE_COLOR = "[Remove action] Remove Color";
export const DELETE_COLOR = "[Delete action] Delete Color";
export const CREATE_COLOR = "[Create action] Create Color";
export const LIST_COLOR = "[List action] List Color";
export const RANDOM_COLOR = "[Random action] Random Color";
export const BASKET_COLOR = "[Basket action] Basket Color";
export const ACCESS_COLOR = "[Access action] Access Color";
export const INIT_CONSOLE = "[Console action] Init Console";
export const UPDATE_CONSOLE = "[Console action] Update Console";
export const READ_CONSOLE = "[Read action] Read Console";
export const WRITE_CONSOLE = "[Write action] Write Console";
export const REMOVE_CONSOLE = "[Remove action] Remove Console";
export const DELETE_CONSOLE = "[Delete action] Delete Console";
export const CREATE_CONSOLE = "[Create action] Create Console";
export const INIT_CONTAINER = "[Container action] Init Container";
export const UPDATE_CONTAINER = "[Container action] Update Container";
export const READ_CONTAINER = "[Read action] Read Container";
export const WRITE_CONTAINER = "[Write action] Write Container";
export const CREATE_CONTAINER = "[Create action] Create Container";
export const SURFACE_CONTAINER = "[Surface action] Surface Container";
export const ADD_CONTAINER = "[Add action] Add Container";
export const REMOVE_CONTAINER = "[Remove action] Remove Container";
export const DELETE_CONTAINER = "[Delete action] Delete Container";
export const LIST_CONTAINER = "[List action] List Container";
export const INIT_CONTROL = "[Control action] Init Control";
export const UPDATE_CONTROL = "[Control action] Update Control";
export const OPEN_CONTROL = "[Open action] Open Control";
export const CREATE_CONTROL = "[Create action] Create Control";
export const TEST_CONTROL = "[Test action] Test Control";
export const ACCESS_CONTROL = "[Access action] Access Control";
export const OUTPUT_CONTROL = "[Output action] Output Control";
export const ADVANCE_CONTROL = "[Advance action] Advance Control";
export const INCREMENT_CONTROL = "[Increment action] Increment Control";
 export const DATA_CONTROL = "[Control action] Data Control";
export const INIT_DIFFUSION = "[Diffusion action] Init Diffusion";
export const UPDATE_DIFFUSION = "[Diffusion action] Update Diffusion";

export const INIT_DISK = '[Disk action] Init Disk'
export const UPDATE_DISK = '[Disk action] Update Disk'
export const READ_DISK = '[Disk action] Read Disk'
export const WRITE_DISK = '[Disk action] Write Disk'
export const INDEX_DISK = '[Index action] Index Disk'
export const LOAD_LIST_DISK = '[Load_list action] Load_list Disk'
export const COPY_DISK = '[Copy action] Copy Disk'
export const FRAME_DISK = '[Frame action] Frame Disk'
export const BATCH_DISK = '[Batch action] Batch Disk'
export const TRASH_DISK = '[Trash action] Trash Disk'
export const ENSURE_DISK = '[Ensure action] Ensure Disk'
export const DELETE_DISK = '[Delete action] Delete Disk'
export const INIT_EARTH = "[Earth action] Init Earth";
export const OPEN_EARTH = "[Earth action] Open Earth";
export const UPDATE_EARTH = "[Earth action] Update Earth";
export const ADVANCE_EARTH = "[Advance action] Advance Earth";
export const OUTPUT_EARTH = "[Output action] Output Earth";
export const ACCESS_EARTH = "[Access action] Access Earth";
export const INIT_FATE = "[Fate action] Init Fate";
export const UPDATE_FATE = "[Fate action] Update Fate";
export const INTEGER_FATE = "[Fate action] Integer Fate";
export const APPLE_FATE = "[Fate action] Apple Fate";
export const SINE_FATE = "[Sine action] Sine Fate";
export const SELECT_FATE = "[Select action] Select Fate";
export const INIT_FOCIGON = "[Focigon action] Init Focigon";
export const UPDATE_FOCIGON = "[Focigon action] Update Focigon";
export const READ_FOCIGON = "[Read action] Read Focigon";
export const WRITE_FOCIGON = "[Write action] Write Focigon";
export const REMOVE_FOCIGON = "[Remove action] Remove Focigon";
export const CREATE_FOCIGON = "[Create action] Create Focigon";
export const DELETE_FOCIGON = "[Delete action] Delete Focigon";
export const INIT_FOCUS = "[Focus action] Init Focus";
export const AWAKE_FOCUS = "[Focus action] Awake Focus";
export const UPDATE_FOCUS = "[Focus action] Update Focus";
export const OPEN_FOCUS = "[Focus action] Open Focus";
export const CREATE_FOCUS = "[Focus action] Create Focus";
export const READ_FOCUS = "[Read action] Read Focus";
export const WRITE_FOCUS = "[Write action] Write Focus";
export const REMOVE_FOCUS = "[Remove action] Remove Focus";
export const DELETE_FOCUS = "[Delete action] Delete Focus";
export const CORNER_FOCUS = "[Corner action] Corner Focus";
export const LIST_FOCUS = "[List action] List Focus";
 export const SPIN_RIGHT_FOCUS = "[List action] Spin Left Focus";
 export const SPIN_LEFT_FOCUS = "[List action] Spin Right Focus";
 export const FORWARD_FOCUS = "[List action] Forward Focus";
 export const BACKWARD_FOCUS = "[List action] Backward Focus";
 export const CENTER_FOCUS = "[List action] Center Focus";
export const BOND_FOCUS = "[Bond action] Bond Focus";
export const LOCATE_FOCUS = "[Locate action] Locate Focus";
export const VISION_FOCUS = "[Vision action] Vision Focus";
export const SELECT_FOCUS = "[Select action] Select Focus";
 export const MODEL_FOCUS = "[Select action] Model Focus";
 export const BROWNIAN_FOCUS = "[Select action] Brownian Focus";
export const INIT_FRAME = "[Frame action] Init Frame";
export const UPDATE_FRAME = "[Frame action] Update Frame";
export const READ_FRAME = "[Read action] Read Frame";
export const WRITE_FRAME = "[Write action] Write Frame";
export const REMOVE_FRAME = "[Remove action] Remove Frame";
export const CREATE_FRAME = "[Create action] Create Frame";
export const DELETE_FRAME = "[Delete action] Delete Frame";
export const INIT_GRAPHIC = "[Graphic action] Init Graphic";
export const UPDATE_GRAPHIC = "[Graphic action] Update Graphic";
export const READ_GRAPHIC = "[Read action] Read Graphic";
export const WRITE_GRAPHIC = "[Write action] Write Graphic";
export const CREATE_GRAPHIC = "[Create action] Create Graphic";
export const REMOVE_GRAPHIC = "[Remove action] Remove Graphic";
export const DELETE_GRAPHIC = "[Delete action] Delete Graphic";
export const INIT_GRID = "[Grid action] Init Grid";
export const UPDATE_GRID = "[Grid action] Update Grid";

export const INIT_HEXAGON = "[Hexagon action] Init Hexagon";
export const UPDATE_HEXAGON = "[Hexagon action] Update Hexagon";
export const READ_HEXAGON = "[Read action] Read Hexagon";
export const WRITE_HEXAGON = "[Write action] Write Hexagon";
export const CREATE_HEXAGON = "[Create action] Create Hexagon";
export const REMOVE_HEXAGON = "[Replace action] Remove Hexagon";
export const DELETE_HEXAGON = "[Delete action] Delete Hexagon";
export const FOCUS_HEXAGON = "[Focus action] Focus Hexagon";
export const HEXMAP_HEXAGON = "[Hexmap action] Hexmap Hexagon";
export const INIT_HEXMAP = "[Hexmap action] Init Hexmap";
export const UPDATE_HEXMAP = "[Hexmap action] Update Hexmap";
export const OPEN_HEXMAP = "[Hexmap action] Open Hexmap";
export const READ_HEXMAP = "[Read action] Read Hexmap";
export const WRITE_HEXMAP = "[Write action] Write Hexmap";
export const CREATE_HEXMAP = "[Create action] Create Hexmap";
export const COPY_HEXMAP = "[Copy action] Copy Hexmap";
export const ATLAS_HEXMAP = "[Atlas action] Atlas Hexmap";
export const GEOJSON_HEXMAP = "[Geojson action] Geojson Hexmap";
export const TOOL_HEXMAP = "[Tool action] Tool Hexmap";
export const SAVE_HEXMAP = "[Save action] Save Hexmap";
export const STORE_HEXMAP = "[Store action] Store Hexmap";
export const SHAPE_HEXMAP = "[Shape action] Shape Hexmap";
export const LOAD_HEXMAP = "[Load action] Load Hexmap";
export const LIST_HEXMAP = "[List action] List Hexmap";
export const REPLACE_HEXMAP = "[Replace action] Replace Hexmap";
export const NAME_HEXMAP = "[Name action] Name Hexmap";
export const SEEK_HEXMAP = "[Seek action] Seek Hexmap";
export const FOCUSING_HEXMAP = "[Focusing action] Focusing Hexmap";
export const DEFOCUS_HEXMAP = "[Defocus action] Defocus Hexmap";
export const SELECT_HEXMAP = "[Select action] Select Hexmap";
export const ADD_HEXMAP = "[Select action] Add Hexmap";
export const POUCH_HEXMAP = "[Select action] Pouch Hexmap";
export const INIT_INCREMENT = "[Increment action] Init Increment";
export const UPDATE_INCREMENT = "[Increment action] Update Increment";
export const READ_INCREMENT = "[Read action] Read Increment";
export const WRITE_INCREMENT = "[Write action] Write Increment";
export const REMOVE_INCREMENT = "[Remove action] Remove Increment";
export const DELETE_INCREMENT = "[Delete action] Delete Increment";
export const CREATE_INCREMENT = "[Create action] Create Increment";
export const LIST_INCREMENT = "[List action] List Increment";
export const INIT_INPUT = "[Input action] Init Input";
export const UPDATE_INPUT = "[Input action] Update Input";
export const OPEN_INPUT = "[Open action] Open Input";
export const INIT_MARKET = "[Market action] Init Market";
export const UPDATE_MARKET = "[Market action] Update Market";
export const INIT_MIKU = "[Miku action] Init Miku";
export const UPDATE_MIKU = "[Miku action] Update Miku";
export const READ_MIKU = "[Miku action] Read Miku";
export const WRITE_MIKU = "[Miku action] Write Miku";
export const DELETE_MIKU = "[Miku action] Delete Miku";
export const REMOVE_MIKU = "[Miku action] Remove Miku";
export const CREATE_MIKU = "[Miku action] Create Miku";
export const INIT_PASTORAL = "[Pastoral action] Init Pastoral";
export const UPDATE_PASTORAL = "[Pastoral action] Update Pastoral";
export const READ_PASTORAL = "[Read action] Read Pastoral";
export const WRITE_PASTORAL = "[Write action] Write Pastoral";
export const REMOVE_PASTORAL = "[Remove action] Remove Pastoral";
export const DELETE_PASTORAL = "[Delete action] Delete Pastoral";
export const CREATE_PASTORAL = "[Create action] Create Pastoral";
export const INIT_PIVOT = "[Pivot action] Init Pivot";
export const UPDATE_PIVOT = "[Pivot action] Update Pivot";
export const OPEN_PIVOT = "[Open action] Open Pivot";
export const RUN_PIVOT = "[Run action] Run Pivot";
export const EDIT_PIVOT = "[Edit action] Edit Pivot";
export const PATCH_PIVOT = "[Patch action] Patch Pivot";
export const COUNT_PIVOT = "[Patch action] Count Pivot";
export const LIST_PIVOT = "[Patch action] List Pivot";
export const CREATE_PIVOT = "[Patch action] Create Pivot";
export const CONTAINS_PIVOT = "[Patch action] Contains Pivot";
export const BUNDLE_PIVOT = "[Patch action] Bundle Pivot";
export const REPLACE_PIVOT = "[Patch action] Replace Pivot";
export const SHIP_PIVOT = "[Patch action] Ship Pivot";

export const INIT_PIXEL = "[Pixel action] Init Pixel";
export const UPDATE_PIXEL = "[Pixel action] Update Pixel";
export const OPEN_PIXEL = "[Open action] Open Pixel";
export const PROCESS_PIXEL = "[Process action] Process Pixel";
export const COLOR_PIXEL = "[Color action] Color Pixel";
export const BUILD_PIXEL = "[Build action] Build Pixel";
export const WRITE_PIXEL = "[Write action] Write Pixel";
export const READ_PIXEL = "[Read action] Read Pixel";
export const PALETTE_PIXEL = "[Read action] Palette Pixel";
export const BATCH_PIXEL = "[Batch action] Batch Pixel";
export const FRAME_PIXEL = "[Frame action] Frame Pixel";
export const CHROMA_PIXEL = "[Chroma action] Chroma Pixel";
export const SORT_PIXEL = "[Chroma action] Sort Pixel";
export const TEST_PIXEL = "[Test action] Test Pixel";

export const INIT_PRIMAL = "[Primal action] Init Primal";
export const UPDATE_PRIMAL = "[Primal action] Update Primal";
export const READ_PRIMAL = "[Read action] Read Primal";
export const WRITE_PRIMAL = "[Write action] Write Primal";
export const REMOVE_PRIMAL = "[Remove action] Remove Primal";
export const DELETE_PRIMAL = "[Delete action] Delete Primal";
export const CREATE_PRIMAL = "[Create action] Create Primal";
export const INIT_PROGRESS = "[Progress action] Init Progress";
export const UPDATE_PROGRESS = "[Progress action] Update Progress";
export const INIT_RENPY = "[Renpy action] Init Renpy";
export const UPDATE_RENPY = "[Renpy action] Update Renpy";
export const OPEN_RENPY = "[Renpy action] Open Renpy";

export const INIT_SCREEN = "[Screen action] Init Screen";
export const UPDATE_SCREEN = "[Screen action] Update Screen";
export const READ_SCREEN = "[Read action] Read Screen";
export const WRITE_SCREEN = "[Write action] Write Screen";
export const REMOVE_SCREEN = "[Remove action] Remove Screen";
export const DELETE_SCREEN = "[Delete action] Delete Screen";
export const CREATE_SCREEN = "[Create action] Create Screen";
export const INIT_SHINY = "[Shiny action] Init Shiny";
export const UPDATE_SHINY = "[Shiny action] Update Shiny";
export const OPEN_SHINY = "[Shiny action] Open Shiny";

export const INIT_SOWER = "[Sower action] Init Sower";
export const UPDATE_SOWER = "[Sower action] Update Sower";
export const DEV_SOWER = "[Dev action] Dev Sower";
export const OPEN_SOWER = "[Open action] Open Sower";
export const TEST_SOWER = "[Test action] Test Sower";
export const INIT_SPACE = "[Space action] Init Space";
export const UPDATE_SPACE = "[Space action] Update Space";
export const TEST_SPACE = "[Test action] Test Space";
export const INIT_SPARK = "[Spark action] Init Spark";
export const UPDATE_SPARK = "[Spark action] Update Spark";
export const READ_SPARK = "[Read action] Read Spark";
export const WRITE_SPARK = "[Write action] Write Spark";
export const REMOVE_SPARK = "[Remove action] Remove Spark";
export const DELETE_SPARK = "[Delete action] Delete Spark";
export const CREATE_SPARK = "[Create action] Create Spark";
export const INIT_SUPERNAL = "[Supernal action] Init Supernal";
export const UPDATE_SUPERNAL = "[Supernal action] Update Supernal";
export const READ_SUPERNAL = "[Read action] Read Supernal";
export const WRITE_SUPERNAL = "[Write action] Write Supernal";
export const REMOVE_SUPERNAL = "[Remove action] Remove Supernal";
export const DELETE_SUPERNAL = "[Delete action] Delete Supernal";
export const CREATE_SUPERNAL = "[Create action] Create Supernal";
// Terminal actions
export const INIT_TERMINAL = "[Terminal action] Init Terminal";
export const UPDATE_TERMINAL = "[Terminal action] Update Terminal";
export const RUN_TERMINAL = "[Run action] Run Terminal";
export const EDIT_TERMINAL = "[Edit action] Edit Terminal"; 
export const PRINT_TERMINAL = "[Print action] Print Terminal";
export const CLOSE_TERMINAL = "[Close action] Close Terminal";
export const OPTION_TERMINAL = "[Option action] Option Terminal";
export const INPUT_TERMINAL = "[Input action] Input Terminal"; 
export const LAYOUT_TERMINAL = "[Layout action] Layout Terminal";
export const OPEN_TERMINAL = "[Layout action] Open Terminal";
export const CLEAR_TERMINAL = "[Layout action] Clear Terminal";

export const INIT_TEXT = "[Text action] Init Text";
export const UPDATE_TEXT = "[Text action] Update Text";
export const READ_TEXT = "[Read action] Read Text";
export const WRITE_TEXT = "[Write action] Write Text";
export const CREATE_TEXT = "[Create action] Create Text";
export const REMOVE_TEXT = "[Remove action] Remove Text";
export const DELETE_TEXT = "[Delete action] Delete Text";
export const LIST_TEXT = "[List action] List Text";
export const INIT_TIME = "[Time action] Init Time";
export const UPDATE_TIME = "[Time action] Update Time";
 export const TEST_TIME = "[Reduce action] Test Time";
export const RANDOM_TIME = "[Random action] Random Time";
export const INIT_TURN = "[Turn action] Init Turn";
export const UPDATE_TURN = "[Turn action] Update Turn";
export const OPEN_TURN = "[Open action] Open Turn";
export const READ_TURN = "[Read action] Read Turn";
export const START_TURN = "[Start action] Start Turn";
export const INIT_VISAGE = "[Visage action] Init Visage";
export const UPDATE_VISAGE = "[Visage action] Update Visage";
export const FULLSCREEN_VISAGE = "[Fullscreen action] Fullscreen Visage"; 
export const READ_VISAGE = "[Read action] Read Visage";
export const WRITE_VISAGE = "[Write action] Write Visage"; 
export const CREATE_VISAGE = "[Create action] Create Visage";
export const SIZE_VISAGE = "[Size action] Size Visage";
export const RENDER_VISAGE = "[Render action] Render Visage";
export const INIT_VURT = "[Vurt action] Init Vurt";
export const DELAY_VURT = "[Vurt action] Delay Vurt";
export const TEST_CLOUD_VURT = "[Vurt action] Test Cloud Vurt";
export const FETCH_VURT = "[Vurt action] Fetch Vurt";
export const UPDATE_VURT = "[Vurt action] Update Vurt";
export const REPLACE_VURT = "[Vurt action] Replace Vurt";
export const UNIT_VURT = "[Vurt action] Unit Vurt";
export const COUNT_VURT = "[Vurt action] Count Vurt";
export const LIST_PIVOT_VURT = "[Vurt action] List Pivot Vurt";
export const LIST_UNIT_VURT = "[Vurt action] List Unit Vurt";
export const CONTAINS_VURT = "[Contains action] Contains Vurt";
export const BUNDLE_VURT = "[Bundle action] Bundle Vurt";
export const VALUE_VURT = "[Value action] Value Vurt";
import Model from "./99.core/interface/model.interface";

import LibraryUnit from "./00.library.unit/library.unit";
import UnitUnit from "./01.unit.unit/unit.unit";
import ActionUnit from "./02.action.unit/action.unit";
import DataUnit from "./03.data.unit/data.unit";
import ServerUnit from "./04.server.unit/server.unit";
import OllamaUnit from "./10.ollama.unit/ollama.unit";
import PromptUnit from "./12.prompt.unit/prompt.unit";
import AuthorUnit from "./13.author.unit/author.unit";
import GenreUnit from "./14.genre.unit/genre.unit";
import SettingUnit from "./15.setting.unit/setting.unit";
import CodexUnit from "./20.codex.unit/codex.unit";
import TerminalUnit from "./80.terminal.unit/terminal.unit";
import GridUnit from "./81.grid.unit/grid.unit";
import ConsoleUnit from "./83.console.unit/console.unit";
import InputUnit from "./84.input.unit/input.unit";
import ChoiceUnit from "./85.choice.unit/choice.unit";
import CollectUnit from "./97.collect.unit/collect.unit";
import MenuUnit from "./98.menu.unit/menu.unit";
import BusUnit from "./99.bus.unit/bus.unit";


import Library from "./00.library.unit/fce/library.interface";
import { LibraryModel } from "./00.library.unit/library.model";
import Unit from "./01.unit.unit/fce/unit.interface";
import { UnitModel } from "./01.unit.unit/unit.model";
import Action from "./02.action.unit/fce/action.interface";
import { ActionModel } from "./02.action.unit/action.model";
import Data from "./03.data.unit/fce/data.interface";
import { DataModel } from "./03.data.unit/data.model";
import Server from "./04.server.unit/fce/server.interface";
import { ServerModel } from "./04.server.unit/server.model";
import Ollama from "./10.ollama.unit/fce/ollama.interface";
import { OllamaModel } from "./10.ollama.unit/ollama.model";
import Prompt from "./12.prompt.unit/fce/prompt.interface";
import { PromptModel } from "./12.prompt.unit/prompt.model";
import Author from "./13.author.unit/fce/author.interface";
import { AuthorModel } from "./13.author.unit/author.model";
import Genre from "./14.genre.unit/fce/genre.interface";
import { GenreModel } from "./14.genre.unit/genre.model";
import Setting from "./15.setting.unit/fce/setting.interface";
import { SettingModel } from "./15.setting.unit/setting.model";
import Codex from "./20.codex.unit/fce/codex.interface";
import { CodexModel } from "./20.codex.unit/codex.model";
import Terminal from "./80.terminal.unit/fce/terminal.interface";
import { TerminalModel } from "./80.terminal.unit/terminal.model";
import Grid from "./81.grid.unit/fce/grid.interface";
import { GridModel } from "./81.grid.unit/grid.model";
import Console from "./83.console.unit/fce/console.interface";
import { ConsoleModel } from "./83.console.unit/console.model";
import Input from "./84.input.unit/fce/input.interface";
import { InputModel } from "./84.input.unit/input.model";
import Choice from "./85.choice.unit/fce/choice.interface";
import { ChoiceModel } from "./85.choice.unit/choice.model";
import Collect from "./97.collect.unit/fce/collect.interface";
import { CollectModel } from "./97.collect.unit/collect.model";
import Menu from "./98.menu.unit/fce/menu.interface";
import { MenuModel } from "./98.menu.unit/menu.model";
import Bus from "./99.bus.unit/fce/bus.interface";
import { BusModel } from "./99.bus.unit/bus.model";


export const list: Array<any> = [LibraryUnit,UnitUnit,ActionUnit,DataUnit,ServerUnit,OllamaUnit,PromptUnit,AuthorUnit,GenreUnit,SettingUnit,CodexUnit,TerminalUnit,GridUnit,ConsoleUnit,InputUnit,ChoiceUnit,CollectUnit,MenuUnit,BusUnit];

import * as reduceFromLibrary from "./00.library.unit/library.reduce";
import * as reduceFromUnit from "./01.unit.unit/unit.reduce";
import * as reduceFromAction from "./02.action.unit/action.reduce";
import * as reduceFromData from "./03.data.unit/data.reduce";
import * as reduceFromServer from "./04.server.unit/server.reduce";
import * as reduceFromOllama from "./10.ollama.unit/ollama.reduce";
import * as reduceFromPrompt from "./12.prompt.unit/prompt.reduce";
import * as reduceFromAuthor from "./13.author.unit/author.reduce";
import * as reduceFromGenre from "./14.genre.unit/genre.reduce";
import * as reduceFromSetting from "./15.setting.unit/setting.reduce";
import * as reduceFromCodex from "./20.codex.unit/codex.reduce";
import * as reduceFromTerminal from "./80.terminal.unit/terminal.reduce";
import * as reduceFromGrid from "./81.grid.unit/grid.reduce";
import * as reduceFromConsole from "./83.console.unit/console.reduce";
import * as reduceFromInput from "./84.input.unit/input.reduce";
import * as reduceFromChoice from "./85.choice.unit/choice.reduce";
import * as reduceFromCollect from "./97.collect.unit/collect.reduce";
import * as reduceFromMenu from "./98.menu.unit/menu.reduce";
import * as reduceFromBus from "./99.bus.unit/bus.reduce";


export const reducer: any = {
 library : reduceFromLibrary.reducer, 
unit : reduceFromUnit.reducer, 
action : reduceFromAction.reducer, 
data : reduceFromData.reducer, 
server : reduceFromServer.reducer, 
ollama : reduceFromOllama.reducer, 
prompt : reduceFromPrompt.reducer, 
author : reduceFromAuthor.reducer, 
genre : reduceFromGenre.reducer, 
setting : reduceFromSetting.reducer, 
codex : reduceFromCodex.reducer, 
terminal : reduceFromTerminal.reducer, 
grid : reduceFromGrid.reducer, 
console : reduceFromConsole.reducer, 
input : reduceFromInput.reducer, 
choice : reduceFromChoice.reducer, 
collect : reduceFromCollect.reducer, 
menu : reduceFromMenu.reducer, 
bus : reduceFromBus.reducer, 

};

export default class UnitData implements Model {
 
 library : Library = new LibraryModel();
unit : Unit = new UnitModel();
action : Action = new ActionModel();
data : Data = new DataModel();
server : Server = new ServerModel();
ollama : Ollama = new OllamaModel();
prompt : Prompt = new PromptModel();
author : Author = new AuthorModel();
genre : Genre = new GenreModel();
setting : Setting = new SettingModel();
codex : Codex = new CodexModel();
terminal : Terminal = new TerminalModel();
grid : Grid = new GridModel();
console : Console = new ConsoleModel();
input : Input = new InputModel();
choice : Choice = new ChoiceModel();
collect : Collect = new CollectModel();
menu : Menu = new MenuModel();
bus : Bus = new BusModel();

 
}

var sim = {
 hunt:null,
 state: null
};

sim.hunt = (typ,obj) =>{return host(obj, typ)}

var host = (obj, typ) => {
 

 
 init();

 var slv;
 const promo = new Promise((rslv, rjct) => (slv = rslv));

 if (obj == null) obj = {};
 if (obj.slv == null) obj.slv = (val0) => slv(val0);
 
 sim.state.dispatch({ type: typ, bale: obj });
 return promo;
};

var init = () => {
 if (sim.state != null) return;
 sim.state = new State();
 sim.state.pivot = sim;
 sim.state.hunt = sim.hunt
 for (var k in Import.list) new Import.list[k](sim.state);
};

import * as Import from "./BEE";
import State from "./99.core/state";

module.exports = sim;
export const VERTICAL = "vertical";
export const HORIZONTAL = "horizontal";



export const BLACK: string = "black";
export const RED: string = "red";
export const GREEN: string = "green";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";
export const CYAN: string = "cyan";
export const WHITE: string = "white";
export const BLUE: string = "blue";
export const RED: string = "\x1b[31m%s\x1b[0m";
export const GREEN: string = "\x1b[32m%s\x1b[0m";
export const YELLOW: string = "\x1b[33m%s\x1b[0m";
export const MAGENTA: string = "\x1b[34m%s\x1b[0m";
export const CYAN: string = "\x1b[36m%s\x1b[0m";

export const EAST = "E";
export const SOUTH_EAST = "SE";
export const SOUTH = "S";
export const SOUTH_WEST = "SW";
export const WEST = "W";
export const NORTH_WEST = "NW";
export const NORTH = "N";
export const NORTH_EAST = "NE";

export const WISE_EAST = "Wise E";
export const WISE_SOUTH_EAST = "Wise SE";
export const WISE_SOUTH = "Wise S";
export const WISE_SOUTH_WEST = "Wise SW";
export const WISE_WEST = "Wise W";
export const WISE_NORTH_WEST = "Wise NW";
export const WISE_NORTH = "Wise N";
export const WISE_NORTH_EAST = "Wise NE";

export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const RECTANGLE: string = "rectangle";
export const ROUNDED_RECTANGLE: string = "rounded-rectangle";

export const CIRCLE: string = "circle";

export type Position <Type> = {
    x: number;
    y: number;
} & Type


export type GridFill =Position<{
    xSpan:number;
    ySpan:number;
}>

export const TOP_FULL_IDX = 'top-fill';
export const MID_FULL_IDX = 'mid-fill';
export const BOT_FULL_IDX  = 'bot-fill';

export const TOP_FULL_BIT:GridFill= {x:0, y:0, xSpan:12, ySpan:4};
export const MID_FULL_BIT:GridFill= {x:0, y:4, xSpan:12, ySpan:5};
export const BOT_FULL_BIT:GridFill= {x:0, y:8, xSpan:12, ySpan:4};

export const FOCUS: string = "focus";
export const HEXMAP: string = "hexmap";
export const PLAT: string = "plat";
export const AMBT: string = "ambt";
export const AVAS: string = "avas";
export const SPACE: string = "space";
export const TIMELINE: string = "timeline";
export const MENU_SINGLE: string = "menu_single";
export const CLEAN: string = "clean";
export const CYAN: string = "cyan";
export const RED: string = "red";
export const GREEN: string = "green";
export const BLUE: string = "blue";
export const YELLOW: string = "yellow";
export const MAGENTA: string = "magenta";

export const CONTROL = "CONTROL";
export const TIME = "TIME";
export const SPACE = "SPACE";
export const EARTH = "EARTH";
export const SOWER = "SOWER";
export const SHADE = "SHADE";
export const SOLID = "SOLID";
export const MARKET = "MARKET";
export const LIBRARY = "LIBRARY";

export const VISAGE: string = "visage";
export const SURFACE: string = "surface";
export const CONTAINER: string = "container";
export const GRAPHIC: string = "graphic";
export const TEXT: string = "text";
export const SPRITE: string = "sprite";
export const HEXAGON: string = "hexagon";
export const VIDEO: string = "video";
export const LOOP: string = "loop";
export const GEOJSON = "geojson";
export const RECTANGLE = "rectangle";
export const TRIANGLE = "triangle";
export const HEXAGON = "hexagon";
export const PARALLELOGRAM = "parallelogram";

export const FOCUS = "focus";
export const HEXMAP = "hexmap";
export const CLOCK: string = "clock";
export const SCREEN: string = "screen-visage";
export const MOUNT_FULL: string = "mount-visage-full";
export const MOUNT_PART: string = "mount-visage-part";
export const MOUNT_HEIGHT: string = "mount-visage-height";
export const MOUNT_WIDTH: string = "mount-visage-width";
import React from 'react';

import Control from "../../000.control/99.core/state";
import * as Import from "../../000.control/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function ControlBlock() {
    console.log( PIVOT.CONTROL + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Control();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.CONTROL ] == null) {
        (window as any)[ PIVOT.CONTROL ] = sim.hunt;
    }

    return (
        <></>
    );
}
import React from 'react';

import Earth from "../../000.earth/99.core/state";
import * as Import from "../../000.earth/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function EarthBlock() {
    console.log( PIVOT.EARTH + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Earth();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.EARTH ] == null) {
        (window as any)[ PIVOT.EARTH ] = sim.hunt;
    }

    return (
        <></>
    );
}
export const CONTROL = "CONTROL";
export const TIME = "TIME";
export const SPACE = "SPACE";
export const EARTH = "EARTH";
export const SOWER = "SOWER";
export const SHADE = "SHADE";
export const SOLID = "SOLID";
export const MARKET = "MARKET";
export const LIBRARY = "LIBRARY";

import React from 'react';

import Shade from "../../110.shade/99.core/state";
import * as Import from "../../110.shade/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function ShadeBlock() {
    console.log( PIVOT.SHADE + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Shade();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.SHADE ] == null) {
        (window as any)[ PIVOT.SHADE ] = sim.hunt;
    }

    return (
        <></>
    );
}
import React from 'react';

import Solid from "../../111.solid/99.core/state";
import * as Import from "../../111.solid/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function SolidBlock() {
    console.log( PIVOT.SOLID + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Solid();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.SOLID ] == null) {
        (window as any)[ PIVOT.SOLID ] = sim.hunt;
    }

    return (
        <></>
    );
}
import React from 'react';

import Sower from "../../010.sower/99.core/state";
import * as Import from "../../010.sower/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function SowerBlock() {
    console.log( PIVOT.SOWER + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Sower();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.SOWER ] == null) {
        (window as any)[ PIVOT.SOWER ] = sim.hunt;
    }

    return (
        <></>
    );
}
import React from 'react';

import Space from "../../002.space/99.core/state";
import * as Import from "../../002.space/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function SpaceBlock() {
    console.log( PIVOT.SPACE + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Space();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.SPACE ] == null) {
        (window as any)[ PIVOT.SPACE ] = sim.hunt;
    }

    return (
        <></>
    );
}

import React from 'react';

import Time from "../../001.time/99.core/state";
import * as Import from "../../001.time/BEE";

import * as PIVOT from '../pivot'

interface Sim {
    hunt: (typ: string, obj?: any) => Promise<any>;
    state: State | null;
}

interface State {
    pivot: Sim;
    hunt: (typ: string, obj?: any) => Promise<any>;
    dispatch(action: { type: string; bale: any }): void;
}


export default function TimeBlock() {
    console.log( PIVOT.TIME + " block");

    let sim: Sim = {
        hunt: (typ, obj) => Promise.resolve({}),
        state: null,
    };

    sim.hunt = (typ: string, obj: any) => { return host(obj, typ); };

    var host = (obj: any, typ: string): Promise<any> => {
        init();

        var slv: (value: any) => void;
        const promo = new Promise<any>((rslv) => (slv = rslv));

        if (obj == null) obj = {};
        if (obj.slv == null) obj.slv = (val0: any) => slv(val0);

        sim.state!.dispatch({ type: typ, bale: obj });
        return promo;
    };

    var init = (): void => {
        if (sim.state != null) return;
        sim.state = new Time();
        sim.state.pivot = sim;
        sim.state.hunt = sim.hunt;
        for (var k in Import.list) {
            new Import.list[k](sim.state);
        }
    };

    if (typeof window !== 'undefined' && (window as any)[  PIVOT.TIME ] == null) {
        (window as any)[ PIVOT.TIME ] = sim.hunt;
    }

    return (
        <></>
    );
}

const os = require('os');
const { execSync } = require('child_process');

//var FS = require('fs-extra');
//console.log('prepare to copy');

//var sourceDir = '../100.fictiq/dist/100.fictiq';
//var destDir = './100.fictiq';

//FS.ensureDirSync('./100.fictiq');

//async function emptyDirectory(dirPath) {
//  try {
//    FS.emptyDirSync(dirPath); // fs-extra's emptyDir efficiently removes all files & subdirectories.
//    console.log(`Directory "${dirPath}" emptied successfully.`);
//  } catch (err) {
//    console.error(`Error emptying directory "${dirPath}":`, err);
//  }
//}

// Example usage:

//function copyDirectory(sourceDir, destinationDir) {
//  try {
//    FS.copySync(sourceDir, destinationDir); // fs-extra's copy recursively copies contents.
//    console.log(`Directory "${sourceDir}" copied to "${destinationDir}" successfully.`);
//  } catch (err) {
//    console.error(`Error copying directory:`, err);
//  }
//}

// Example usage:
//emptyDirectory(destDir);
//copyDirectory(sourceDir, destDir);

console.log('prepare to clear');

try {
  const platform = os.platform();
  let command;

  if (platform === 'win32') {
    command = 'taskkill /f /im node.exe';
  } else if (platform === 'darwin') {
    // macOS
    command = 'killall node';
  } else if (platform === 'linux') {
    command = 'killall node';
  } else {
    console.warn('Unsupported platform.  Cannot kill Node.js processes.');
    return;
  }

  execSync(command, { stdio: 'ignore' });
  console.log('Killed all Node.js processes.');
} catch (error) {
  console.error('Error killing Node.js processes:', error);
}

require('dotenv').config();
const { spawn } = require('child_process');
const path = require('path');

function launchBatchFile(userInputPath) {
    const sanitizedPath = path.normalize(userInputPath); // Sanitize the path

    batch = spawn('cmd', ['/c', sanitizedPath]);

    batch.stdout.on('data', (data) => {
        console.log(`stdout: ${data}`);
    });

    batch.stderr.on('data', (data) => {
        console.error(`stderr: ${data}`);
    });

    batch.on('close', (code) => {
        console.log(`child process exited with code ${code}`);

        //FS.emptyDir( dest, ()=>{
        //  FS.copySync('./dist/win-unpacked/' , dest )
        //})

        console.log("application complete ")

    });


    console.log('Batch file launched!');
}

launchBatchFile(process.env.QUEST_BAT);



export const onRequestGet = async () => {
    
    var queryFn = async () => {
   
        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/okwierdo/open')
        if (!response.ok) {
          throw new Error('Network response was not ok : okwierdo.onrender.com/api/okwierdo/open')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  







const URLS = {
  production: 'https://zero01-alligator-quest.onrender.com/api/',
  staging: 'http://localhost:3005/api/',
};

export const onRequestGet = async (context) => {

  var request = context.request

  var environment = env.TARGET_ENVIRONMENT

  var loc;
  if (environment == 'staging') loc = env.STAGING
  else loc = env.PRODUCTION

  var queryFn = async () => {

    const targetUrl = loc + 'time/init';

    const response = await fetch(targetUrl)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()

  }

  const bit = await queryFn()

  return new Response(JSON.stringify(bit));
};










export const onRequestGet = async (request) => {

    const url = new URL(request.url);
    const idx = url.searchParams.get('idx');

    var bit = { idx: "on request get " + idx }

    return new Response(JSON.stringify(bit));

};










export const onRequestGet = async (request) => {

    const url = new URL(request.url);
    const idx = url.searchParams.get('idx');

    var queryFn = async () => {

        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/funfoot/read?idx=' + idx)
        if (!response.ok) {
            throw new Error('Network response was not ok : okwierdo.onrender.com/api/0kwierdo/funfoot/read')
        }
        return response.json()

    }

    const bit = await queryFn()

    return new Response(JSON.stringify(bit));
};









export const onRequestGet = async ( request ) => {

    const url = new URL(request.url);
  // read the encrypted data from the query param
  const idx = url.searchParams.get('idx');
      
      var queryFn = async () => {
     
          const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/funfoot/write?idx=' + idx )
          if (!response.ok) {
            throw new Error('Network response was not ok : okwierdo.onrender.com/api/0kwierdo/funfoot/read')
          }
          return response.json()
    
        }
    
        const bit = await queryFn()
      
      return new Response(JSON.stringify(bit));
    };
    
    
  






export const onRequestGet = async (context) => {

    var request = context.request

    const { searchParams } = new URL(request.url)
    let idx = searchParams.get('idx')

    if (idx == null) {
        var bitNow = { idx: 'request-error', src: "no idx present" }
        return new Response(JSON.stringify(bitNow));
    }

    var queryFn = async () => {

        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/funfoot/open?idx=' + idx)
        if (!response.ok) {
            throw new Error('Network response was not ok : okwierdo.onrender.com/api/okwierdo/open')
        }
        return response.json()

    }

    const bit = await queryFn()

    return new Response(JSON.stringify(bit));
};













export const onRequestGet = async (context) => {

    var request = context.request

    const { searchParams } = new URL(request.url)
    let idx = searchParams.get('idx')

    if (idx == null) {
        var bitNow = { idx: 'request-error', src: "no idx present" }
        return new Response(JSON.stringify(bitNow));
    }

    var queryFn = async () => {

        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/funfoot/read?idx=' + idx)
        if (!response.ok) {
            throw new Error('Network response was not ok : okwierdo.onrender.com/api/okwierdo/read')
        }
        return response.json()

    }

    const bit = await queryFn()

    return new Response(JSON.stringify(bit));
};













export const onRequestGet = async (context) => {

    var request = context.request

    const { searchParams } = new URL(request.url)
    let idx = searchParams.get('idx')

    if (idx == null) {
        var bitNow = { idx: 'request-error', src: "no idx present" }
        return new Response(JSON.stringify(bitNow));
    }

    var queryFn = async () => {

        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/funfoot/write?idx=' + idx)
        if (!response.ok) {
            throw new Error('Network response was not ok : okwierdo.onrender.com/api/okwierdo/write')
        }
        return response.json()

    }

    const bit = await queryFn()

    return new Response(JSON.stringify(bit));
};







export const onRequestGet = () => {
    return new Response("Hello, world!");
  };
  
  // POST requests to /filename with a JSON-encoded body would return "Hello, <name>!"
  export const onRequestPost = async ({ request }) => {
    const { name } = await request.json();
    return new Response(`Hello, ${name}!`);
  };
  
export const onRequestGet = async () => {
    
    var queryFn = async () => {

      const targetUrl = 'http://localhost:3005/api/time/init';

        const response = await fetch( targetUrl )
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  







export const onRequestGet = async () => {
    
    var queryFn = async () => {

      const targetUrl = 'https://zero01-alligator-quest.onrender.com/api/time/init';

      

        const response = await fetch( targetUrl )
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  








export const onRequestGet = async () => {
    
    var queryFn = async () => {

        const response = await fetch('https://okwierdo.onrender.com/api/moon')
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  








export const onRequestGet = async () => {
    
    var queryFn = async () => {
   
        const response = await fetch('https://okwierdo.onrender.com/api/0kwierdo/okwierdo/open')
        if (!response.ok) {
          throw new Error('Network response was not ok : okwierdo.onrender.com/api/okwierdo/open')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  







const URLS = {
  production: 'https://zero01-alligator-quest.onrender.com/api/',
  staging: 'http://localhost:3005/api/time/init',
};

export const onRequestGet = async () => {
    
    var queryFn = async () => {

      const targetEnv = env.TARGET_ENVIRONMENT;
      const targetUrl = URLS[targetEnv] || URLS.production + 'time/init';

        const response = await fetch( targetUrl )
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  





export const onRequestGet = async () => {
    
    var queryFn = async () => {

      const targetUrl = 'http://localhost:3005/api/earth/update';

        const response = await fetch( targetUrl )
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  







export const onRequestGet = async () => {
    
    var queryFn = async () => {

      const targetUrl = 'https://zero01-alligator-quest.onrender.com/api/earth/update';

      

        const response = await fetch( targetUrl )
        if (!response.ok) {
          throw new Error('Network response was not ok')
        }
        return response.json()
  
      }
  
      const bit = await queryFn()
    
    return new Response(JSON.stringify(bit));
  };
  
  





// Cloudflare Worker code (worker.js)
addEventListener('fetch', event => {
  event.respondWith(handleRequest(event.request));
});

async function handleRequest(request) {
  if (request.method === 'POST' && request.headers.get('Content-Type').startsWith('multipart/form-data')) {
    try {
      // 1. Get the request body as a FormData object
      const formData = await request.formData();

      // 2. Construct a new request to your Next.js API route
      const nextJsRequest = new Request('https://zero00-primal-mom.onrender.com/api/upload-video', { // Replace with your Next.js API route URL
        method: 'POST',
        body: formData, // Pass the FormData object directly
        headers: {
          // Don't set Content-Type here!  fetch will handle it correctly.
        },
      });

      // 3. Forward the request to Next.js using fetch
      const response = await fetch(nextJsRequest);

      // 4. Return the response from Next.js to the client
      return new Response(response.body, {
        status: response.status,
        headers: response.headers
      });

    } catch (error) {
      console.error('Error forwarding request:', error);
      return new Response('Internal Server Error', { status: 500 });
    }
  } else {
    // Handle other requests (e.g., OPTIONS)
    return new Response('Method Not Allowed', { status: 405 });
  }
}
const aedes = require("aedes")();
const httpServer = require("http").createServer();
const ws = require("websocket-stream");
const port = process.env.PORT || 80;

ws.createServer({ server: httpServer }, aedes.handle);

httpServer.listen(port, () => {
  console.log("websocket server listening on port ", port);
});

import Index from '../../ui/000.Index';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Index />;
};

export default Page;

import Title from '../../ui/001.Title';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Title />;
};

export default Page;

import Scene from '../../ui/002.Scene';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Scene />;
};

export default Page;

import React from 'react'
import Index from "../../../ui/test/Index"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Index />;
};

export default Page;

import Title from '../../ui/001.Title';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Title />;
};

export default Page;

import Scene from '../../ui/002.Scene';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Scene />;
};

export default Page;

import React from 'react'
import Index from "../../../ui/test/Index"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Index />;
};

export default Page;

import React from 'react'
import ShadeTest from "../../../ui/test/ShadeTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <ShadeTest />;
};

export default Page;

import React from 'react'
import SolidTest from "../../../ui/test/SolidTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <SolidTest />;
};

export default Page;

import React from 'react'
import PixelTest from "../../../ui/test/PixelTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <PixelTest />;
};

export default Page;

import React from 'react'
import ControlTest from "../../../ui/test/ControlTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <ControlTest />;
};

export default Page;

import React from 'react'
import SpaceTest from "../../../ui/test/SpaceTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <SpaceTest />;
};

export default Page;

import React from 'react'
import TimeTest from "../../../ui/test/TimeTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <TimeTest />;
};

export default Page;

import React from 'react'
import Index from "../../../ui/play/Index"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Index />;
};

export default Page;

import React from 'react'
import SpaceTest from "../../../ui/test/SpaceTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <SpaceTest />;
};

export default Page;

import React from 'react'
import TimeTest from "../../../ui/test/TimeTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <TimeTest />;
};

export default Page;

import React from 'react'
import ControlTest from "../../../ui/test/ControlTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <ControlTest />;
};

export default Page;

import React from 'react'
import EarthTest from "../../../ui/test/EarthTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <EarthTest />;
};

export default Page;

import React from 'react'
import SolidTest from "../../../ui/test/SolidTest"

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <SolidTest />;
};

export default Page;

import Play from '../../ui/004.Play';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Play />;
};

export default Page;

import Play from '../../ui/010.Station';

/**
 * The main page component that renders the HomePage component.
 *
 * @returns {JSX.Element} The rendered HomePage component.
 */
const Page = () => {
    
    return <Play />;
};

export default Page;

module.exports = {
    plugins: {
      'postcss-preset-mantine': {},
      'postcss-simple-vars': {
        variables: {
          'mantine-breakpoint-xs': '36em',
          'mantine-breakpoint-sm': '48em',
          'mantine-breakpoint-md': '62em',
          'mantine-breakpoint-lg': '75em',
          'mantine-breakpoint-xl': '88em',
        },
      },
    },
  }

import * as ActCtl from "../000.control/00.control.unit/control.action";
import { useQuery } from "@tanstack/react-query"


export function useInitControl() {
    return useQuery({
        queryFn: async () => {
            var bit = await window['CONTROL']( ActCtl.INIT_CONTROL, {})
            return bit

        },
        queryKey: ['initControl']
    })
}



import { useQuery } from "@tanstack/react-query"

import * as ActEth from "../000.earth/00.earth.unit/earth.action";
import * as ActCtl from "../000.control/00.control.unit/control.action";

export function useInitEarth() {
    return useQuery({
        queryFn: async () => {
            var bit = await window['EARTH'](ActEth.INIT_EARTH, {})
            return bit

        },
        queryKey: ['initPixel']
    })
}


export function useUpdateEarth() {
    return useQuery({
        queryFn: async () => {

            const { ctlBit: { dat: { clientLocal, serverLocal, localLocation, remoteLocation } } } = await window['CONTROL'](ActCtl.ACCESS_CONTROL, {});

            if (clientLocal) {
                return window['EARTH'](ActEth.UPDATE_EARTH, {});
            }

            let endpoint = '/api/updateEarthLocal'

            if (serverLocal == false) endpoint = '/api/updateEarthRemote'
            const response = await fetch(endpoint);

            if (!response.ok) {
                alert(`Network response was not ok. Status: ${response.status}`)
                throw new Error(`Network response was not ok. Status: ${response.status}`);
            }

            return response.json();

        },
        refetchInterval: 1000,
        staleTime: 1000,
        queryKey: ['updateEarth']
    })
}


import { useQuery } from "@tanstack/react-query"

export function useWriteFictiq() {
    return useQuery({
        queryFn: async () => {


            var url = 'https://upload-r2-assets.fictiq.workers.dev/README.md'
            var token = 'voice-of-caitlin'

            var data = `game on`


            const response = await fetch(url, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `Bearer ${token}` // Include the token in the Authorization header
                },
                body: JSON.stringify(data) // Convert data to JSON
              });
          
              if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
              }
          
              const responseData = await response.text(); // Parse the JSON response
              return responseData;


            

            //const response = await fetch('/api/space/hexmap/shape')
            //if (!response.ok) {
             //   alert('Network response was not ok : /api/space/init ')
                //throw new Error('Network response was not ok')
           // }
           // return response.json()






        },
        queryKey: ['writeFictiq']
    })
}



import * as ActSpc from "../002.space/00.space.unit/space.action";
import { useQuery } from "@tanstack/react-query"

export function useInitSpace() {
    return useQuery({
        queryFn: async () => {

            var bit = await window['SPACE']( ActSpc.INIT_SPACE, {})
            return bit

        },
        queryKey: ['initSpace']
    })
}



import * as ActCtl from "../000.control/00.control.unit/control.action";

import * as ActTme from "../001.time/00.time.unit/time.action";
import * as ActClk from "../001.time/03.clock.unit/clock.action";

import { useQuery } from "@tanstack/react-query"

export function useInitTime() {
    return useQuery({
        queryFn: async () => {

            const { ctlBit: { dat: { clientLocal, serverLocal, localLocation, remoteLocation } } } = await window['CONTROL'](ActCtl.ACCESS_CONTROL, {});

            if (clientLocal) {
              return window['TIME'](ActTme.INIT_TIME, {});
            }
          
            let endpoint = '/api/initTimeLocal'
            
            if ( serverLocal == false ) endpoint = '/api/initTimeRemote'
            const response = await fetch(endpoint);
          
            if (!response.ok) {
              alert( `Network response was not ok. Status: ${response.status}` )
               throw new Error(`Network response was not ok. Status: ${response.status}`);
            }
          
            return response.json();
           
        },
        queryKey: ['initTime']
    })
}

export function useRandomTime(idx) {

    return useQuery({
        queryFn: async () => {

            var bit = await window['TIME'](ActTme.RANDOM_TIME, { idx })
            return bit

        },
        queryKey: ['randomTime']
    })
}

export function useWriteClock(idx, clk) {
    return useQuery({
        queryFn: async () => {

            var bit = await window['TIME'](ActClk.WRITE_CLOCK, { idx, clk })
            return bit

        },
        queryKey: ['writeClock']
    })
}

export function useWriteClockIncrement(idx, clk) {

    clk.yrs = 0;

    return useQuery({
        queryFn: async () => {

            var bit = await window['TIME'](ActClk.WRITE_CLOCK, { idx, clk })
            return bit

        },
        queryKey: ['writeClockIncrement']
    })
}

export async function useReadClock(idx) {

    return useQuery({
        queryFn: async () => {

            var bit = await window['TIME'](ActClk.READ_CLOCK, { idx })
            return bit

        },
        queryKey: ['readClock']
    })
}



export function useListClock() {
    return useQuery({
        queryFn: async () => {

            var bit = await window['TIME'](ActClk.LIST_CLOCK, {})
            return bit

        },
        queryKey: ['listClock']
    })
}



import React from 'react'
import { Box, Container, Group, Button } from '@mantine/core';

import { Link } from '@tanstack/react-router'

function NavBar() {




    return (

        <>

            <div >
            </div>

        </>




    )




}

export default NavBar
import IndexPage from '../page/000.index/page';
import TitlePage from '../page/001.title/page';
import ScenePage from '../page/002.scene/page';
import StationPage from '../page/005.station/page';

import TestPage from '../page/003.test/000.index/page';
import TestSolidPage from '../page/003.test/009.solid-test/page';
import TestEarthPage from '../page/003.test/008.earth-test/page';
import TestControlPage from '../page/003.test/007.control-test/page';
import TestSpacePage from '../page/003.test/005.space-test/page';
import TestTimePage from '../page/003.test/006.time-test/page';

import PlayPage from '../page/004.play/page';

import {
    Link,
    Outlet,
    RouterProvider,
    createRootRoute,
    createRoute,
    createRouter,
} from '@tanstack/react-router'

import React from "react";

import NavBar from "./NavBar"


const rootRoute = createRootRoute({
    component: () => (
        <>

            <div >

                <NavBar />

                <div style={{ position: 'absolute', left: 0, right: 0, marginInline: 'auto', width: 'fit-content' }} >
                    <Outlet />
                </div>

            </div>

        </>
    ),
});

const indexRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/",
    component: function Index() {
        return (
            <IndexPage />
        );
    },
});

const titleRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/title",
    component: function Test() {
        return (
            <TitlePage />
        );
    },
});

const sceneRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/scene",
    component: function Lora() {
        return (
            <ScenePage />
        );
    },
});

const testRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test",
    component: function Lora() {
        return (
            <TestPage />
        );
    },
});




const testEarthRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test/earth",
    component: function Lora() {
        return (
            <TestEarthPage />
        );
    },
});


const testControlRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test/control",
    component: function Lora() {
        return (
            <TestControlPage />
        );
    },
});

const testSpaceRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test/space",
    component: function Lora() {
        return (
            <TestSpacePage />
        );
    },
});

const testTimeRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test/time",
    component: function Lora() {
        return (
            <TestTimePage />
        );
    },
});


const testSolidRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/test/solid",
    component: function Lora() {
        return (
            <TestSolidPage />
        );
    },
});



const playRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/play",
    component: function Lora() {
        return (
            <PlayPage />
        );
    },
});


const stationRoute = createRoute({
    getParentRoute: () => rootRoute,
    path: "/station",
    component: function Lora() {
        return (
            <StationPage />
        );
    },
});




export var RouteTree = () => {

    var item = rootRoute.addChildren([
        indexRoute,
        titleRoute,
        sceneRoute,
        testRoute,
        testSolidRoute,
        testEarthRoute,
        testControlRoute,
        testSpaceRoute,
        testTimeRoute,
        playRoute,
        stationRoute,

    ]);

    return item

}


import { defineConfig } from '@rsbuild/core';
import { pluginReact } from '@rsbuild/plugin-react';

import { pluginNodePolyfill } from "@rsbuild/plugin-node-polyfill";

export default defineConfig({
  plugins: [pluginReact(), pluginNodePolyfill()],

});

require('dotenv').config();
const { spawn } = require('child_process');
const MQTT = require('async-mqtt');
const path = require('path');
const fs = require('fs');
const { program } = require('commander');

const PORT = 1995;
const wsPort = 8995;

var idx;
program.option('--first').option('-t, --separator <char>');
program.parse(process.argv);
const options = program.opts();
if (options['separator'] != null) idx = options['separator'];


const aedes = require('aedes')();
const server = require('net').createServer(aedes.handle);

const httpServer = require('http').createServer()
const ws = require('websocket-stream')
ws.createServer({ server: httpServer }, aedes.handle)

httpServer.listen(wsPort, function () {
    console.log('Aedes MQTT-WS listening on port: ' + wsPort)
    aedes.publish({ topic: 'aedes/hello', payload: "I'm broker " + aedes.id })
});

server.listen(PORT, async () => {
    console.log('server started and listening on port ', PORT);

    var exec = require('child_process').exec;

    exec('tsc -b 995.library', async (err, stdout, stderr) => {
        if (err) {
            console.error(`exec error: ${err}`);
        }
        init(PORT);
    })
});


const init = async (prt) => {

    console.log("inits")

    const local = 'ws://localhost:80';
    //const local = 'wss://agent-network-8af0ee89ad26.herokuapp.com';

    const localBit = { idx: 'local', src: local };

    const { JSDOM } = require('jsdom');

    const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
        url: 'http://localhost', // Provide a URL for features like location.href
    });

    // Attach the jsdom window to the Node.js global object
    global.window = dom.window;

    LIBRARY = require(path.resolve('./dist/995.library/hunt'));
    LIBRARY_ACTION = require(path.resolve('./dist/995.library/00.library.unit/library.action'));
    await LIBRARY.hunt(LIBRARY_ACTION.INIT_LIBRARY, { val: 1, dat: MQTT, src: [localBit] });

    //LIBRARY = require(path.resolve('./dist/995.library/hunt'));
    //LIBRARY_ACTION = require(path.resolve('./dist/995.library/00.library.unit/library.action'));

    //SPACE = require(path.resolve('./002.space/index'));
    //SPACE_ACTION = require(path.resolve('./002.space/00.space.unit/space.action'));

    //PIVOT = require(path.resolve('./999.pivot/index'));
    //PIVOT_ACTION = require(path.resolve('./999.pivot/00.pivot.unit/pivot.action'));

    //if (pvt == false) {
     //   await PIVOT.hunt(PIVOT_ACTION.INIT_PIVOT, { dat: MQTT, src: local });
        //await SPACE.hunt( SPACE_ACTION.INIT_SPACE, {  dat: MQTT, src: local });
    //    await LIBRARY.hunt(LIBRARY_ACTION.INIT_LIBRARY, { val: 1, dat: MQTT, src: [localBit] });

   // }
   // else {

   //     await PIVOT.hunt(PIVOT_ACTION.INIT_PIVOT, { val: 1, dat: MQTT, src: local });
        //await SHADE.hunt( SHADE_ACTION.INIT_SHADE , { val: 1, dat: MQTT, src:  [localBit]  });
   // }

};





//var exec = require('child_process').exec;

//exec('tsc -b 995.library', async (err, stdout, stderr) => {
//    if (err) {
//        console.error(`exec error: ${err}`);
//    }

//    init()
//})


function launchBatchFile(userInputPath) {
    const sanitizedPath = path.normalize(userInputPath); // Sanitize the path

    batch = spawn('cmd', ['/c', sanitizedPath]);

    batch.stdout.on('data', (data) => {
        console.log(`stdout: ${data}`);
    });

    batch.stderr.on('data', (data) => {
        console.error(`stderr: ${data}`);
    });

    batch.on('close', (code) => {
        console.log(`child process exited with code ${code}`);

        //FS.emptyDir( dest, ()=>{
        //  FS.copySync('./dist/win-unpacked/' , dest )
        //})

        console.log("application complete ")

    });


    console.log('Batch file launched!');
}

launchBatchFile(process.env.MQTT_BAT);


//const init = async () => {

//    const { JSDOM } = require('jsdom');

//    const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>', {
//        url: 'http://localhost', // Provide a URL for features like location.href
//    });

    // Attach the jsdom window to the Node.js global object
 //   global.window = dom.window;

 //   LIBRARY = require(path.resolve('./dist/995.library/hunt'));
 //   LIBRARY_ACTION = require(path.resolve('./dist/995.library/00.library.unit/library.action'));
  //  await LIBRARY.hunt(LIBRARY_ACTION.INIT_LIBRARY, { val: 1, dat: null, src: null });

//};




.invisible {
  opacity: 0;
}

body {
  margin: 0;
  color: #000000;
  font-family: Inter, Avenir, Helvetica, Arial, sans-serif;
  background-color: #353839;  
  image-rendering: pixelated;
}

.content {
  display: flex;
  min-height: 100vh;
  line-height: 1.1;
  text-align: center;
  flex-direction: column;
  justify-content: center;
}

.content h1 {
  font-size: 3.6rem;
  font-weight: 700;
}

.content p {
  font-size: 1.2rem;
  font-weight: 400;
  opacity: 0.5;
}

html, body {
  margin: 0;
  padding: 0;
  overflow: hidden;
}




#renderCanvas {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%); /* The classic centering trick */
  outline: none;
  overflow: hidden;
}

import React from "react";
import ReactDOM from "react-dom/client";

import "./App.css";
import '@mantine/core/styles.css';

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { createTheme, MantineProvider } from '@mantine/core';

import { RouteTree } from "../router/RouteTree"

import { RouterProvider, createRouter } from '@tanstack/react-router'


import ControlBlock from '../base/control/block'
import TimeBlock from '../base/time/block'
import SpaceBlock from '../base/space/block'
import SowerBlock from '../base/sower/block'

import EarthBlock from '../base/earth/block'

import SolidBlock from '../base/solid/block'
import ShadeBlock from '../base/shade/block'



// Create a brutalist theme
const brutalistTheme = createTheme({
  imageRendering: 'pixelated',
  fontFamily: 'Courier New, monospace',
  headings: { fontFamily: 'Courier New, monospace' },
  colorScheme: 'dark',
  white: '#FFFF00'

})



const queryClient = new QueryClient();

const routeTree = RouteTree()
const router = createRouter({
  routeTree,
  defaultPreload: "intent",
  scrollRestoration: true,
});



const root = ReactDOM.createRoot(document.getElementById("root"));
root.render(
  <React.StrictMode>

    <ControlBlock />
    <TimeBlock />
    <SpaceBlock />
    <SowerBlock />
    <EarthBlock />
    <ShadeBlock />
    <SolidBlock />

    <QueryClientProvider client={queryClient}>
      <MantineProvider theme={brutalistTheme}>
        <RouterProvider router={router} />
      </MantineProvider>
    </QueryClientProvider>
  </React.StrictMode>
);

import React from 'react'
import { redirect } from '@tanstack/react-router'

function Index() {
  document.location.href = './station'

  

  return (
    <div>
    </div>
  )
}

export default Index

'use client'

import React from 'react'
import FrameTitle from './title/FrameTitle'
import { useState, useEffect } from 'react';


export default function Component() {
    //const { classes, cx } = useStyles();
    const [activeOption, setActiveOption] = useState('GAME');
    const [flickerOpacity, setFlickerOpacity] = useState(1);

    var actionOne = () => {
        document.location.href = '/camera'


    }

    var actionTwo = () => {

        document.location.href = '/pixi'


    }

    var actionThree = () => {

        document.location.href = '/camera'


    }



    // Film flicker effect
    useEffect(() => {
        const flickerInterval = setInterval(() => {
            const randomOpacity = Math.random() * 0.1 + 0.9; // Between 0.9 and 1.0
            setFlickerOpacity(randomOpacity);
        }, 100);

        return () => clearInterval(flickerInterval);
    }, []);

    return (

        <div>
            <FrameTitle />
        </div>

    );
}
'use client'

import React from 'react'

import FrameScene from './scene/FrameScene'

export default function Component() {
 
    return (

        <div>
            <FrameScene/>
        </div>

    );
}
'use client'

import React from 'react'

import Index from './test/Index'

export default function Component() {
 
    return (

        <div>
            <Index/>
        </div>

    );
}
'use client'

import React from 'react'

import Index from './play/Index'

export default function Component() {
 
    return (

        <div>
            <Index/>
        </div>

    );
}
'use client'

import React from 'react'

import ControlTest from './test/ControlTest'

export default function Component() {
 
    return (

        <div>
            <ControlTest/>
        </div>

    );
}
'use client'

import React from 'react'

import EarthTest from './test/EarthTest'

export default function Component() {
 
    return (

        <div>
            <EarthTest/>
        </div>

    );
}
'use client'

import React from 'react'

import Index from './station/Index'

export default function Component() {
 
    return (

        <div>
            <Index/>
        </div>

    );
}
import React from 'react';
import { Box, ScrollArea } from '@mantine/core';

import { useState, useEffect } from 'react';

import Scene from './Scene'

const buttonStyles = {
    root: {
        width: '100%',
        height: '50px',
        fontFamily: 'Arial, sans-serif',
        fontSize: '20px',
        fontWeight: 700,
        borderRadius: 0,
        border: 'none',
        marginBottom: '8px',
        transition: 'background-color 0.2s',
    },
};

function GameMenu() {

    return (
        <Box
            style={{
                width: '1280px',
                height: '720px',
                position: 'relative'
            }}

        >

            <Scene />


        </Box>
    );
}

export default function AmericanFugitiveMenu() {
    return (
        <div>
            <GameMenu />
            \
        </div>
    );
}


import React from 'react'
import { useState, useEffect } from 'react';
import { Box, Divider, ScrollArea, Center } from '@mantine/core';

import RecordButton from './RecordButton'
import SelectionBox from './SelectionBox'
import Slider from './Slider'

import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'

import * as ActMku from '../../111.solid/10.miku.unit/miku.action'

import * as ActScr from '../../111.solid/08.screen.unit/screen.action'

export default function Component() {

    setTimeout( async ()=>{
        await window['SOLID']( ActBab.OPEN_BABYLON, {src:'surface00'})
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', src: 'slop/003.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', dat: { position: { z: 40, x: -15, y:-16 } } })
        
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', src: 'slop/slop00.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', dat: { position: { z: 40, x: 35, y:-16 } } })
        
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00' })
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00', dat: { position: { z: 40, x: -35, y:-16 }, rotation: { z: 0, x: 0, y:0 } } })
  
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src01' })
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src01', dat: { position: { z: 40, x: 35, y:-16 } } } )
   
        

    }, 333)

    
    return (

        <Center maw={1920} h={1080} bg="var(--mantine-color-green-light)">
        <Box bg="var(--mantine-color-red-light)">


        <Box style={{
                width: '1920px',
                height: '1080px',
                position: 'relative',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                overflow: "hidden"
            }}>

                <canvas id='surface00' />

            </Box>


        </Box>
      </Center>

        

    );
}
import React from 'react'

import { Button, Box, rem } from "@mantine/core"


import * as ActSld from "../../111.solid/00.solid.unit/solid.action";
import * as ActBab from "../../111.solid/01.babylon.unit/babylon.action";


var recording = false;
var hunt 

function RecordButton(bus) {

  hunt = bus.bus
  
  
  
  
  const record = async () => {

    if (recording == false) {
      recording = true;

      hunt
      

      var bit = await hunt(ActBab.ACTION_BABYLON, { idx: "txt01", dat: { txt: 'testing gator man' } })
      return
    }


    var bit = await hunt(ActBab.CUT_BABYLON, { idx: "txt01", dat: { txt: 'testing gator man' } })
    return


    // bit = await SOLID.hunt( "[Babylon action] Record Babylon", { src: "surface00" })

  }



  return (
    <div>


      {/* Black LORA Button - positioned between header and first input */}
      <Box
        style={{
          marginBottom: rem(30),
          width: "100%",
        }}
      >
        <Button
          onClick={record}
          fullWidth
          styles={{
            root: {
              height: rem(60),
              backgroundColor: "#000000",
              color: "#FFFFFF",
              border: "3px solid black",
              borderRadius: 0,
              position: "relative",
              "&:hover": {
                backgroundColor: "#333333",
              },
            },
            label: {
              fontSize: rem(24),
              fontWeight: 700,
              fontFamily: "Courier New, monospace",
              letterSpacing: "3px",
              color: "#FFFFFF",
            },
          }}
        >
          RECORD
        </Button>
      </Box>


    </div>
  )
}

export default RecordButton

import React from 'react'
import { useState } from "react"
import { Select, Box, Text, rem } from "@mantine/core"


function SelectionBox() {



    const handleLibraryChange = (value, index) => {
        if (value) {
            const newLibraries = [...libraries]
            newLibraries[index] = value
            setLibraries(newLibraries)
        }
    }

    const libraryOptions = [
        { value: "Spouse", label: "Spouse" },
        { value: "Champion", label: "Champion" },
        { value: "Tyrant", label: "Tyrant" },
        { value: "Martyr", label: "Martyr" },
        { value: "Addict", label: "Addict" },
        { value: "Hag", label: "Hag" },
        { value: "Ambassador", label: "Ambassador" },
        { value: "Innocent", label: "Innocent" },
        { value: "Outlaw", label: "Outlaw" },
        { value: "Prophet", label: "Prophet" },
        { value: "Academic", label: "Academic" },
        { value: "Primal", label: "Primal" },
        { value: "Pastoral", label: "Pastoral" },
    ]



    const [libraries, setLibraries] = useState(["Angular", "Angular", "Angular"])

    var index = 0

    return (
        <div>

            <Box
                key={index}
                style={{
                    border: "2px solid black",
                    padding: rem(15),
                    backgroundColor: index % 2 === 0 ? "#FFFFFF" : "#F0F0F0",
                }}
            >
                <Text
                    style={{
                        fontFamily: "Courier New, monospace",
                        fontWeight: "bold",
                        marginBottom: rem(8),
                        textTransform: "uppercase",
                    }}
                >
                    INPUT {index + 1}: MESH
                </Text>
                <Select
                    placeholder="SEARCH MESH..."
                    value=""
                    onChange={(value) => handleLibraryChange(value, index)}
                    data={libraryOptions}
                    searchable
                    nothingFoundMessage="NO MESH FOUND"
                    styles={{
                        input: {
                            height: rem(45),
                            border: "2px solid black",
                            fontFamily: "Courier New, monospace",
                            fontSize: rem(14),
                            backgroundColor: "#FFFFFF",
                            "&:focus": {
                                border: "2px solid black",
                                outline: "none",
                                boxShadow: "none",
                            },
                        },
                        dropdown: {
                            border: "2px solid black",
                            borderRadius: 0,
                            boxShadow: "none",
                        },
                        item: {
                            fontFamily: "Courier New, monospace",
                            "&[data-selected]": {
                                backgroundColor: "black",
                                color: "white",
                            },
                        },
                    }}
                />
            </Box>


        </div>
    )
}

export default SelectionBox


import React from 'react'

import { useState, useCallback } from 'react';
import { Button, Text, Box } from '@mantine/core';

import { useEventListener } from '@mantine/hooks';

import * as ActMku from "../../111.solid/10.miku.unit/miku.action";

var hunt, bit

function HorizontalSlider(bus) {

    hunt = window['SOLID']

    const [value, setValue] = useState(0);
    const [endValue, setEndValue] = useState(50);

    const increment = useCallback(() => setValue(async (c) => {
        c+=1
        hunt(ActMku.WRITE_MIKU, { idx: "mku00", dat: { position: { z: c } } })
    }),
        []);
    const ref = useEventListener('click', increment);

    return (
        <Box maw={400} mx="auto">
            <Button fullWidth ref={ref}>UP</Button>
        </Box>
    );
}

export default HorizontalSlider

import React from 'react'
import { useRef, useEffect, useState } from "react"
import { Title, Select, Button, Stack, Box, Text, rem } from "@mantine/core"
import "@mantine/core/styles.css"

import PixiBlock from '../base/pixi/block'


export default function PhaseThree() {

  let sim;
  let bus
  let dex = 0

  const setBus = (obj) => {
    if (dex > 0) return
    dex += 1
    sim = obj;
    
  };

  bus = (idx, bal) => sim.hunt(idx, bal)

  return (
    <div id='surface00' style={{ width: "100%" }}  >

      <PixiBlock setBus={setBus} />

         </div>
  )
}






.thumb {
    border: 1px solid light-dark(var(--mantine-color-gray-3), var(--mantine-color-dark-2));
    width: 28px;
    height: 22px;
    color: var(--mantine-color-gray-5);
    background-color: var(--mantine-color-white);
    border-radius: var(--mantine-radius-sm);
  }
import React from 'react'
import { useState, useEffect } from 'react';
import { Box, Divider, ScrollArea, Center, Button } from '@mantine/core';
import { Title, Text, Stack, Container, Group, Transition } from '@mantine/core';

import { Tabs } from '@mantine/core';
import { IconPhoto, IconMessageCircle, IconSettings, IconHourglassLow } from '@tabler/icons-react';

import { TaskCard } from './TaskCard';

import { Affix, Space, Grid } from '@mantine/core';

import * as Increment from '../../000.control/val/increment'

import Slider from './Slider'
const { useRef } = React;

import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'
import * as ActCtl from '../../000.control/00.control.unit/control.action'
import * as ActFoc from "../../002.space/02.focus.unit/focus.action"

var flag = false;

let bit

export default function Component() {

    const [opened, setOpened] = useState(false);
    const [count, setCount] = useState(false);

    const [form, setForm] = useState('-----------------------------------------------------------');

    const [colorListSize, setColorListSize] = useState(0);

    const [second, setSecond] = useState();
    const [minute, setMinute] = useState();
    const [hour, setHour] = useState();

    const [data, setData] = useState('');

    const [fadeIn, setFadein] = useState('invisible');

    const [activeSegment, setActiveSegment] = useState('sec');

    var secondsAction = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.SECONDS })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 1 })

        setTimeout(secondsRelease, 333)
    }

    var secondsRelease = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.DEFAULT })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 0 })
        await window['CONTROL'](ActCtl.UPDATE_CONTROL, { val: 1 })
    }


    var minutesAction = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.MINUTES })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 1 })

        setTimeout(minutesRelease, 333)
    }

    var minutesRelease = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.DEFAULT })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 0 })
        await window['CONTROL'](ActCtl.UPDATE_CONTROL, { val: 1 })
    }

    var hoursAction = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.HOURS })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 1 })

        setTimeout(hoursRelease, 333)
    }

    var hoursRelease = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.DEFAULT })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 0 })
        await window['CONTROL'](ActCtl.UPDATE_CONTROL, { val: 1 })
    }

    var daysAction = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.DAYS })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 1 })

        setTimeout(daysRelease, 333)
    }

    var daysRelease = async () => {
        await window['CONTROL'](ActCtl.INCREMENT_CONTROL, { src: Increment.DEFAULT })
        await window['CONTROL'](ActCtl.ACCESS_CONTROL, { val: 0 })
        await window['CONTROL'](ActCtl.UPDATE_CONTROL, { val: 1 })
    }

    var spinRight = () => window['SPACE'](ActFoc.SPIN_RIGHT_FOCUS, { idx: 'foc00' })
    var spinLeft = () => window['SPACE'](ActFoc.SPIN_LEFT_FOCUS, { idx: 'foc00' })
    var forward = () => window['SPACE'](ActFoc.FORWARD_FOCUS, { idx: 'foc00' })
    var backward = () => window['SPACE'](ActFoc.BACKWARD_FOCUS, { idx: 'foc00' })

    useEffect(() => {

        var animate = async () => {
            var bit = await window['CONTROL'](ActCtl.UPDATE_CONTROL, {})

            var now = bit.ctlBit.dat.now;
            var clrLstSize = bit.ctlBit.dat.colorListSize

            setForm(now.frm)
            setSecond(now.sec)
            setMinute(now.min)
            setHour(now.hrs)
            setColorListSize(clrLstSize)

            //requestAnimationFrame(animate);
        }

        setFadein('fade-in')

        //window.location.href = "test/pixel"
        var intervalId = setInterval(animate, 42)

        //requestAnimationFrame(animate);

        return () => {
            clearInterval(intervalId);
        };



    }, [])



    var testPage = async () => {
        window.location.href = './test'
    }


    return (

        <div >

            <Container className={fadeIn} size="sm" p={0} style={{ backgroundColor: '#ffff00', minHeight: '100vh', color: '#000' }}>

                <Space h="md" />

                <Grid>
                    <Grid.Col span={1}>
                    </Grid.Col>
                    <Grid.Col span={8}>

                        <Title size="xs">
                            {form}
                        </Title>

                    </Grid.Col>
                    <Grid.Col span={2}>

                        <Title size="xs">
                            Colors {colorListSize}
                        </Title>

                    </Grid.Col>

                </Grid>

                <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #00ff00' }}>

                    <Box style={{
                        width: '960px',
                        height: '112px',
                        position: 'relative',
                        backgroundSize: 'cover',
                        backgroundPosition: 'center',
                        overflow: "hidden"
                    }}>

                        <div id='surface00' />

                    </Box>
                </Box>

                <Tabs defaultValue="clock" color="green">

                    <Tabs.Panel value="gallery">

                        <Box p={5} h={130}>

                            <Stack gap="xs">

                                <Button size='xs' radius="xl" color='green' fullWidth onClick={forward} >
                                    Forward
                                </Button>

                                <Grid>
                                    <Grid.Col span={5}>
                                        <Button color='green' fullWidth size='xs' radius="xl" onClick={spinLeft} >
                                            Spin Left
                                        </Button>
                                    </Grid.Col>
                                    <Grid.Col span={2}>
                                        <Button size='xs' radius="xl" color='green' fullWidth onClick={backward} >
                                            Backward
                                        </Button>
                                    </Grid.Col>
                                    <Grid.Col span={5}>
                                        <Button size='xs' radius="xl" color='green' fullWidth onClick={spinRight} >
                                            Turn Right
                                        </Button>
                                    </Grid.Col>
                                </Grid>


                                <Grid >
                                    <Grid.Col span={3}>
                                        <Button color='yellow' fullWidth size='xs' onMouseDown={secondsAction} onMouseUp={secondsRelease} >
                                            Apply Pigment
                                        </Button>
                                    </Grid.Col>

                                    <Grid.Col span={3}>
                                        <Button size='xs' color='yellow' fullWidth onMouseDown={minutesAction} onMouseUp={minutesRelease} >
                                            Ponder
                                        </Button>
                                    </Grid.Col>

                                    <Grid.Col span={3}>
                                        <Button size='xs' color='yellow' fullWidth onMouseDown={hoursAction} onMouseUp={hoursRelease} >
                                            Suffer
                                        </Button>
                                    </Grid.Col>

                                    <Grid.Col span={3}>
                                        <Button size='xs' color='yellow' fullWidth onMouseDown={hoursAction} onMouseUp={hoursRelease} >
                                            Display Painting
                                        </Button>
                                    </Grid.Col>

                                </Grid>

                            </Stack>

                        </Box>

                    </Tabs.Panel>

                    <Tabs.Panel value="clock">

                        <Box p={50} h={130}>

                            <Stack gap="xs" >

                                <Grid>
                                    <Grid.Col span={3}>
                                        <Button size='xs' color='green' fullWidth onClick={daysAction}  >
                                            Days
                                        </Button>
                                    </Grid.Col>
                                    <Grid.Col span={3}>
                                        <Button size='xs' color='green' fullWidth onClick={hoursAction}  >
                                            Hours
                                        </Button>
                                    </Grid.Col>
                                    <Grid.Col span={3}>
                                        <Button size='xs' color='green' fullWidth onClick={minutesAction} >
                                            Minutes
                                        </Button>
                                    </Grid.Col>
                                    <Grid.Col span={3}>

                                        <Button color='green' fullWidth size='xs' onClick={secondsAction} >
                                            Seconds
                                        </Button>
                                    </Grid.Col>
                                </Grid>


                            </Stack>

                        </Box>

                    </Tabs.Panel>

                    <Tabs.Panel value="settings">

                        <Box p={12} h={130}>
                        </Box>

                    </Tabs.Panel>

                    <Divider color='green' />


                    <Tabs.List>

                        <Tabs.Tab value="clock" leftSection={<IconHourglassLow size={12} />}>
                            Clock
                        </Tabs.Tab>

                        <Tabs.Tab value="gallery" leftSection={<IconPhoto size={12} />}>
                            Play
                        </Tabs.Tab>

                        <Tabs.Tab value="settings" leftSection={<IconSettings size={12} />}>
                            Settings
                        </Tabs.Tab>
                    </Tabs.List>

                </Tabs>

                <Stack gap="xs">
                    <Divider color='green' />
                    <TaskCard />
                    <Space h="md" />
                    <TaskCard />
                    <Space h="md" />
                    <TaskCard />
                    <Space h="md" />
                    <TaskCard />
                </Stack>

            </Container>

            <Affix position={{ bottom: 20, right: 20 }}>
                <Text size='xs'>Version 0.0.2</Text>
            </Affix>

        </div>


    );





}
import { IconGripHorizontal } from '@tabler/icons-react';
import { Slider } from '@mantine/core';
import classes from './SliderWhite.module.css';
import React, { useState } from 'react'; // Import useState

interface SliderWhiteProps {
    value: number;
    onChange: (newValue: number) => void;
    // You can include other SliderProps here if you want to pass them through
    // For example: label?: SliderProps['label'];
  }

export default function SliderWhite( { value, onChange } ) : SliderWhiteProps {
 
 
  return (
    <Slider
      classNames={classes}
      thumbChildren={<IconGripHorizontal size={20} stroke={1.5} />}
      // defaultValue={40} // defaultValue is for uncontrolled components. Use 'value' for controlled.
      value={value}         // Control the slider's value with the state variable
      onChange={onChange}    // Update the state when the slider value changes
      // Or use a custom handler: onChange={handleChange}
      label={null} // Mantine's Slider `label` prop can be a function (value) => React.ReactNode or null
                   // If you want to display the current value, you can do: label={(val) => val}
                   // Or keep it null if no label is desired.
    />
    // Optional: Display the current value for debugging or UI purposes
    // <div style={{ marginTop: 10 }}>Current Value: {value}</div>
  );
}
import React from 'react'
import { IconUpload } from '@tabler/icons-react';
import { ActionIcon, Avatar, Badge, Card, Group, Progress, Text, Image } from '@mantine/core';

const avatars = [
  'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-2.png',
  'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-4.png',
  'https://raw.githubusercontent.com/mantinedev/mantine/master/.demo/avatars/avatar-7.png',
];

export function TaskCard() {
  return (
    <Card  withBorder padding="lg" radius="xl" shadow="xl" >

      <Card.Section>
        <Image
          src="./img/017.png"
          alt="Running challenge"
          height={224}
        />
      </Card.Section>

      <Text fz="lg" fw={500} mt="md">
        5.3 minor release (September 2022)
      </Text>
      <Text fz="sm" c="dimmed" mt={5}>
        Form context management, Switch, Grid and Indicator components improvements, new hook and
        10+ other changes
      </Text>

      <Text c="dimmed" fz="sm" mt="md">
        Tasks completed:{' '}
        <Text span fw={500} c="bright">
          23/36
        </Text>
      </Text>

      <Progress value={(23 / 36) * 100} mt={5} />

    </Card>
  );
}
import React from 'react';
import { Box, ScrollArea } from '@mantine/core';

import { useState, useEffect } from 'react';

import Scene from './Scene'

const buttonStyles = {
    root: {
        width: '100%',
        height: '50px',
        fontFamily: 'Arial, sans-serif',
        fontSize: '20px',
        fontWeight: 700,
        borderRadius: 0,
        border: 'none',
        marginBottom: '8px',
        transition: 'background-color 0.2s',
    },
};

function GameMenu() {

    return (
        <Box
            style={{
                width: '1280px',
                height: '720px',
                position: 'relative'
            }}

        >

            <Scene />


        </Box>
    );
}

export default function AmericanFugitiveMenu() {
    return (
        <div>
            <GameMenu />
            \
        </div>
    );
}


import React from 'react'

import { Button, Box, rem } from "@mantine/core"


import * as ActSld from "../../111.solid/00.solid.unit/solid.action";
import * as ActBab from "../../111.solid/01.babylon.unit/babylon.action";


var recording = false;
var hunt 

function RecordButton(bus) {

  hunt = bus.bus
  
  
  
  
  const record = async () => {

    if (recording == false) {
      recording = true;

      hunt
      

      var bit = await hunt(ActBab.ACTION_BABYLON, { idx: "txt01", dat: { txt: 'testing gator man' } })
      return
    }


    var bit = await hunt(ActBab.CUT_BABYLON, { idx: "txt01", dat: { txt: 'testing gator man' } })
    return


    // bit = await SOLID.hunt( "[Babylon action] Record Babylon", { src: "surface00" })

  }



  return (
    <div>


      {/* Black LORA Button - positioned between header and first input */}
      <Box
        style={{
          marginBottom: rem(30),
          width: "100%",
        }}
      >
        <Button
          onClick={record}
          fullWidth
          styles={{
            root: {
              height: rem(60),
              backgroundColor: "#000000",
              color: "#FFFFFF",
              border: "3px solid black",
              borderRadius: 0,
              position: "relative",
              "&:hover": {
                backgroundColor: "#333333",
              },
            },
            label: {
              fontSize: rem(24),
              fontWeight: 700,
              fontFamily: "Courier New, monospace",
              letterSpacing: "3px",
              color: "#FFFFFF",
            },
          }}
        >
          RECORD
        </Button>
      </Box>


    </div>
  )
}

export default RecordButton

import React from 'react'
import { useState, useEffect } from 'react';
import { Box, Divider, ScrollArea } from '@mantine/core';

import RecordButton from './RecordButton'
import SelectionBox from './SelectionBox'
import Slider from './Slider'

import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'

import * as ActMku from '../../111.solid/10.miku.unit/miku.action'

import * as ActScr from '../../111.solid/08.screen.unit/screen.action'

export default function Component() {

    

    setTimeout( async ()=>{
        await window['SOLID']( ActBab.OPEN_BABYLON, {src:'surface00'})
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', src: 'slop/slop00.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', dat: { position: { z: 40, x: -15 } } })
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00' })
    }, 333)

    
    return (
        <Box>

            <Box style={{
                width: '1920px',
                height: '1080px',
                position: 'relative',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                overflow: "hidden"
            }}>

                <canvas id='surface00' />

            </Box>



            <Divider my="md" />
            <RecordButton />
            <Divider my="md" />
            <SelectionBox/>
            <Divider my="md" />
            <Slider/>



        </Box>

    );
}
import React from 'react'
import { useState } from "react"
import { Select, Box, Text, rem } from "@mantine/core"


function SelectionBox() {



    const handleLibraryChange = (value, index) => {
        if (value) {
            const newLibraries = [...libraries]
            newLibraries[index] = value
            setLibraries(newLibraries)
        }
    }

    const libraryOptions = [
        { value: "Spouse", label: "Spouse" },
        { value: "Champion", label: "Champion" },
        { value: "Tyrant", label: "Tyrant" },
        { value: "Martyr", label: "Martyr" },
        { value: "Addict", label: "Addict" },
        { value: "Hag", label: "Hag" },
        { value: "Ambassador", label: "Ambassador" },
        { value: "Innocent", label: "Innocent" },
        { value: "Outlaw", label: "Outlaw" },
        { value: "Prophet", label: "Prophet" },
        { value: "Academic", label: "Academic" },
        { value: "Primal", label: "Primal" },
        { value: "Pastoral", label: "Pastoral" },
    ]



    const [libraries, setLibraries] = useState(["Angular", "Angular", "Angular"])

    var index = 0

    return (
        <div>

            <Box
                key={index}
                style={{
                    border: "2px solid black",
                    padding: rem(15),
                    backgroundColor: index % 2 === 0 ? "#FFFFFF" : "#F0F0F0",
                }}
            >
                <Text
                    style={{
                        fontFamily: "Courier New, monospace",
                        fontWeight: "bold",
                        marginBottom: rem(8),
                        textTransform: "uppercase",
                    }}
                >
                    INPUT {index + 1}: MESH
                </Text>
                <Select
                    placeholder="SEARCH MESH..."
                    value=""
                    onChange={(value) => handleLibraryChange(value, index)}
                    data={libraryOptions}
                    searchable
                    nothingFoundMessage="NO MESH FOUND"
                    styles={{
                        input: {
                            height: rem(45),
                            border: "2px solid black",
                            fontFamily: "Courier New, monospace",
                            fontSize: rem(14),
                            backgroundColor: "#FFFFFF",
                            "&:focus": {
                                border: "2px solid black",
                                outline: "none",
                                boxShadow: "none",
                            },
                        },
                        dropdown: {
                            border: "2px solid black",
                            borderRadius: 0,
                            boxShadow: "none",
                        },
                        item: {
                            fontFamily: "Courier New, monospace",
                            "&[data-selected]": {
                                backgroundColor: "black",
                                color: "white",
                            },
                        },
                    }}
                />
            </Box>


        </div>
    )
}

export default SelectionBox


import React from 'react'

import { useState, useCallback } from 'react';
import { Button, Text, Box } from '@mantine/core';

import { useEventListener } from '@mantine/hooks';

import * as ActMku from "../../111.solid/10.miku.unit/miku.action";

var hunt, bit

function HorizontalSlider(bus) {

    hunt = window['SOLID']

    const [value, setValue] = useState(0);
    const [endValue, setEndValue] = useState(50);

    const increment = useCallback(() => setValue(async (c) => {
        c+=1
        hunt(ActMku.WRITE_MIKU, { idx: "mku00", dat: { position: { z: c } } })
    }),
        []);
    const ref = useEventListener('click', increment);

    return (
        <Box maw={400} mx="auto">
            <Button fullWidth ref={ref}>UP</Button>
        </Box>
    );
}

export default HorizontalSlider

"use client"
import { Text, Divider } from '@mantine/core'

import React from 'react'
import { useUpdateEarth } from '../../queue/earth.query'

import { Box, ScrollArea, Center } from '@mantine/core';

import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'

import * as ActMku from '../../111.solid/10.miku.unit/miku.action'

import * as ActScr from '../../111.solid/08.screen.unit/screen.action'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useUpdateEarth()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    //now you can do what ever you want to with the data

    setTimeout(async () => {
      await window['SOLID'](ActBab.OPEN_BABYLON, { src: 'surface00' })

      for (var i = 0; i < 100; i++) {


        var idx = 'milu' + i 
        var pos = i * 10;

        await window['SOLID'](ActMku.WRITE_MIKU, { idx, src: 'glop/000.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, {  idx, dat: { position: { z: 40, x: pos, y: -16 } } })




      }




      //await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', src: 'slop/slop00.pmx', dat: { position: { z: -7 } } })
      //await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', dat: { position: { z: 40, x: 35, y: -16 } } })

      //await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00' })
      //await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00', dat: { position: { z: 40, x: -35, y: -16 }, rotation: { z: 0, x: 0, y: 0 } } })




    }, 333)

    return (<div>

      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Is the Earth Pivot present?
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>


      <Center maw={1920} h={1080} bg="var(--mantine-color-green-light)">
        <Box bg="var(--mantine-color-red-light)">


          <Box style={{
            width: '1920px',
            height: '1080px',
            position: 'relative',
            backgroundSize: 'cover',
            backgroundPosition: 'center',
            overflow: "hidden"
          }}>

            <canvas id='surface00' />

          </Box>


        </Box>
      </Center>






      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening...
    </div>
  )


}

export default Test

import React from 'react'
import { useState, useEffect } from 'react';
import { Box, Divider, ScrollArea, Center } from '@mantine/core';


import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'

import * as ActMku from '../../111.solid/10.miku.unit/miku.action'

import * as ActScr from '../../111.solid/08.screen.unit/screen.action'

export default function Component() {

    setTimeout( async ()=>{
        await window['SOLID']( ActBab.OPEN_BABYLON, {src:'surface00'})
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', src: 'slop/003.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku00a', dat: { position: { z: 40, x: -15, y:-16 } } })
        
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', src: 'slop/slop00.pmx', dat: { position: { z: -7 } } })
        await window['SOLID'](ActMku.WRITE_MIKU, { idx: 'mku01a', dat: { position: { z: 40, x: 35, y:-16 } } })
        
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00' })
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src00', dat: { position: { z: 40, x: -35, y:-16 }, rotation: { z: 0, x: 0, y:0 } } })
  
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src01' })
        await window['SOLID'](ActScr.WRITE_SCREEN, { idx: 'src01', dat: { position: { z: 40, x: 35, y:-16 } } } )
   
        

    }, 333)

    
    return (

        <Center maw={1920} h={1080} bg="var(--mantine-color-green-light)">
        <Box bg="var(--mantine-color-red-light)">


        <Box style={{
                width: '1920px',
                height: '1080px',
                position: 'relative',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                overflow: "hidden"
            }}>

                <canvas id='surface00' />

            </Box>


        </Box>
      </Center>

        

    );
}
"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useInitControl } from '../../../queue/control.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useInitControl()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Is the Control Pivot present?
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening...
    </div>
  )


}

export default Test



import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import ControlInit from './controlTest/ControlInit'

export default function ContentsPage() {

  var act00 = () => {
    document.location.href = './shade/surface-test'
  }

  var act01 = () => {
    document.location.href = './solid/open-babylon'
  }

  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          CONTROL TEST
        </Title>

        <Text>--------------------------------------------------------------------------------------------------------------------------------------------------------</Text>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ControlInit/>
          </Box>

        </Stack>

        

      </Box>
    </Container>
  );
}

"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useFetchColor } from '../../../queue/pixel.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useFetchColor()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Fetching Color Data
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening...
    </div>
  )


}

export default Test



"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useInitEarth } from '../../../queue/earth.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useInitEarth()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Is the Earth Pivot present?
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening...
    </div>
  )


}

export default Test



import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import EarthInit from './earthTest/EarthInit'

export default function ContentsPage() {


  var act00 = () => {
    document.location.href = './shade/surface-test'
  }

  var act01 = () => {
    document.location.href = './solid/open-babylon'
  }



  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          EARTH TEST
        </Title>

        <Text>--------------------------------------------------------------------------------------------------------------------------------------------------------</Text>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <EarthInit/>
          </Box>

          

        </Stack>

        

      </Box>
    </Container>
  );
}

import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';


export default function ContentsPage() {


  var act00 = () => {
    document.location.href = './test/earth'
  }

  var act01 = () => {
    document.location.href = './test/control'
  }

  var act02 = () => {
    document.location.href = './test/space'
  }

  var act03 = () => {
    document.location.href = './test/time'
  }

  var act04 = () => {
    document.location.href = './test/shade'
  }

  var act05 = () => {
    document.location.href = './play'
  }



  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          TESTING
        </Title>

        <Title order={2} style={{ fontSize: 24, fontWeight: 500, marginBottom: 40 }}>
          PRIMAL.MAMA
        </Title>


        <Text>--------------------------------------------------------------------------------------------------------------------------------------------------------</Text>


        <Stack >

          

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <Button fullWidth variant="outline" color="black" onClick={act05} > OPEN SOLID TEST </Button>
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <Button fullWidth variant="outline" color="black" onClick={act01} > OPEN CONTROL TEST </Button>
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <Button fullWidth variant="outline" color="black" onClick={act03} > OPEN TIME TEST </Button>
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <Button fullWidth variant="outline" color="black" onClick={act00} > OPEN EARTH TEST </Button>
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <Button fullWidth variant="outline" color="black" onClick={act02} > OPEN SPACE TEST </Button>
          </Box>

        </Stack>


      </Box>
    </Container>
  );
}

import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import SpaceInit from './spaceTest/SpaceInit'

export default function ContentsPage() {

  setTimeout( ()=>{
    //window['SOLID']( ActBab.OPEN_BABYLON, {src:'surface00'})
}, 333)


  var act00 = () => {
    document.location.href = './shade/surface-test'
  }

  var act01 = () => {
    document.location.href = './solid/open-babylon'
  }



  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          Shade TEST
        </Title>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>

          <Box style={{
                width: '1280px',
                height: '720px',
                position: 'relative',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                overflow: "hidden"
            }}>

                <canvas id='surface00' />

            </Box>
            
          </Box>

        </Stack>

        

      </Box>
    </Container>
  );
}

import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import SpaceInit from './spaceTest/SpaceInit'

import * as ActBab from '../../111.solid/01.babylon.unit/babylon.action'

export default function ContentsPage() {

  setTimeout( ()=>{
    window['SOLID']( ActBab.OPEN_BABYLON, {src:'surface00'})
}, 333)



  var act00 = () => {
    document.location.href = './shade/surface-test'
  }

  var act01 = () => {
    document.location.href = './solid/open-babylon'
  }

  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          Solid TEST
        </Title>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>


            <Box style={{
              width: '1280px',
              height: '720px',
              position: 'relative',
              backgroundSize: 'cover',
              backgroundPosition: 'center',
              overflow: "hidden"
            }}>

              <canvas id='surface00' />

            </Box>


          </Box>

        </Stack>



      </Box>
    </Container>
  );
}

"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useInitSpace } from '../../../queue/space.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useInitSpace()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Is the Space Pivot present?
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening space pivot...
    </div>
  )


}

export default Test



import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import SpaceInit from './spaceTest/SpaceInit'

export default function ContentsPage() {


  var act00 = () => {
    document.location.href = './shade/surface-test'
  }

  var act01 = () => {
    document.location.href = './solid/open-babylon'
  }



  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          Space TEST
        </Title>

        <Text>--------------------------------------------------------------------------------------------------------------------------------------------------------</Text>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <SpaceInit/>
          </Box>

        </Stack>

        

      </Box>
    </Container>
  );
}

"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useListClock } from '../../../queue/time.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useListClock()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        List Clock
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      listing clock...
    </div>
  )


}

export default Test



// ClockReadDisplay.tsx
"use client"; // If using Next.js App Router and this component has client-side interactions

import React, { useState } from 'react';
import { Button, Text, Box, Loader, Alert } from '@mantine/core';
import * as ActPrg from "../../../001.time/01.progress.unit/progress.action"; // Adjust path as needed

const ClockReadDisplay = () => {
    const [data, setData] = useState<any | null>(null); // Changed type to 'any' for direct data
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    // const [hasFetched, setHasFetched] = useState(false); // No longer strictly needed if button always shows

    const handleFetchData = async () => {
        setIsLoading(true);
        setError(null);
        setData(null); // Clear previous data on new fetch attempt
        // setHasFetched(true); // If you still want to track first fetch for other logic

        try {
            if (typeof window !== 'undefined' && typeof window['TIME'] === 'function') {
                const bit = await window['TIME'](ActPrg.UPDATE_PROGRESS, { idx: 'increment0', src:'clock0' });
                setData(bit); // Store the raw bit data
            } else {
                throw new Error("window['TIME'] function is not available.");
            }
        } catch (e: any) {
            setError(e.message || "An error occurred while fetching data.");
            console.error("Error fetching clock data:", e);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Box style={{ width: '100%' }}>
            <Button 
              fullWidth 
              variant="outline" 
              color="black" 
              onClick={handleFetchData} 
              disabled={isLoading}
              mb="md" // Add margin below button for spacing
            >
                {isLoading ? <Loader size="xs" /> : 'PROGRESS CLOCK'}
            </Button>
            
            {isLoading && ( // Show loader while loading, irrespective of hasFetched
                <Box mt="md" style={{ display: 'flex', justifyContent: 'center' }}>
                    <Loader />
                </Box>
            )}

            {error && ( // Show error if an error occurred
                <Alert title="Error" color="red" mt="md">
                    {error}
                </Alert>
            )}

            {data && !isLoading && !error && ( // Show data only if not loading and no error
                <Text c='green' size="md" style={{ lineHeight: 1.6, whiteSpace: 'pre-wrap', wordBreak: 'break-all' }}>
                    {JSON.stringify(data)} {/* Stringify with pretty print */}
                </Text>
            )}

        </Box>
    );
};

export default ClockReadDisplay;
// ClockReadDisplay.tsx
"use client"; // If using Next.js App Router and this component has client-side interactions

import React, { useState } from 'react';
import { Button, Text, Box, Loader, Alert } from '@mantine/core';
import * as ActClk from "../../../001.time/03.clock.unit/clock.action"; // Adjust path as needed

const ClockReadDisplay = () => {
    const [data, setData] = useState<string | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [hasFetched, setHasFetched] = useState(false); // New state to track if fetch has been initiated

    const handleFetchData = async () => {
        setIsLoading(true);
        setError(null);
        setData(null);
        setHasFetched(true); // Set to true immediately on click

        try {
            if (typeof window !== 'undefined' && typeof window['TIME'] === 'function') {
                const bit = await window['TIME'](ActClk.READ_CLOCK, { idx: 'clk00' });
                setData(bit);
            } else {
                throw new Error("window['TIME'] function is not available.");
            }
        } catch (e: any) {
            setError(e.message || "An error occurred while fetching data.");
            console.error("Error fetching clock data:", e);
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <Box style={{ width: '100%' }}>
            {!hasFetched && ( // Only render the button if fetch has not been initiated
                <Button fullWidth variant="outline" color="black" onClick={handleFetchData} disabled={isLoading}>
                    {isLoading ? <Loader size="xs" /> : 'FETCH AND DISPLAY CLOCK READ'}
                </Button>
            )}

            {isLoading && hasFetched && ( // Show loader only after click and while loading
                <Box mt="md" style={{ display: 'flex', justifyContent: 'center' }}>
                    <Loader />
                </Box>
            )}

            {error && hasFetched && ( // Show error only after fetch attempt
                <Alert title="Error" color="red" mt="md">
                    {error}
                </Alert>
            )}

            <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
                Read Clock
            </Text>

            {data && hasFetched && ( // Show data only after successful fetch attempt

                <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
                    {JSON.stringify(data)}
                </Text>

            )}

            {/* Optional: Message if nothing is fetched yet and button is gone (e.g., initial state of a component designed to fetch once) */}
            {/* This might not be needed if the button click is the only way to get here */}
            {/* {!isLoading && !data && !error && hasFetched && (
        <Text mt="md" c="dimmed">Fetch initiated. No data or error to display yet.</Text>
      )} */}
        </Box>
    );
};

export default ClockReadDisplay;
"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useWriteClock } from '../../../queue/time.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useWriteClock('clock0', {yrs:1978, mth:4, day:11})

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Write Clock
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      writing clock...
    </div>
  )


}

export default Test



"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useWriteClockIncrement } from '../../../queue/time.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useWriteClockIncrement('increment0', {sec:6 })

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Write Clock Increment
      </Text>

      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      writing clock...
    </div>
  )


}

export default Test



"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useInitTime } from '../../../queue/time.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useInitTime()

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Is the Time Pivot present?
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      opening time pivot...
    </div>
  )


}

export default Test



"use client"
import { Text,  Divider } from '@mantine/core'

import React from 'react'
import { useRandomTime } from '../../../queue/time.query'

const Test = () => {

  //const data = {}
  const { data, error, fetchStatus } = useRandomTime('clk00')

  //if (error) return (<div> ERROR: {data['error']} </div>)
  if (data) {

    return (<div>
      
      <Text c="dark" size="md" style={{ lineHeight: 1.6 }}>
        Random Time
      </Text>



      <Text c='green' size="md" style={{ lineHeight: 1.6 }}>
        {JSON.stringify(data)}
      </Text>

      <Divider></Divider>



    </div>)
  }

  return (
    <div>
      randoming time...
    </div>
  )


}

export default Test



import React from 'react'

import { Button } from '@mantine/core';
import { Box, Title, Text, Stack, Container } from '@mantine/core';

import TimeInit from './timeTest/TimeInit'
import TimeRandom from './timeTest/TimeRandom'
import ClockWrite from './timeTest/ClockWrite'
import ClockWriteIncrement from './timeTest/ClockWriteIncrement'
import ClockList from './timeTest/ClockList'
import ClockReadDisplay from './timeTest/ClockReadDisplay'
import ClockProgressDisplay from './timeTest/ClockProgressDisplay'

import * as ActClk from "../../001.time/03.clock.unit/clock.action";

export default function ContentsPage() {

  document.body.style.overflow = 'visible';


  var act00 = async () => {
    var bit = await window['TIME'](ActClk.READ_CLOCK, { idx: 'clk00' })
    alert(JSON.stringify(bit))
  }





  return (
    <Container size="md" p={0} style={{ backgroundColor: '#ab9d77', minHeight: '100vh', color: '#000' }}>
      <Box p={40}>
        <Title order={1} style={{ fontSize: 72, fontWeight: 300, marginBottom: 40 }}>
          TIME TEST
        </Title>

        <Text>--------------------------------------------------------------------------------------------------------------------------------------------------------</Text>

        <Stack >

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ClockProgressDisplay />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ClockWrite />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ClockWriteIncrement />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <TimeRandom />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ClockReadDisplay />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <ClockList />
          </Box>

          <Box style={{ display: 'flex', justifyContent: 'space-between', borderBottom: '1px solid #000' }}>
            <TimeInit />
          </Box>

        </Stack>

      </Box>
    </Container>
  );
}

import React from 'react';
import { Box} from '@mantine/core';

import { useState, useEffect } from 'react';

import Title from './Title'

const buttonStyles = {
    root: {
        width: '100%',
        height: '50px',
        fontFamily: 'Arial, sans-serif',
        fontSize: '20px',
        fontWeight: 700,
        borderRadius: 0,
        border: 'none',
        marginBottom: '8px',
        transition: 'background-color 0.2s',
    },
};

function GameMenu() {
    const menuItems = ['CONTROLS', 'GAMEPAD', 'GRAPHICS', 'AUDIO', 'BACK'];

    const [flickerOpacity, setFlickerOpacity] = useState(1);


    // Film flicker effect
    useEffect(() => {
        const flickerInterval = setInterval(() => {
            const randomOpacity = Math.random() * 0.1 + 0.9; // Between 0.9 and 1.0
            setFlickerOpacity(randomOpacity);
        }, 100);

        return () => clearInterval(flickerInterval);
    }, []);

    return (
        <Box
            style={{
                width: '1280px',
                height: '720px',
                overflow: 'hidden',
                backgroundImage: 'url(./img/017.png)',
                backgroundSize: 'cover',
                backgroundPosition: 'center',
                opacity: flickerOpacity
            }}

        >

            <Title/>


        </Box>
    );
}

export default function AmericanFugitiveMenu() {
    return (
        <div>
            <GameMenu />
        </div>
    );
}


'use client'
import { redirect } from '@tanstack/react-router'
import React from 'react'
import { useState, useEffect } from 'react';
import {
    Box,
    Title,
    Text,
    Button,
    Stack,
    Space,
    //createStyles, 
    MantineProvider,
    MantineThemeOverride,
    Overlay,
    Affix
} from '@mantine/core';

import { Link } from '@tanstack/react-router'


//import { IconSkull } from '@tabler/icons-react';
//<IconSkull size={16} />
// Custom theme for Swamp Water (1941) aesthetic
const theme: MantineThemeOverride = {

};

//const useStyles = createStyles((theme) => ());

export default function Component() {
    //const { classes, cx } = useStyles();
    const [activeOption, setActiveOption] = useState('GAME');
    const [flickerOpacity, setFlickerOpacity] = useState(1);

    var act00 = () => {
        document.location.href = '/scene'
    }

    var act01 = () => {
        document.location.href = '/test'
    }

    var actionThree = () => {

        document.location.href = '/camera'


    }



    // Film flicker effect
    useEffect(() => {
        const flickerInterval = setInterval(() => {
            const randomOpacity = Math.random() * 0.1 + 0.9; // Between 0.9 and 1.0
            setFlickerOpacity(randomOpacity);
        }, 100);

        return () => clearInterval(flickerInterval);
    }, []);

    return (
        <Box className={'wrapper'} style={{ opacity: flickerOpacity }}>
            <div className={'swampFog'} />
            <div className={'fogPatches'} />

            <Box style={{ paddingLeft: '94px', }} className={'titleContainer'}>
                <Title className={'title'} order={1} size={126}>
                    GLOPS.LIVE
                </Title>
                <Text style={{ paddingLeft: '10px' }} className={'subtitle'} size="xs">
                    v0.0.0
                </Text>
            </Box>





            <Stack className={'menuContainer'} style={{ paddingTop: '400px', paddingLeft: '400px' }} justify="flex-end">

                <Button
                    key='0'
                    className={'menuButton'}
                    onClick={act00}
                    size="lg"
                    fullWidth
                    style={{ height: '33px', width: '1000px' }}
                >
                    PLAY
                </Button>



                <Button
                    key='0'
                    className={'menuButton'}
                    size="lg"
                    fullWidth
                    style={{ height: '33px', width: '1000px' }}
                    onClick={act01}
                >
                    TEST

                </Button>



            </Stack>



        </Box>

    );
}